/* automatically generated by rust-bindgen */

pub use self::pj_ssl_entropy as pj_ssl_entropy_t;

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
    where
        Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}

impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
    where
        Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self {
            storage,
            align: [],
        }
    }

    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];

        let bit_index =
            if cfg!(target_endian = "big") {
                7 - (index % 8)
            } else {
                index % 8
            };

        let mask = 1 << bit_index;

        byte & mask == mask
    }

    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];

        let bit_index =
            if cfg!(target_endian = "big") {
                7 - (index % 8)
            } else {
                index % 8
            };

        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }

    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        let mut val = 0;

        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index =
                    if cfg!(target_endian = "big") {
                        bit_width as usize - 1 - i
                    } else {
                        i
                    };
                val |= 1 << index;
            }
        }

        val
    }

    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index =
                if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}

pub const PJMEDIA_AUDIO_DEV_HAS_ALSA: u32 = 0;
pub const PJMEDIA_AUDIO_DEV_HAS_PORTAUDIO: u32 = 1;
pub const PJMEDIA_CONF_USE_SWITCH_BOARD: u32 = 1;
pub const PJMEDIA_STREAM_VAD_SUSPEND_MSEC: u32 = 0;
pub const PJSUA_MAX_ACC: u32 = 12;
pub const PJMEDIA_HAS_L16_CODEC: u32 = 0;
pub const PJMEDIA_HAS_GSM_CODEC: u32 = 0;
pub const PJMEDIA_HAS_SPEEX_CODEC: u32 = 0;
pub const PJMEDIA_CODEC_SPEEX_DEFAULT_COMPLEXITY: u32 = 2;
pub const PJMEDIA_CODEC_SPEEX_DEFAULT_QUALITY: u32 = 8;
pub const PJMEDIA_HAS_ILBC_CODEC: u32 = 0;
pub const PJMEDIA_HAS_G722_CODEC: u32 = 0;
pub const PJMEDIA_G722_DEFAULT_PCM_SHIFT: u32 = 2;
pub const PJMEDIA_G722_STOP_PCM_SHIFT_ON_CLIPPING: u32 = 1;
pub const PJMEDIA_HAS_INTEL_IPP: u32 = 0;
pub const PJMEDIA_AUTO_LINK_IPP_LIBS: u32 = 0;
pub const PJMEDIA_HAS_INTEL_IPP_CODEC_AMR: u32 = 0;
pub const PJMEDIA_HAS_INTEL_IPP_CODEC_AMRWB: u32 = 0;
pub const PJMEDIA_HAS_INTEL_IPP_CODEC_G729: u32 = 0;
pub const PJMEDIA_HAS_INTEL_IPP_CODEC_G723_1: u32 = 0;
pub const PJMEDIA_HAS_INTEL_IPP_CODEC_G726: u32 = 0;
pub const PJMEDIA_HAS_INTEL_IPP_CODEC_G728: u32 = 0;
pub const PJMEDIA_HAS_INTEL_IPP_CODEC_G722_1: u32 = 0;
pub const PJMEDIA_HAS_PASSTHROUGH_CODECS: u32 = 0;
pub const PJMEDIA_HAS_PASSTHROUGH_CODEC_AMR: u32 = 0;
pub const PJMEDIA_HAS_PASSTHROUGH_CODEC_G729: u32 = 0;
pub const PJMEDIA_HAS_PASSTHROUGH_CODEC_ILBC: u32 = 0;
pub const PJMEDIA_HAS_PASSTHROUGH_CODEC_PCMU: u32 = 1;
pub const PJMEDIA_HAS_PASSTHROUGH_CODEC_PCMA: u32 = 1;
pub const PJMEDIA_HAS_G7221_CODEC: u32 = 0;
pub const PJMEDIA_HAS_OPENCORE_AMRNB_CODEC: u32 = 0;
pub const PJMEDIA_HAS_OPENCORE_AMRWB_CODEC: u32 = 0;
pub const PJMEDIA_AUTO_LINK_OPENCORE_AMR_LIBS: u32 = 0;
pub const PJMEDIA_OPENCORE_AMR_BUILT_WITH_GCC: u32 = 0;
pub const PJMEDIA_G7221_DEFAULT_PCM_SHIFT: u32 = 0;
pub const PJMEDIA_HAS_SILK_CODEC: u32 = 0;
pub const PJMEDIA_CODEC_SILK_DEFAULT_COMPLEXITY: u32 = 2;
pub const PJMEDIA_CODEC_SILK_DEFAULT_QUALITY: u32 = 10;
pub const PJMEDIA_HAS_OPUS_CODEC: u32 = 0;
pub const PJMEDIA_CODEC_OPUS_DEFAULT_SAMPLE_RATE: u32 = 48000;
pub const PJMEDIA_CODEC_OPUS_DEFAULT_BIT_RATE: u32 = 0;
pub const PJMEDIA_CODEC_OPUS_DEFAULT_COMPLEXITY: u32 = 5;
pub const PJ_IS_LITTLE_ENDIAN: u32 = 1;
pub const PJ_IS_BIG_ENDIAN: u32 = 0;
pub const PJ_CC_NAME: &'static [u8; 4usize] = b"gcc\0";
pub const PJ_HAS_INT64: u32 = 1;
pub const PJ_INT64_FMT: &'static [u8; 2usize] = b"L\0";
pub const PJ_LINUX: u32 = 1;
pub const PJ_OS_NAME: &'static [u8; 6usize] = b"linux\0";
pub const PJ_HAS_ARPA_INET_H: u32 = 1;
pub const PJ_HAS_ASSERT_H: u32 = 1;
pub const PJ_HAS_CTYPE_H: u32 = 1;
pub const PJ_HAS_ERRNO_H: u32 = 1;
pub const PJ_HAS_LINUX_SOCKET_H: u32 = 0;
pub const PJ_HAS_MALLOC_H: u32 = 1;
pub const PJ_HAS_NETDB_H: u32 = 1;
pub const PJ_HAS_NETINET_IN_H: u32 = 1;
pub const PJ_HAS_SETJMP_H: u32 = 1;
pub const PJ_HAS_STDARG_H: u32 = 1;
pub const PJ_HAS_STDDEF_H: u32 = 1;
pub const PJ_HAS_STDIO_H: u32 = 1;
pub const PJ_HAS_STDLIB_H: u32 = 1;
pub const PJ_HAS_STRING_H: u32 = 1;
pub const PJ_HAS_SYS_IOCTL_H: u32 = 1;
pub const PJ_HAS_SYS_SELECT_H: u32 = 1;
pub const PJ_HAS_SYS_SOCKET_H: u32 = 1;
pub const PJ_HAS_SYS_TIME_H: u32 = 1;
pub const PJ_HAS_SYS_TIMEB_H: u32 = 1;
pub const PJ_HAS_SYS_TYPES_H: u32 = 1;
pub const PJ_HAS_TIME_H: u32 = 1;
pub const PJ_HAS_UNISTD_H: u32 = 1;
pub const PJ_HAS_SEMAPHORE_H: u32 = 1;
pub const PJ_HAS_MSWSOCK_H: u32 = 0;
pub const PJ_HAS_WINSOCK_H: u32 = 0;
pub const PJ_HAS_WINSOCK2_H: u32 = 0;
pub const PJ_HAS_LOCALTIME_R: u32 = 1;
pub const PJ_SOCK_HAS_INET_ATON: u32 = 1;
pub const PJ_SOCKADDR_HAS_LEN: u32 = 0;
pub const PJ_SELECT_NEEDS_NFDS: u32 = 0;
pub const PJ_HAS_ERRNO_VAR: u32 = 1;
pub const PJ_HAS_SO_ERROR: u32 = 1;
pub const PJ_HAS_THREADS: u32 = 1;
pub const PJ_HAS_HIGH_RES_TIMER: u32 = 1;
pub const PJ_HAS_MALLOC: u32 = 1;
pub const PJ_OS_HAS_CHECK_STACK: u32 = 0;
pub const PJ_NATIVE_STRING_IS_UNICODE: u32 = 0;
pub const PJ_EMULATE_RWMUTEX: u32 = 0;
pub const PJ_THREAD_SET_STACK_SIZE: u32 = 0;
pub const PJ_THREAD_ALLOCATE_STACK: u32 = 0;
pub const PJ_HAS_SOCKLEN_T: u32 = 1;
pub const PJ_HAS_PENTIUM: u32 = 0;
pub const PJ_DEBUG: u32 = 1;
pub const PJ_DEBUG_MUTEX: u32 = 0;
pub const PJ_FUNCTIONS_ARE_INLINED: u32 = 0;
pub const PJ_HAS_FLOATING_POINT: u32 = 1;
pub const PJ_LOG_MAX_LEVEL: u32 = 5;
pub const PJ_LOG_MAX_SIZE: u32 = 4000;
pub const PJ_LOG_USE_STACK_BUFFER: u32 = 1;
pub const PJ_LOG_ENABLE_INDENT: u32 = 1;
pub const PJ_LOG_INDENT_SIZE: u32 = 1;
pub const PJ_LOG_INDENT_CHAR: u8 = 46u8;
pub const PJ_LOG_SENDER_WIDTH: u32 = 14;
pub const PJ_LOG_THREAD_WIDTH: u32 = 12;
pub const PJ_TERM_HAS_COLOR: u32 = 1;
pub const PJ_SAFE_POOL: u32 = 0;
pub const PJ_POOL_DEBUG: u32 = 0;
pub const PJ_TIMER_DEBUG: u32 = 0;
pub const PJ_GRP_LOCK_DEBUG: u32 = 0;
pub const PJ_THREAD_DEFAULT_STACK_SIZE: u32 = 8192;
pub const PJ_HAS_POOL_ALT_API: u32 = 0;
pub const PJ_HAS_TCP: u32 = 1;
pub const PJ_HAS_IPV6: u32 = 0;
pub const PJ_MAX_HOSTNAME: u32 = 128;
pub const PJ_ACTIVESOCK_MAX_CONSECUTIVE_ACCEPT_ERROR: u32 = 50;
pub const PJ_IOQUEUE_MAX_HANDLES: u32 = 64;
pub const PJ_IOQUEUE_HAS_SAFE_UNREG: u32 = 1;
pub const PJ_IOQUEUE_DEFAULT_ALLOW_CONCURRENCY: u32 = 1;
pub const PJ_IOQUEUE_KEY_FREE_DELAY: u32 = 500;
pub const PJ_FD_SETSIZE_SETABLE: u32 = 0;
pub const PJ_IP_HELPER_IGNORE_LOOPBACK_IF: u32 = 1;
pub const PJ_HAS_SEMAPHORE: u32 = 1;
pub const PJ_HAS_EVENT_OBJ: u32 = 1;
pub const PJ_MAXPATH: u32 = 260;
pub const PJ_ENABLE_EXTRA_CHECK: u32 = 1;
pub const PJ_HAS_EXCEPTION_NAMES: u32 = 1;
pub const PJ_MAX_EXCEPTION_ID: u32 = 16;
pub const PJ_EXCEPTION_USE_WIN32_SEH: u32 = 0;
pub const PJ_TIMESTAMP_USE_RDTSC: u32 = 0;
pub const PJ_NATIVE_ERR_POSITIVE: u32 = 1;
pub const PJ_HAS_ERROR_STRING: u32 = 1;
pub const PJ_HAS_STRICMP_ALNUM: u32 = 0;
pub const PJ_QOS_DUMMY: u32 = 1;
pub const PJ_QOS_BSD: u32 = 2;
pub const PJ_QOS_WM: u32 = 3;
pub const PJ_QOS_SYMBIAN: u32 = 4;
pub const PJ_QOS_DARWIN: u32 = 5;
pub const PJ_HAS_SSL_SOCK: u32 = 0;
pub const PJ_SSL_SOCK_MAX_CIPHERS: u32 = 256;
pub const PJ_SSL_SOCK_OSSL_CIPHERS: &'static [u8; 26usize] = b"HIGH:-COMPLEMENTOFDEFAULT\0";
pub const PJ_SSL_SOCK_MAX_CURVES: u32 = 32;
pub const PJ_SOCK_DISABLE_WSAECONNRESET: u32 = 1;
pub const PJ_VERSION_NUM_MAJOR: u32 = 2;
pub const PJ_VERSION_NUM_MINOR: u32 = 7;
pub const PJ_VERSION_NUM_REV: u32 = 2;
pub const PJ_VERSION_NUM_EXTRA: &'static [u8; 1usize] = b"\0";
pub const PJ_VERSION_NUM: u32 = 34013696;
pub const PJ_MAX_OBJ_NAME: u32 = 32;
pub const PJSIP_MAX_TSX_COUNT: u32 = 1023;
pub const PJSIP_MAX_DIALOG_COUNT: u32 = 511;
pub const PJSIP_MAX_TRANSPORTS: u32 = 64;
pub const PJSIP_TPMGR_HTABLE_SIZE: u32 = 31;
pub const PJSIP_MAX_URL_SIZE: u32 = 256;
pub const PJSIP_MAX_MODULE: u32 = 32;
pub const PJSIP_MAX_PKT_LEN: u32 = 4000;
pub const PJSIP_DONT_SWITCH_TO_TCP: u32 = 0;
pub const PJSIP_DONT_SWITCH_TO_TLS: u32 = 0;
pub const PJSIP_HANDLE_EVENTS_HAS_SLEEP_ON_ERR: u32 = 1;
pub const PJSIP_ACCEPT_REPLACE_IN_EARLY_STATE: u32 = 0;
pub const PJSIP_UDP_SIZE_THRESHOLD: u32 = 1300;
pub const PJSIP_ENCODE_SHORT_HNAME: u32 = 0;
pub const PJSIP_INCLUDE_ALLOW_HDR_IN_DLG: u32 = 1;
pub const PJSIP_SAFE_MODULE: u32 = 1;
pub const PJSIP_CHECK_VIA_SENT_BY: u32 = 0;
pub const PJSIP_UNESCAPE_IN_PLACE: u32 = 0;
pub const PJSIP_ALLOW_PORT_IN_FROMTO_HDR: u32 = 0;
pub const PJSIP_MAX_NET_EVENTS: u32 = 1;
pub const PJSIP_MAX_TIMED_OUT_ENTRIES: u32 = 10;
pub const PJSIP_TRANSPORT_IDLE_TIME: u32 = 33;
pub const PJSIP_TRANSPORT_SERVER_IDLE_TIME: u32 = 600;
pub const PJSIP_TCP_TRANSPORT_BACKLOG: u32 = 5;
pub const PJSIP_TCP_TRANSPORT_REUSEADDR: u32 = 1;
pub const PJSIP_TCP_TRANSPORT_DONT_CREATE_LISTENER: u32 = 0;
pub const PJSIP_TLS_TRANSPORT_DONT_CREATE_LISTENER: u32 = 0;
pub const PJSIP_TCP_KEEP_ALIVE_INTERVAL: u32 = 90;
pub const PJSIP_TLS_KEEP_ALIVE_INTERVAL: u32 = 90;
pub const PJSIP_HAS_RESOLVER: u32 = 1;
pub const PJSIP_MAX_RESOLVED_ADDRESSES: u32 = 8;
pub const PJSIP_HAS_TLS_TRANSPORT: u32 = 0;
pub const PJSIP_TLS_TRANSPORT_BACKLOG: u32 = 5;
pub const PJSIP_TLS_TRANSPORT_REUSEADDR: u32 = 1;
pub const PJSIP_POOL_LEN_ENDPT: u32 = 4000;
pub const PJSIP_POOL_INC_ENDPT: u32 = 4000;
pub const PJSIP_POOL_RDATA_LEN: u32 = 4000;
pub const PJSIP_POOL_RDATA_INC: u32 = 4000;
pub const PJSIP_POOL_LEN_TRANSPORT: u32 = 512;
pub const PJSIP_POOL_INC_TRANSPORT: u32 = 512;
pub const PJSIP_POOL_LEN_TDATA: u32 = 4000;
pub const PJSIP_POOL_INC_TDATA: u32 = 4000;
pub const PJSIP_POOL_LEN_UA: u32 = 512;
pub const PJSIP_POOL_INC_UA: u32 = 512;
pub const PJSIP_MAX_FORWARDS_VALUE: u32 = 70;
pub const PJSIP_RFC3261_BRANCH_ID: &'static [u8; 8usize] = b"z9hG4bK\0";
pub const PJSIP_RFC3261_BRANCH_LEN: u32 = 7;
pub const PJSIP_POOL_TSX_LAYER_LEN: u32 = 512;
pub const PJSIP_POOL_TSX_LAYER_INC: u32 = 512;
pub const PJSIP_POOL_TSX_LEN: u32 = 1536;
pub const PJSIP_POOL_TSX_INC: u32 = 256;
pub const PJSIP_TSX_1XX_RETRANS_DELAY: u32 = 60;
pub const PJSIP_MAX_TSX_KEY_LEN: u32 = 512;
pub const PJSIP_POOL_LEN_USER_AGENT: u32 = 1024;
pub const PJSIP_POOL_INC_USER_AGENT: u32 = 1024;
pub const PJSIP_MAX_HNAME_LEN: u32 = 64;
pub const PJSIP_POOL_LEN_DIALOG: u32 = 1200;
pub const PJSIP_POOL_INC_DIALOG: u32 = 512;
pub const PJSIP_MAX_HEADER_TYPES: u32 = 72;
pub const PJSIP_MAX_URI_TYPES: u32 = 4;
pub const PJSIP_T1_TIMEOUT: u32 = 500;
pub const PJSIP_T2_TIMEOUT: u32 = 4000;
pub const PJSIP_T4_TIMEOUT: u32 = 5000;
pub const PJSIP_TD_TIMEOUT: u32 = 32000;
pub const PJSIP_AUTH_HEADER_CACHING: u32 = 0;
pub const PJSIP_AUTH_AUTO_SEND_NEXT: u32 = 0;
pub const PJSIP_AUTH_QOP_SUPPORT: u32 = 1;
pub const PJSIP_MAX_STALE_COUNT: u32 = 3;
pub const PJSIP_HAS_DIGEST_AKA_AUTH: u32 = 0;
pub const PJSIP_REGISTER_CLIENT_DELAY_BEFORE_REFRESH: u32 = 5;
pub const PJSIP_REGISTER_CLIENT_CHECK_CONTACT: u32 = 1;
pub const PJSIP_REGISTER_CLIENT_ADD_XUID_PARAM: u32 = 0;
pub const PJSIP_AUTH_CACHED_POOL_MAX_SIZE: u32 = 20480;
pub const PJSIP_EVSUB_TIME_UAC_REFRESH: u32 = 5;
pub const PJSIP_PUBLISHC_DELAY_BEFORE_REFRESH: u32 = 5;
pub const PJSIP_EVSUB_TIME_UAC_TERMINATE: u32 = 5;
pub const PJSIP_EVSUB_TIME_UAC_WAIT_NOTIFY: u32 = 5;
pub const PJSIP_PRES_DEFAULT_EXPIRES: u32 = 600;
pub const PJSIP_PRES_BAD_CONTENT_RESPONSE: u32 = 488;
pub const PJSIP_PRES_PIDF_ADD_TIMESTAMP: u32 = 1;
pub const PJSIP_SESS_TIMER_DEF_SE: u32 = 1800;
pub const PJSIP_SESS_TIMER_RETRY_DELAY: u32 = 10;
pub const PJSIP_PUBLISHC_QUEUE_REQUEST: u32 = 1;
pub const PJSIP_MWI_DEFAULT_EXPIRES: u32 = 3600;
pub const PJSIP_HAS_TX_DATA_LIST: u32 = 0;
pub const PJ_ERR_MSG_SIZE: u32 = 80;
pub const PJ_PERROR_TITLE_BUF_SIZE: u32 = 120;
pub const PJ_ERRNO_START: u32 = 20000;
pub const PJ_ERRNO_SPACE_SIZE: u32 = 50000;
pub const PJ_ERRNO_START_STATUS: u32 = 70000;
pub const PJ_ERRNO_START_SYS: u32 = 120000;
pub const PJ_ERRNO_START_USER: u32 = 170000;
pub const PJSIP_ERRNO_START: u32 = 170000;
pub const PJSIP_ERRNO_START_PJSIP: u32 = 171000;
pub const PJSIP_EBUSY: u32 = 171001;
pub const PJSIP_ETYPEEXISTS: u32 = 171002;
pub const PJSIP_ESHUTDOWN: u32 = 171003;
pub const PJSIP_ENOTINITIALIZED: u32 = 171004;
pub const PJSIP_ENOROUTESET: u32 = 171005;
pub const PJSIP_EINVALIDMSG: u32 = 171020;
pub const PJSIP_ENOTREQUESTMSG: u32 = 171021;
pub const PJSIP_ENOTRESPONSEMSG: u32 = 171022;
pub const PJSIP_EMSGTOOLONG: u32 = 171023;
pub const PJSIP_EPARTIALMSG: u32 = 171024;
pub const PJSIP_EINVALIDSTATUS: u32 = 171030;
pub const PJSIP_EINVALIDURI: u32 = 171039;
pub const PJSIP_EINVALIDSCHEME: u32 = 171040;
pub const PJSIP_EMISSINGREQURI: u32 = 171041;
pub const PJSIP_EINVALIDREQURI: u32 = 171042;
pub const PJSIP_EURITOOLONG: u32 = 171043;
pub const PJSIP_EMISSINGHDR: u32 = 171050;
pub const PJSIP_EINVALIDHDR: u32 = 171051;
pub const PJSIP_EINVALIDVIA: u32 = 171052;
pub const PJSIP_EMULTIPLEVIA: u32 = 171053;
pub const PJSIP_EMISSINGBODY: u32 = 171054;
pub const PJSIP_EINVALIDMETHOD: u32 = 171055;
pub const PJSIP_EUNSUPTRANSPORT: u32 = 171060;
pub const PJSIP_EPENDINGTX: u32 = 171061;
pub const PJSIP_ERXOVERFLOW: u32 = 171062;
pub const PJSIP_EBUFDESTROYED: u32 = 171063;
pub const PJSIP_ETPNOTSUITABLE: u32 = 171064;
pub const PJSIP_ETPNOTAVAIL: u32 = 171065;
pub const PJSIP_ETSXDESTROYED: u32 = 171070;
pub const PJSIP_ENOTSX: u32 = 171071;
pub const PJSIP_ECMPSCHEME: u32 = 171080;
pub const PJSIP_ECMPUSER: u32 = 171081;
pub const PJSIP_ECMPPASSWD: u32 = 171082;
pub const PJSIP_ECMPHOST: u32 = 171083;
pub const PJSIP_ECMPPORT: u32 = 171084;
pub const PJSIP_ECMPTRANSPORTPRM: u32 = 171085;
pub const PJSIP_ECMPTTLPARAM: u32 = 171086;
pub const PJSIP_ECMPUSERPARAM: u32 = 171087;
pub const PJSIP_ECMPMETHODPARAM: u32 = 171088;
pub const PJSIP_ECMPMADDRPARAM: u32 = 171089;
pub const PJSIP_ECMPOTHERPARAM: u32 = 171090;
pub const PJSIP_ECMPHEADERPARAM: u32 = 171091;
pub const PJSIP_EFAILEDCREDENTIAL: u32 = 171100;
pub const PJSIP_ENOCREDENTIAL: u32 = 171101;
pub const PJSIP_EINVALIDALGORITHM: u32 = 171102;
pub const PJSIP_EINVALIDQOP: u32 = 171103;
pub const PJSIP_EINVALIDAUTHSCHEME: u32 = 171104;
pub const PJSIP_EAUTHNOPREVCHAL: u32 = 171105;
pub const PJSIP_EAUTHNOAUTH: u32 = 171106;
pub const PJSIP_EAUTHACCNOTFOUND: u32 = 171107;
pub const PJSIP_EAUTHACCDISABLED: u32 = 171108;
pub const PJSIP_EAUTHINVALIDREALM: u32 = 171109;
pub const PJSIP_EAUTHINVALIDDIGEST: u32 = 171110;
pub const PJSIP_EAUTHSTALECOUNT: u32 = 171111;
pub const PJSIP_EAUTHINNONCE: u32 = 171112;
pub const PJSIP_EAUTHINAKACRED: u32 = 171113;
pub const PJSIP_EAUTHNOCHAL: u32 = 171114;
pub const PJSIP_EMISSINGTAG: u32 = 171120;
pub const PJSIP_ENOTREFER: u32 = 171121;
pub const PJSIP_ENOREFERSESSION: u32 = 171122;
pub const PJSIP_ESESSIONTERMINATED: u32 = 171140;
pub const PJSIP_ESESSIONSTATE: u32 = 171141;
pub const PJSIP_ESESSIONINSECURE: u32 = 171142;
pub const PJSIP_TLS_EUNKNOWN: u32 = 171160;
pub const PJSIP_TLS_EINVMETHOD: u32 = 171161;
pub const PJSIP_TLS_ECACERT: u32 = 171162;
pub const PJSIP_TLS_ECERTFILE: u32 = 171163;
pub const PJSIP_TLS_EKEYFILE: u32 = 171164;
pub const PJSIP_TLS_ECIPHER: u32 = 171165;
pub const PJSIP_TLS_ECTX: u32 = 171166;
pub const PJSIP_TLS_ESSLCONN: u32 = 171167;
pub const PJSIP_TLS_ECONNECT: u32 = 171168;
pub const PJSIP_TLS_EACCEPT: u32 = 171169;
pub const PJSIP_TLS_ESEND: u32 = 171170;
pub const PJSIP_TLS_EREAD: u32 = 171171;
pub const PJSIP_TLS_ETIMEDOUT: u32 = 171172;
pub const PJSIP_TLS_ECERTVERIF: u32 = 171173;
pub const PJ_DNS_MAX_IP_IN_A_REC: u32 = 8;
pub const PJ_DNS_SRV_MAX_ADDR: u32 = 8;
pub const PJ_DNS_MAX_NAMES_IN_NAMETABLE: u32 = 16;
pub const PJ_DNS_RESOLVER_MAX_NS: u32 = 16;
pub const PJ_DNS_RESOLVER_QUERY_RETRANSMIT_DELAY: u32 = 2000;
pub const PJ_DNS_RESOLVER_QUERY_RETRANSMIT_COUNT: u32 = 5;
pub const PJ_DNS_RESOLVER_MAX_TTL: u32 = 300;
pub const PJ_DNS_RESOLVER_INVALID_TTL: u32 = 60;
pub const PJ_DNS_RESOLVER_GOOD_NS_TTL: u32 = 600;
pub const PJ_DNS_RESOLVER_BAD_NS_TTL: u32 = 60;
pub const PJ_DNS_RESOLVER_MAX_UDP_SIZE: u32 = 512;
pub const PJ_DNS_RESOLVER_RES_BUF_SIZE: u32 = 512;
pub const PJ_DNS_RESOLVER_TMP_BUF_SIZE: u32 = 4000;
pub const PJ_SCANNER_USE_BITWISE: u32 = 1;
pub const PJSTUN_MAX_ATTR: u32 = 16;
pub const PJ_STUN_MAX_ATTR: u32 = 16;
pub const PJ_CRC32_HAS_TABLES: u32 = 1;
pub const PJ_HTTP_DEFAULT_TIMEOUT: u32 = 60000;
pub const PJ_CLI_POOL_SIZE: u32 = 1024;
pub const PJ_CLI_POOL_INC: u32 = 512;
pub const PJ_CLI_MAX_CMDBUF: u32 = 512;
pub const PJ_CLI_MAX_ARGS: u32 = 8;
pub const PJ_CLI_MAX_HINTS: u32 = 32;
pub const PJ_CLI_MAX_SHORTCUTS: u32 = 4;
pub const PJ_CLI_CONSOLE_POOL_SIZE: u32 = 256;
pub const PJ_CLI_CONSOLE_POOL_INC: u32 = 256;
pub const PJ_CLI_TELNET_POOL_SIZE: u32 = 1024;
pub const PJ_CLI_TELNET_POOL_INC: u32 = 512;
pub const PJ_CLI_MAX_CHOICE_VAL: u32 = 16;
pub const PJ_CLI_MAX_CMD_HISTORY: u32 = 16;
pub const PJSIP_GENERIC_ARRAY_MAX_COUNT: u32 = 32;
pub const PJSIP_MAX_ACCEPT_COUNT: u32 = 32;
pub const PJSIP_MIN_CONTENT_LENGTH: u32 = 0;
pub const PJSIP_MIN_PORT: u32 = 0;
pub const PJSIP_MIN_TTL: u32 = 0;
pub const PJSIP_MIN_STATUS_CODE: u32 = 100;
pub const PJSIP_MAX_STATUS_CODE: u32 = 999;
pub const PJSIP_MIN_Q1000: u32 = 0;
pub const PJSIP_MIN_EXPIRES: u32 = 0;
pub const PJSIP_MIN_CSEQ: u32 = 0;
pub const PJSIP_MIN_RETRY_AFTER: u32 = 0;
pub const PJ_SOMAXCONN: u32 = 5;
pub const PJ_INVALID_SOCKET: i32 = -1;
pub const PJ_INET_ADDRSTRLEN: u32 = 16;
pub const PJ_INET6_ADDRSTRLEN: u32 = 46;
pub const PJ_SOCKADDR_IN_SIN_ZERO_LEN: u32 = 8;
pub const PJ_MAX_SOCKOPT_PARAMS: u32 = 4;
pub const PJ_IOQUEUE_MAX_EVENTS_IN_SINGLE_POLL: u32 = 16;
pub const PJ_IOQUEUE_MAX_CAND_EVENTS: u32 = 16;
pub const PJ_POOL_ALIGNMENT: u32 = 4;
pub const PJ_CACHING_POOL_ARRAY_SIZE: u32 = 16;
pub const PJSIP_MD5STRLEN: u32 = 32;
pub const PJSIP_AUTH_SRV_IS_PROXY: u32 = 1;
pub const PJSIP_AKA_AKLEN: u32 = 6;
pub const PJSIP_AKA_AMFLEN: u32 = 2;
pub const PJSIP_AKA_AUTNLEN: u32 = 16;
pub const PJSIP_AKA_CKLEN: u32 = 16;
pub const PJSIP_AKA_IKLEN: u32 = 16;
pub const PJSIP_AKA_KLEN: u32 = 16;
pub const PJSIP_AKA_MACLEN: u32 = 8;
pub const PJSIP_AKA_OPLEN: u32 = 16;
pub const PJSIP_AKA_RANDLEN: u32 = 16;
pub const PJSIP_AKA_RESLEN: u32 = 8;
pub const PJSIP_AKA_SQNLEN: u32 = 6;
pub const PJMEDIA_HAS_LEGACY_SOUND_API: u32 = 1;
pub const PJMEDIA_SND_DEFAULT_REC_LATENCY: u32 = 100;
pub const PJMEDIA_SND_DEFAULT_PLAY_LATENCY: u32 = 140;
pub const PJMEDIA_WSOLA_IMP_NULL: u32 = 0;
pub const PJMEDIA_WSOLA_IMP_WSOLA: u32 = 1;
pub const PJMEDIA_WSOLA_IMP_WSOLA_LITE: u32 = 2;
pub const PJMEDIA_WSOLA_IMP: u32 = 1;
pub const PJMEDIA_WSOLA_MAX_EXPAND_MSEC: u32 = 80;
pub const PJMEDIA_WSOLA_TEMPLATE_LENGTH_MSEC: u32 = 5;
pub const PJMEDIA_WSOLA_DELAY_MSEC: u32 = 5;
pub const PJMEDIA_WSOLA_PLC_NO_FADING: u32 = 0;
pub const PJMEDIA_MAX_PLC_DURATION_MSEC: u32 = 240;
pub const PJMEDIA_SOUND_BUFFER_COUNT: u32 = 8;
pub const PJMEDIA_HAS_ALAW_ULAW_TABLE: u32 = 1;
pub const PJMEDIA_HAS_G711_CODEC: u32 = 1;
pub const PJMEDIA_RESAMPLE_NONE: u32 = 1;
pub const PJMEDIA_RESAMPLE_LIBRESAMPLE: u32 = 2;
pub const PJMEDIA_RESAMPLE_SPEEX: u32 = 3;
pub const PJMEDIA_RESAMPLE_LIBSAMPLERATE: u32 = 4;
pub const PJMEDIA_RESAMPLE_IMP: u32 = 2;
pub const PJMEDIA_FILE_PORT_BUFSIZE: u32 = 4000;
pub const PJMEDIA_MAX_FRAME_DURATION_MS: u32 = 200;
pub const PJMEDIA_MAX_MTU: u32 = 1500;
pub const PJMEDIA_MAX_MRU: u32 = 2000;
pub const PJMEDIA_DTMF_DURATION: u32 = 1600;
pub const PJMEDIA_RTP_NAT_PROBATION_CNT: u32 = 10;
pub const PJMEDIA_RTCP_NAT_PROBATION_CNT: u32 = 3;
pub const PJMEDIA_ADVERTISE_RTCP: u32 = 1;
pub const PJMEDIA_RTCP_INTERVAL: u32 = 5000;
pub const PJMEDIA_RTCP_IGNORE_FIRST_PACKETS: u32 = 25;
pub const PJMEDIA_RTCP_STAT_HAS_RAW_JITTER: u32 = 0;
pub const PJMEDIA_RTCP_NORMALIZE_FACTOR: u32 = 3;
pub const PJMEDIA_RTCP_STAT_HAS_IPDV: u32 = 0;
pub const PJMEDIA_HAS_RTCP_XR: u32 = 0;
pub const PJMEDIA_STREAM_ENABLE_XR: u32 = 0;
pub const PJMEDIA_RTCP_RX_SDES_BUF_LEN: u32 = 64;
pub const PJMEDIA_STREAM_CHECK_RTP_PT: u32 = 1;
pub const PJMEDIA_STREAM_RESV_PAYLOAD_LEN: u32 = 20;
pub const PJMEDIA_CODEC_MAX_SILENCE_PERIOD: u32 = 5000;
pub const PJMEDIA_SILENCE_DET_THRESHOLD: u32 = 4;
pub const PJMEDIA_SILENCE_DET_MAX_THRESHOLD: u32 = 65536;
pub const PJMEDIA_HAS_SPEEX_AEC: u32 = 1;
pub const PJMEDIA_SPEEX_AEC_USE_AGC: u32 = 1;
pub const PJMEDIA_SPEEX_AEC_USE_DENOISE: u32 = 1;
pub const PJMEDIA_HAS_WEBRTC_AEC: u32 = 0;
pub const PJMEDIA_WEBRTC_AEC_USE_MOBILE: u32 = 0;
pub const PJMEDIA_CODEC_MAX_FMTP_CNT: u32 = 16;
pub const PJMEDIA_SDP_NEG_PREFER_REMOTE_CODEC_ORDER: u32 = 1;
pub const PJMEDIA_SDP_NEG_ANSWER_MULTIPLE_CODECS: u32 = 0;
pub const PJMEDIA_SDP_NEG_MAX_CUSTOM_FMT_NEG_CB: u32 = 8;
pub const PJMEDIA_SDP_NEG_ANSWER_SYMMETRIC_PT: u32 = 1;
pub const PJMEDIA_SDP_NEG_COMPARE_BEFORE_INC_VERSION: u32 = 0;
pub const PJMEDIA_HAS_RTCP_IN_SDP: u32 = 1;
pub const PJMEDIA_ADD_BANDWIDTH_TIAS_IN_SDP: u32 = 1;
pub const PJMEDIA_ADD_RTPMAP_FOR_STATIC_PT: u32 = 1;
pub const PJMEDIA_RTP_PT_TELEPHONE_EVENTS: u32 = 96;
pub const PJMEDIA_RTP_PT_TELEPHONE_EVENTS_STR: &'static [u8; 3usize] = b"96\0";
pub const PJMEDIA_TONEGEN_MAX_DIGITS: u32 = 32;
pub const PJMEDIA_TONEGEN_SINE: u32 = 1;
pub const PJMEDIA_TONEGEN_FLOATING_POINT: u32 = 2;
pub const PJMEDIA_TONEGEN_FIXED_POINT_CORDIC: u32 = 3;
pub const PJMEDIA_TONEGEN_FAST_FIXED_POINT: u32 = 4;
pub const PJMEDIA_TONEGEN_ALG: u32 = 2;
pub const PJMEDIA_TONEGEN_FIXED_POINT_CORDIC_LOOP: u32 = 10;
pub const PJMEDIA_TONEGEN_FADE_IN_TIME: u32 = 1;
pub const PJMEDIA_TONEGEN_FADE_OUT_TIME: u32 = 2;
pub const PJMEDIA_TONEGEN_VOLUME: u32 = 12288;
pub const PJMEDIA_HAS_SRTP: u32 = 1;
pub const PJMEDIA_SRTP_HAS_SDES: u32 = 1;
pub const PJMEDIA_SRTP_HAS_DTLS: u32 = 0;
pub const PJMEDIA_SRTP_DTLS_OSSL_CIPHERS: &'static [u8; 8usize] = b"DEFAULT\0";
pub const PJMEDIA_SRTP_MAX_CRYPTOS: u32 = 16;
pub const PJMEDIA_SRTP_HAS_AES_CM_256: u32 = 1;
pub const PJMEDIA_SRTP_HAS_AES_CM_192: u32 = 0;
pub const PJMEDIA_SRTP_HAS_AES_CM_128: u32 = 1;
pub const PJMEDIA_SRTP_HAS_AES_GCM_256: u32 = 0;
pub const PJMEDIA_SRTP_HAS_AES_GCM_128: u32 = 0;
pub const PJMEDIA_LIBSRTP_AUTO_INIT_DEINIT: u32 = 1;
pub const PJMEDIA_HANDLE_G722_MPEG_BUG: u32 = 1;
pub const PJMEDIA_TRANSPORT_SPECIFIC_INFO_MAXCNT: u32 = 4;
pub const PJMEDIA_STREAM_KA_EMPTY_RTP: u32 = 1;
pub const PJMEDIA_STREAM_KA_USER: u32 = 2;
pub const PJMEDIA_STREAM_ENABLE_KA: u32 = 0;
pub const PJMEDIA_STREAM_KA_INTERVAL: u32 = 5;
pub const PJMEDIA_HAS_VIDEO: u32 = 0;
pub const PJMEDIA_HAS_FFMPEG: u32 = 0;
pub const PJMEDIA_HAS_LIBAVFORMAT: u32 = 0;
pub const PJMEDIA_HAS_LIBAVCODEC: u32 = 0;
pub const PJMEDIA_HAS_LIBAVUTIL: u32 = 0;
pub const PJMEDIA_HAS_LIBSWSCALE: u32 = 0;
pub const PJMEDIA_HAS_LIBAVDEVICE: u32 = 0;
pub const PJMEDIA_MAX_VIDEO_PLANES: u32 = 4;
pub const PJMEDIA_MAX_VIDEO_FORMATS: u32 = 32;
pub const PJMEDIA_CLOCK_SYNC_MAX_SYNC_MSEC: u32 = 20000;
pub const PJMEDIA_MAX_VIDEO_ENC_FRAME_SIZE: u32 = 131072;
pub const PJMEDIA_CLOCK_SYNC_MAX_RESYNC_DURATION: u32 = 2000;
pub const PJMEDIA_JBUF_DISC_MIN_GAP: u32 = 200;
pub const PJMEDIA_JBUF_PRO_DISC_MIN_BURST: u32 = 1;
pub const PJMEDIA_JBUF_PRO_DISC_MAX_BURST: u32 = 100;
pub const PJMEDIA_JBUF_PRO_DISC_T1: u32 = 2000;
pub const PJMEDIA_JBUF_PRO_DISC_T2: u32 = 10000;
pub const PJMEDIA_VID_STREAM_SKIP_PACKETS_TO_REDUCE_LATENCY: u32 = 0;
pub const PJMEDIA_MAX_VID_PAYLOAD_SIZE: u32 = 1336;
pub const PJMEDIA_TRANSPORT_SO_RCVBUF_SIZE: u32 = 0;
pub const PJMEDIA_TRANSPORT_SO_SNDBUF_SIZE: u32 = 0;
pub const PJMEDIA_HAS_LIBYUV: u32 = 0;
pub const PJMEDIA_HAS_DTMF_FLASH: u32 = 1;
pub const PJMEDIA_VID_STREAM_START_KEYFRAME_CNT: u32 = 5;
pub const PJMEDIA_VID_STREAM_START_KEYFRAME_INTERVAL_MSEC: u32 = 1000;
pub const PJMEDIA_FORMAT_DETAIL_USER_SIZE: u32 = 1;
pub const PJ_THREAD_DESC_SIZE: u32 = 64;
pub const PJMEDIA_CODEC_MGR_MAX_CODECS: u32 = 32;
pub const PJMEDIA_MAX_SDP_FMT: u32 = 32;
pub const PJMEDIA_MAX_SDP_BANDW: u32 = 4;
pub const PJMEDIA_MAX_SDP_ATTR: u32 = 68;
pub const PJMEDIA_MAX_SDP_MEDIA: u32 = 16;
pub const PJMEDIA_ERRNO_START: u32 = 220000;
pub const PJMEDIA_ERRNO_END: u32 = 269999;
pub const PJMEDIA_PORTAUDIO_ERRNO_START: u32 = 259999;
pub const PJMEDIA_PORTAUDIO_ERRNO_END: u32 = 269998;
pub const PJMEDIA_LIBSRTP_ERRNO_START: u32 = 259799;
pub const PJMEDIA_LIBSRTP_ERRNO_END: u32 = 259998;
pub const PJMEDIA_ERROR: u32 = 220001;
pub const PJMEDIA_SDP_EINSDP: u32 = 220020;
pub const PJMEDIA_SDP_EINVER: u32 = 220021;
pub const PJMEDIA_SDP_EINORIGIN: u32 = 220022;
pub const PJMEDIA_SDP_EINTIME: u32 = 220023;
pub const PJMEDIA_SDP_EINNAME: u32 = 220024;
pub const PJMEDIA_SDP_EINCONN: u32 = 220025;
pub const PJMEDIA_SDP_EMISSINGCONN: u32 = 220026;
pub const PJMEDIA_SDP_EINATTR: u32 = 220027;
pub const PJMEDIA_SDP_EINRTPMAP: u32 = 220028;
pub const PJMEDIA_SDP_ERTPMAPTOOLONG: u32 = 220029;
pub const PJMEDIA_SDP_EMISSINGRTPMAP: u32 = 220030;
pub const PJMEDIA_SDP_EINMEDIA: u32 = 220031;
pub const PJMEDIA_SDP_ENOFMT: u32 = 220032;
pub const PJMEDIA_SDP_EINPT: u32 = 220033;
pub const PJMEDIA_SDP_EINFMTP: u32 = 220034;
pub const PJMEDIA_SDP_EINRTCP: u32 = 220035;
pub const PJMEDIA_SDP_EINPROTO: u32 = 220036;
pub const PJMEDIA_SDP_EINBANDW: u32 = 220037;
pub const PJMEDIA_SDPNEG_EINSTATE: u32 = 220040;
pub const PJMEDIA_SDPNEG_ENOINITIAL: u32 = 220041;
pub const PJMEDIA_SDPNEG_ENOACTIVE: u32 = 220042;
pub const PJMEDIA_SDPNEG_ENONEG: u32 = 220043;
pub const PJMEDIA_SDPNEG_EMISMEDIA: u32 = 220044;
pub const PJMEDIA_SDPNEG_EINVANSMEDIA: u32 = 220045;
pub const PJMEDIA_SDPNEG_EINVANSTP: u32 = 220046;
pub const PJMEDIA_SDPNEG_EANSNOMEDIA: u32 = 220047;
pub const PJMEDIA_SDPNEG_ENOMEDIA: u32 = 220048;
pub const PJMEDIA_SDPNEG_NOANSCODEC: u32 = 220049;
pub const PJMEDIA_SDPNEG_NOANSTELEVENT: u32 = 220050;
pub const PJMEDIA_SDPNEG_NOANSUNKNOWN: u32 = 220051;
pub const PJMEDIA_SDP_EMEDIANOTEQUAL: u32 = 220060;
pub const PJMEDIA_SDP_EPORTNOTEQUAL: u32 = 220061;
pub const PJMEDIA_SDP_ETPORTNOTEQUAL: u32 = 220062;
pub const PJMEDIA_SDP_EFORMATNOTEQUAL: u32 = 220063;
pub const PJMEDIA_SDP_ECONNNOTEQUAL: u32 = 220064;
pub const PJMEDIA_SDP_EATTRNOTEQUAL: u32 = 220065;
pub const PJMEDIA_SDP_EDIRNOTEQUAL: u32 = 220066;
pub const PJMEDIA_SDP_EFMTPNOTEQUAL: u32 = 220067;
pub const PJMEDIA_SDP_ERTPMAPNOTEQUAL: u32 = 220068;
pub const PJMEDIA_SDP_ESESSNOTEQUAL: u32 = 220069;
pub const PJMEDIA_SDP_EORIGINNOTEQUAL: u32 = 220070;
pub const PJMEDIA_SDP_ENAMENOTEQUAL: u32 = 220071;
pub const PJMEDIA_SDP_ETIMENOTEQUAL: u32 = 220072;
pub const PJMEDIA_CODEC_EUNSUP: u32 = 220080;
pub const PJMEDIA_CODEC_EFAILED: u32 = 220081;
pub const PJMEDIA_CODEC_EFRMTOOSHORT: u32 = 220082;
pub const PJMEDIA_CODEC_EPCMTOOSHORT: u32 = 220083;
pub const PJMEDIA_CODEC_EFRMINLEN: u32 = 220084;
pub const PJMEDIA_CODEC_EPCMFRMINLEN: u32 = 220085;
pub const PJMEDIA_CODEC_EINMODE: u32 = 220086;
pub const PJMEDIA_CODEC_EBADBITSTREAM: u32 = 220087;
pub const PJMEDIA_EINVALIDIP: u32 = 220100;
pub const PJMEDIA_EASYMCODEC: u32 = 220101;
pub const PJMEDIA_EINVALIDPT: u32 = 220102;
pub const PJMEDIA_EMISSINGRTPMAP: u32 = 220103;
pub const PJMEDIA_EINVALIMEDIATYPE: u32 = 220104;
pub const PJMEDIA_EREMOTENODTMF: u32 = 220105;
pub const PJMEDIA_RTP_EINDTMF: u32 = 220106;
pub const PJMEDIA_RTP_EREMNORFC2833: u32 = 220107;
pub const PJMEDIA_EBADFMT: u32 = 220108;
pub const PJMEDIA_EUNSUPMEDIATYPE: u32 = 220109;
pub const PJMEDIA_RTP_EINPKT: u32 = 220120;
pub const PJMEDIA_RTP_EINPACK: u32 = 220121;
pub const PJMEDIA_RTP_EINVER: u32 = 220122;
pub const PJMEDIA_RTP_EINSSRC: u32 = 220123;
pub const PJMEDIA_RTP_EINPT: u32 = 220124;
pub const PJMEDIA_RTP_EINLEN: u32 = 220125;
pub const PJMEDIA_RTP_ESESSRESTART: u32 = 220130;
pub const PJMEDIA_RTP_ESESSPROBATION: u32 = 220131;
pub const PJMEDIA_RTP_EBADSEQ: u32 = 220132;
pub const PJMEDIA_RTP_EBADDEST: u32 = 220133;
pub const PJMEDIA_RTP_ENOCONFIG: u32 = 220134;
pub const PJMEDIA_ENOTCOMPATIBLE: u32 = 220160;
pub const PJMEDIA_ENCCLOCKRATE: u32 = 220161;
pub const PJMEDIA_ENCSAMPLESPFRAME: u32 = 220162;
pub const PJMEDIA_ENCTYPE: u32 = 220163;
pub const PJMEDIA_ENCBITS: u32 = 220164;
pub const PJMEDIA_ENCBYTES: u32 = 220165;
pub const PJMEDIA_ENCCHANNEL: u32 = 220166;
pub const PJMEDIA_ENOTVALIDWAVE: u32 = 220180;
pub const PJMEDIA_EWAVEUNSUPP: u32 = 220181;
pub const PJMEDIA_EWAVETOOSHORT: u32 = 220182;
pub const PJMEDIA_EFRMFILETOOBIG: u32 = 220183;
pub const PJMEDIA_EAVIUNSUPP: u32 = 220191;
pub const PJMEDIA_ENOSNDREC: u32 = 220200;
pub const PJMEDIA_ENOSNDPLAY: u32 = 220201;
pub const PJMEDIA_ESNDINDEVID: u32 = 220202;
pub const PJMEDIA_ESNDINSAMPLEFMT: u32 = 220203;
pub const PJMEDIA_SRTP_ECRYPTONOTMATCH: u32 = 220220;
pub const PJMEDIA_SRTP_EINKEYLEN: u32 = 220221;
pub const PJMEDIA_SRTP_ENOTSUPCRYPTO: u32 = 220222;
pub const PJMEDIA_SRTP_ESDPAMBIGUEANS: u32 = 220223;
pub const PJMEDIA_SRTP_ESDPDUPCRYPTOTAG: u32 = 220224;
pub const PJMEDIA_SRTP_ESDPINCRYPTO: u32 = 220225;
pub const PJMEDIA_SRTP_ESDPINCRYPTOTAG: u32 = 220226;
pub const PJMEDIA_SRTP_ESDPINTRANSPORT: u32 = 220227;
pub const PJMEDIA_SRTP_ESDPREQCRYPTO: u32 = 220228;
pub const PJMEDIA_SRTP_ESDPREQSECTP: u32 = 220229;
pub const PJMEDIA_SRTP_DTLS_ENOCRYPTO: u32 = 220240;
pub const PJMEDIA_SRTP_DTLS_EPEERNOCERT: u32 = 220241;
pub const PJMEDIA_SRTP_DTLS_EFPNOTMATCH: u32 = 220242;
pub const PJMEDIA_AUD_DEV_INFO_NAME_LEN: u32 = 64;
pub const PJMEDIA_AUDIO_DEV_HAS_OPENSL: u32 = 0;
pub const PJMEDIA_AUDIO_DEV_HAS_BB10: u32 = 0;
pub const PJMEDIA_AUDIO_DEV_HAS_NULL_AUDIO: u32 = 0;
pub const PJMEDIA_AUDIO_DEV_HAS_COREAUDIO: u32 = 0;
pub const PJMEDIA_AUDIO_DEV_HAS_WMME: u32 = 1;
pub const PJMEDIA_AUDIO_DEV_HAS_WASAPI: u32 = 0;
pub const PJMEDIA_AUDIO_DEV_HAS_BDIMAD: u32 = 0;
pub const PJMEDIA_AUDIO_DEV_HAS_SYMB_APS: u32 = 0;
pub const PJMEDIA_AUDIO_DEV_SYMB_APS_DETECTS_CODEC: u32 = 1;
pub const PJMEDIA_AUDIO_DEV_HAS_SYMB_VAS: u32 = 0;
pub const PJMEDIA_AUDIO_DEV_SYMB_VAS_VERSION: u32 = 1;
pub const PJMEDIA_AUDIO_DEV_MDA_USE_SYNC_START: u32 = 1;
pub const PJMEDIA_AUDIO_DEV_HAS_LEGACY_DEVICE: u32 = 0;
pub const PJMEDIA_AUDIODEV_ERRNO_START: u32 = 420000;
pub const PJMEDIA_AUDIODEV_ERRNO_END: u32 = 469999;
pub const PJMEDIA_AUDIODEV_PORTAUDIO_ERRNO_START: u32 = 459999;
pub const PJMEDIA_AUDIODEV_PORTAUDIO_ERRNO_END: u32 = 469998;
pub const PJMEDIA_AUDIODEV_WMME_IN_ERROR_START: u32 = 450000;
pub const PJMEDIA_AUDIODEV_WMME_IN_ERROR_END: u32 = 450999;
pub const PJMEDIA_AUDIODEV_WMME_OUT_ERROR_START: u32 = 451999;
pub const PJMEDIA_AUDIODEV_WMME_OUT_ERROR_END: u32 = 452999;
pub const PJMEDIA_AUDIODEV_COREAUDIO_ERRNO_START: u32 = 440000;
pub const PJMEDIA_AUDIODEV_COREAUDIO_ERRNO_END: u32 = 459999;
pub const PJMEDIA_AUDIODEV_BDIMAD_ERROR_START: u32 = 460000;
pub const PJMEDIA_AUDIODEV_BDIMAD_ERROR_END: u32 = 461999;
pub const PJMEDIA_EAUD_ERR: u32 = 420001;
pub const PJMEDIA_EAUD_SYSERR: u32 = 420002;
pub const PJMEDIA_EAUD_INIT: u32 = 420003;
pub const PJMEDIA_EAUD_INVDEV: u32 = 420004;
pub const PJMEDIA_EAUD_NODEV: u32 = 420005;
pub const PJMEDIA_EAUD_NODEFDEV: u32 = 420006;
pub const PJMEDIA_EAUD_NOTREADY: u32 = 420007;
pub const PJMEDIA_EAUD_INVCAP: u32 = 420008;
pub const PJMEDIA_EAUD_INVOP: u32 = 420009;
pub const PJMEDIA_EAUD_BADFORMAT: u32 = 420010;
pub const PJMEDIA_EAUD_SAMPFORMAT: u32 = 420011;
pub const PJMEDIA_EAUD_BADLATENCY: u32 = 420012;
pub const PJMEDIA_EAUD_WASAPI_ERROR: u32 = 420013;
pub const PJMEDIA_AUD_MAX_DRIVERS: u32 = 16;
pub const PJMEDIA_AUD_MAX_DEVS: u32 = 64;
pub const PJMEDIA_CODEC_L16_HAS_8KHZ_MONO: u32 = 0;
pub const PJMEDIA_CODEC_L16_HAS_8KHZ_STEREO: u32 = 0;
pub const PJMEDIA_CODEC_L16_HAS_16KHZ_MONO: u32 = 0;
pub const PJMEDIA_CODEC_L16_HAS_16KHZ_STEREO: u32 = 0;
pub const PJMEDIA_HAS_BCG729: u32 = 0;
pub const PJMEDIA_HAS_FFMPEG_CODEC: u32 = 0;
pub const PJMEDIA_HAS_FFMPEG_VID_CODEC: u32 = 0;
pub const PJMEDIA_HAS_FFMPEG_CODEC_H263P: u32 = 0;
pub const PJMEDIA_HAS_FFMPEG_CODEC_H264: u32 = 0;
pub const PJMEDIA_JB_DEFAULT_INIT_DELAY: u32 = 15;
pub const PJ_PI: f64 = 3.141592653589793;
pub const PJ_1_PI: f64 = 0.3183098861837907;
pub const PJMEDIA_VID_CODEC_MAX_DEC_FMT_CNT: u32 = 8;
pub const PJMEDIA_VID_CODEC_MAX_FPS_CNT: u32 = 16;
pub const PJMEDIA_VID_CODEC_MGR_MAX_CODECS: u32 = 32;
pub const PJNATH_ERROR_LEVEL: u32 = 1;
pub const PJ_STUN_RTO_VALUE: u32 = 100;
pub const PJ_STUN_TIMEOUT_VALUE: u32 = 1600;
pub const PJ_STUN_MAX_TRANSMIT_COUNT: u32 = 7;
pub const PJ_STUN_RES_CACHE_DURATION: u32 = 10000;
pub const PJ_STUN_MAX_PKT_LEN: u32 = 800;
pub const PJ_STUN_PORT: u32 = 3478;
pub const PJ_STUN_STRING_ATTR_PAD_CHR: u32 = 0;
pub const PJ_STUN_OLD_STYLE_MI_FINGERPRINT: u32 = 0;
pub const PJ_STUN_SOCK_PKT_LEN: u32 = 2000;
pub const PJ_STUN_KEEP_ALIVE_SEC: u32 = 15;
pub const PJ_TURN_MAX_DNS_SRV_CNT: u32 = 4;
pub const PJ_TURN_MAX_PKT_LEN: u32 = 3000;
pub const PJ_TURN_PERM_TIMEOUT: u32 = 300;
pub const PJ_TURN_CHANNEL_TIMEOUT: u32 = 600;
pub const PJ_TURN_REFRESH_SEC_BEFORE: u32 = 60;
pub const PJ_TURN_KEEP_ALIVE_SEC: u32 = 15;
pub const PJ_ICE_MAX_CAND: u32 = 16;
pub const PJ_ICE_ST_MAX_CAND: u32 = 8;
pub const PJ_ICE_MAX_STUN: u32 = 2;
pub const PJ_ICE_MAX_TURN: u32 = 3;
pub const PJ_ICE_COMP_BITS: u32 = 1;
pub const PJ_ICE_MAX_COMP: u32 = 4;
pub const PJNATH_ICE_PRIO_STD: u32 = 1;
pub const PJ_ICE_CAND_TYPE_PREF_BITS: u32 = 8;
pub const PJ_ICE_LOCAL_PREF_BITS: u32 = 0;
pub const PJ_ICE_MAX_CHECKS: u32 = 32;
pub const PJ_ICE_TA_VAL: u32 = 20;
pub const PJ_ICE_CANCEL_ALL: u32 = 1;
pub const PJ_ICE_NOMINATED_CHECK_DELAY: u32 = 400;
pub const PJ_ICE_SESS_KEEP_ALIVE_MIN: u32 = 20;
pub const PJ_ICE_SESS_KEEP_ALIVE_MAX_RAND: u32 = 5;
pub const PJ_ICE_UFRAG_LEN: u32 = 8;
pub const PJNATH_POOL_LEN_ICE_SESS: u32 = 512;
pub const PJNATH_POOL_INC_ICE_SESS: u32 = 512;
pub const PJNATH_POOL_LEN_ICE_STRANS: u32 = 1000;
pub const PJNATH_POOL_INC_ICE_STRANS: u32 = 512;
pub const PJNATH_POOL_LEN_NATCK: u32 = 512;
pub const PJNATH_POOL_INC_NATCK: u32 = 512;
pub const PJNATH_POOL_LEN_STUN_SESS: u32 = 1000;
pub const PJNATH_POOL_INC_STUN_SESS: u32 = 1000;
pub const PJNATH_POOL_LEN_STUN_TDATA: u32 = 1000;
pub const PJNATH_POOL_INC_STUN_TDATA: u32 = 1000;
pub const PJNATH_POOL_LEN_TURN_SESS: u32 = 1000;
pub const PJNATH_POOL_INC_TURN_SESS: u32 = 1000;
pub const PJNATH_POOL_LEN_TURN_SOCK: u32 = 1000;
pub const PJNATH_POOL_INC_TURN_SOCK: u32 = 1000;
pub const PJ_TURN_INVALID_CHANNEL: u32 = 65535;
pub const PJ_STUN_MAGIC: u32 = 554869826;
pub const PJ_STUN_SUCCESS_RESPONSE_BIT: u32 = 256;
pub const PJ_STUN_ERROR_RESPONSE_BIT: u32 = 272;
pub const PJ_STUN_INDICATION_BIT: u32 = 16;
pub const PJNATH_ERRNO_START: u32 = 370000;
pub const PJNATH_EINSTUNMSG: u32 = 370001;
pub const PJNATH_EINSTUNMSGLEN: u32 = 370002;
pub const PJNATH_EINSTUNMSGTYPE: u32 = 370003;
pub const PJNATH_ESTUNTIMEDOUT: u32 = 370004;
pub const PJNATH_ESTUNTOOMANYATTR: u32 = 370021;
pub const PJNATH_ESTUNINATTRLEN: u32 = 370022;
pub const PJNATH_ESTUNDUPATTR: u32 = 370023;
pub const PJNATH_ESTUNFINGERPRINT: u32 = 370030;
pub const PJNATH_ESTUNMSGINTPOS: u32 = 370031;
pub const PJNATH_ESTUNFINGERPOS: u32 = 370033;
pub const PJNATH_ESTUNNOMAPPEDADDR: u32 = 370040;
pub const PJNATH_ESTUNIPV6NOTSUPP: u32 = 370041;
pub const PJNATH_EINVAF: u32 = 370042;
pub const PJNATH_ESTUNINSERVER: u32 = 370050;
pub const PJNATH_ESTUNDESTROYED: u32 = 370060;
pub const PJNATH_ENOICE: u32 = 370080;
pub const PJNATH_EICEINPROGRESS: u32 = 370081;
pub const PJNATH_EICEFAILED: u32 = 370082;
pub const PJNATH_EICEMISMATCH: u32 = 370083;
pub const PJNATH_EICEINCOMPID: u32 = 370086;
pub const PJNATH_EICEINCANDID: u32 = 370087;
pub const PJNATH_EICEINSRCADDR: u32 = 370088;
pub const PJNATH_EICEMISSINGSDP: u32 = 370090;
pub const PJNATH_EICEINCANDSDP: u32 = 370091;
pub const PJNATH_EICENOHOSTCAND: u32 = 370092;
pub const PJNATH_EICENOMTIMEOUT: u32 = 370093;
pub const PJNATH_ETURNINTP: u32 = 370120;
pub const PJMEDIA_VID_DEV_INFO_FMT_CNT: u32 = 64;
pub const PJMEDIA_VID_DEV_MAX_DRIVERS: u32 = 8;
pub const PJMEDIA_VID_DEV_MAX_DEVS: u32 = 16;
pub const PJMEDIA_VIDEODEV_ERRNO_START: u32 = 520000;
pub const PJMEDIA_VIDEODEV_ERRNO_END: u32 = 569999;
pub const PJMEDIA_EVID_ERR: u32 = 520001;
pub const PJMEDIA_EVID_SYSERR: u32 = 520002;
pub const PJMEDIA_EVID_INIT: u32 = 520003;
pub const PJMEDIA_EVID_INVDEV: u32 = 520004;
pub const PJMEDIA_EVID_NODEV: u32 = 520005;
pub const PJMEDIA_EVID_NODEFDEV: u32 = 520006;
pub const PJMEDIA_EVID_NOTREADY: u32 = 520007;
pub const PJMEDIA_EVID_INVCAP: u32 = 520008;
pub const PJMEDIA_EVID_INVOP: u32 = 520009;
pub const PJMEDIA_EVID_BADFORMAT: u32 = 520010;
pub const PJMEDIA_EVID_SAMPFORMAT: u32 = 520011;
pub const PJMEDIA_EVID_BADLATENCY: u32 = 520012;
pub const PJMEDIA_EVID_BADSIZE: u32 = 520013;
pub const PJSIP_REGC_MAX_CONTACT: u32 = 10;
pub const PJSIP_REGC_CONTACT_BUF_SIZE: u32 = 512;
pub const PJSIP_EVSUB_POOL_LEN: u32 = 4000;
pub const PJSIP_EVSUB_POOL_INC: u32 = 4000;
pub const PJSIP_MAX_ALLOW_EVENTS: u32 = 16;
pub const PJSIP_PRES_STATUS_MAX_INFO: u32 = 8;
pub const PJLIB_UTIL_ERRNO_START: u32 = 320000;
pub const PJLIB_UTIL_ESTUNRESOLVE: u32 = 320001;
pub const PJLIB_UTIL_ESTUNINMSGTYPE: u32 = 320002;
pub const PJLIB_UTIL_ESTUNINMSGLEN: u32 = 320003;
pub const PJLIB_UTIL_ESTUNINATTRLEN: u32 = 320004;
pub const PJLIB_UTIL_ESTUNINATTRTYPE: u32 = 320005;
pub const PJLIB_UTIL_ESTUNININDEX: u32 = 320006;
pub const PJLIB_UTIL_ESTUNNOBINDRES: u32 = 320007;
pub const PJLIB_UTIL_ESTUNRECVERRATTR: u32 = 320008;
pub const PJLIB_UTIL_ESTUNNOMAP: u32 = 320009;
pub const PJLIB_UTIL_ESTUNNOTRESPOND: u32 = 320010;
pub const PJLIB_UTIL_ESTUNSYMMETRIC: u32 = 320011;
pub const PJLIB_UTIL_ESTUNNOTMAGIC: u32 = 320012;
pub const PJLIB_UTIL_ESTUNFINGERPRINT: u32 = 320013;
pub const PJLIB_UTIL_EINXML: u32 = 320020;
pub const PJLIB_UTIL_EINJSON: u32 = 320030;
pub const PJLIB_UTIL_EDNSQRYTOOSMALL: u32 = 320040;
pub const PJLIB_UTIL_EDNSINSIZE: u32 = 320041;
pub const PJLIB_UTIL_EDNSINCLASS: u32 = 320042;
pub const PJLIB_UTIL_EDNSINNAMEPTR: u32 = 320043;
pub const PJLIB_UTIL_EDNSINNSADDR: u32 = 320044;
pub const PJLIB_UTIL_EDNSNONS: u32 = 320045;
pub const PJLIB_UTIL_EDNSNOWORKINGNS: u32 = 320046;
pub const PJLIB_UTIL_EDNSNOANSWERREC: u32 = 320047;
pub const PJLIB_UTIL_EDNSINANSWER: u32 = 320048;
pub const PJLIB_UTIL_DNS_RCODE_START: u32 = 320050;
pub const PJLIB_UTIL_ESTUNTOOMANYATTR: u32 = 320110;
pub const PJLIB_UTIL_ESTUNUNKNOWNATTR: u32 = 320111;
pub const PJLIB_UTIL_ESTUNINADDRLEN: u32 = 320112;
pub const PJLIB_UTIL_ESTUNIPV6NOTSUPP: u32 = 320113;
pub const PJLIB_UTIL_ESTUNNOTRESPONSE: u32 = 320114;
pub const PJLIB_UTIL_ESTUNINVALIDID: u32 = 320115;
pub const PJLIB_UTIL_ESTUNNOHANDLER: u32 = 320116;
pub const PJLIB_UTIL_ESTUNMSGINTPOS: u32 = 320118;
pub const PJLIB_UTIL_ESTUNFINGERPOS: u32 = 320119;
pub const PJLIB_UTIL_ESTUNNOUSERNAME: u32 = 320120;
pub const PJLIB_UTIL_ESTUNUSERNAME: u32 = 320121;
pub const PJLIB_UTIL_ESTUNMSGINT: u32 = 320122;
pub const PJLIB_UTIL_ESTUNDUPATTR: u32 = 320123;
pub const PJLIB_UTIL_ESTUNNOREALM: u32 = 320124;
pub const PJLIB_UTIL_ESTUNNONCE: u32 = 320125;
pub const PJLIB_UTIL_ESTUNTSXFAILED: u32 = 320126;
pub const PJLIB_UTIL_EHTTPINURL: u32 = 320151;
pub const PJLIB_UTIL_EHTTPINPORT: u32 = 320152;
pub const PJLIB_UTIL_EHTTPINCHDR: u32 = 320153;
pub const PJLIB_UTIL_EHTTPINSBUF: u32 = 320154;
pub const PJLIB_UTIL_EHTTPLOST: u32 = 320155;
pub const PJ_CLI_EEXIT: u32 = 320201;
pub const PJ_CLI_EMISSINGARG: u32 = 320202;
pub const PJ_CLI_ETOOMANYARGS: u32 = 320203;
pub const PJ_CLI_EINVARG: u32 = 320204;
pub const PJ_CLI_EBADNAME: u32 = 320205;
pub const PJ_CLI_EBADID: u32 = 320206;
pub const PJ_CLI_EBADXML: u32 = 320207;
pub const PJ_CLI_EAMBIGUOUS: u32 = 320208;
pub const PJ_CLI_ETELNETLOST: u32 = 320211;
pub const PJ_SHA1_DIGEST_SIZE: u32 = 20;
pub const PJ_HTTP_HEADER_SIZE: u32 = 32;
pub const PJ_CLI_CONSOLE_LOG_LEVEL: u32 = 5;
pub const PJ_CLI_TELNET_LOG_LEVEL: u32 = 4;
pub const PJ_CLI_TELNET_PORT: u32 = 0;
pub const pj_hex_digits: &'static [u8; 17usize] = b"0123456789abcdef\0";
pub const PJ_GUID_MAX_LENGTH: u32 = 36;
pub const PJSUA_ACC_MAX_PROXIES: u32 = 8;
pub const PJSUA_DEFAULT_SRTP_SECURE_SIGNALING: u32 = 1;
pub const PJSUA_ADD_ICE_TAGS: u32 = 1;
pub const PJSUA_ACQUIRE_CALL_TIMEOUT: u32 = 2000;
pub const PJSUA_HAS_VIDEO: u32 = 0;
pub const PJSUA_VID_REQ_KEYFRAME_INTERVAL: u32 = 3000;
pub const PJSUA_REG_INTERVAL: u32 = 300;
pub const PJSUA_UNREG_TIMEOUT: u32 = 4000;
pub const PJSUA_DEFAULT_ACC_PRIORITY: u32 = 0;
pub const PJSUA_UNPUBLISH_MAX_WAIT_TIME_MSEC: u32 = 2000;
pub const PJSUA_REG_RETRY_INTERVAL: u32 = 300;
pub const PJSUA_REG_USE_OUTBOUND_PROXY: u32 = 1;
pub const PJSUA_REG_USE_ACC_PROXY: u32 = 2;
pub const PJSUA_MAX_CALLS: u32 = 32;
pub const PJSUA_MAX_VID_WINS: u32 = 16;
pub const PJSUA_XFER_NO_REQUIRE_REPLACES: u32 = 1;
pub const PJSUA_MAX_BUDDIES: u32 = 256;
pub const PJSUA_PRES_TIMER: u32 = 300;
pub const PJSUA_MEDIA_HAS_PJMEDIA: u32 = 1;
pub const PJSUA_THIRD_PARTY_STREAM_HAS_GET_INFO: u32 = 0;
pub const PJSUA_THIRD_PARTY_STREAM_HAS_GET_STAT: u32 = 0;
pub const PJSUA_MAX_CONF_PORTS: u32 = 254;
pub const PJSUA_DEFAULT_CLOCK_RATE: u32 = 16000;
pub const PJSUA_DEFAULT_AUDIO_FRAME_PTIME: u32 = 20;
pub const PJSUA_DEFAULT_CODEC_QUALITY: u32 = 8;
pub const PJSUA_DEFAULT_ILBC_MODE: u32 = 30;
pub const PJSUA_DEFAULT_EC_TAIL_LEN: u32 = 200;
pub const PJSUA_MAX_PLAYERS: u32 = 32;
pub const PJSUA_MAX_RECORDERS: u32 = 32;
pub const PJSUA_SDP_SESS_HAS_CONN: u32 = 0;
pub const PJSUA_TRANSPORT_RESTART_DELAY_TIME: u32 = 10;
pub const PJSUA_MAX_CALL_MEDIA: u32 = 16;
pub const PJSUA_BUDDY_SUB_TERM_REASON_LEN: u32 = 32;

pub type pj_int64_t = ::std::os::raw::c_longlong;
pub type pj_uint64_t = ::std::os::raw::c_ulonglong;
pub type wchar_t = ::std::os::raw::c_uint;

extern "C" {
    #[link_name = "\u{1}PJ_VERSION"]
    pub static mut PJ_VERSION: *const ::std::os::raw::c_char;
}

extern "C" { pub fn pj_get_version() -> *const ::std::os::raw::c_char; }

extern "C" { pub fn pj_dump_config(); }

pub type pj_int32_t = ::std::os::raw::c_int;
pub type pj_uint32_t = ::std::os::raw::c_uint;
pub type pj_int16_t = ::std::os::raw::c_short;
pub type pj_uint16_t = ::std::os::raw::c_ushort;
pub type pj_int8_t = ::std::os::raw::c_schar;
pub type pj_uint8_t = ::std::os::raw::c_uchar;
pub type pj_size_t = usize;
pub type pj_ssize_t = ::std::os::raw::c_long;
pub type pj_status_t = ::std::os::raw::c_int;
pub type pj_bool_t = ::std::os::raw::c_int;
pub type pj_char_t = ::std::os::raw::c_char;

impl pj_constants_ { pub const PJ_FALSE: pj_constants_ = pj_constants_::PJ_SUCCESS; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_constants_ { PJ_SUCCESS = 0, PJ_TRUE = 1 }

pub type pj_off_t = pj_int64_t;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_str_t { pub ptr: *mut ::std::os::raw::c_char, pub slen: pj_ssize_t }

#[repr(C)]
#[derive(Copy, Clone)]
pub union pj_timestamp { pub u32: pj_timestamp__bindgen_ty_1, pub u64: pj_uint64_t, _bindgen_union_align: u64 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_timestamp__bindgen_ty_1 { pub lo: pj_uint32_t, pub hi: pj_uint32_t }

pub type pj_list_type = ::std::os::raw::c_void;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_hash_table_t { _unused: [u8; 0] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_hash_entry { _unused: [u8; 0] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_hash_iterator_t { pub index: pj_uint32_t, pub entry: *mut pj_hash_entry }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_ioqueue_t { _unused: [u8; 0] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_ioqueue_key_t { _unused: [u8; 0] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_timer_heap_t { _unused: [u8; 0] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_atomic_t { _unused: [u8; 0] }

pub type pj_atomic_value_t = ::std::os::raw::c_long;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_thread_t { _unused: [u8; 0] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_lock_t { _unused: [u8; 0] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_grp_lock_t { _unused: [u8; 0] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_mutex_t { _unused: [u8; 0] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_sem_t { _unused: [u8; 0] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_event_t { _unused: [u8; 0] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_pipe_t { _unused: [u8; 0] }

pub type pj_oshandle_t = *mut ::std::os::raw::c_void;
pub type pj_sock_t = ::std::os::raw::c_long;
pub type pj_sockaddr_t = ::std::os::raw::c_void;
pub type pj_color_t = ::std::os::raw::c_uint;
pub type pj_exception_id_t = ::std::os::raw::c_int;

extern "C" { pub fn pj_init() -> pj_status_t; }

extern "C" { pub fn pj_shutdown(); }

pub type pj_exit_callback = ::std::option::Option<unsafe extern "C" fn()>;

extern "C" { pub fn pj_atexit(func: pj_exit_callback) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_time_val { pub sec: ::std::os::raw::c_long, pub msec: ::std::os::raw::c_long }

extern "C" { pub fn pj_time_val_normalize(t: *mut pj_time_val); }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_parsed_time { pub wday: ::std::os::raw::c_int, pub day: ::std::os::raw::c_int, pub mon: ::std::os::raw::c_int, pub year: ::std::os::raw::c_int, pub sec: ::std::os::raw::c_int, pub min: ::std::os::raw::c_int, pub hour: ::std::os::raw::c_int, pub msec: ::std::os::raw::c_int }

pub const PJ_TERM_COLOR_R: _bindgen_ty_1 = _bindgen_ty_1::PJ_TERM_COLOR_R;
pub const PJ_TERM_COLOR_G: _bindgen_ty_1 = _bindgen_ty_1::PJ_TERM_COLOR_G;
pub const PJ_TERM_COLOR_B: _bindgen_ty_1 = _bindgen_ty_1::PJ_TERM_COLOR_B;
pub const PJ_TERM_COLOR_BRIGHT: _bindgen_ty_1 = _bindgen_ty_1::PJ_TERM_COLOR_BRIGHT;

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 { PJ_TERM_COLOR_R = 2, PJ_TERM_COLOR_G = 4, PJ_TERM_COLOR_B = 1, PJ_TERM_COLOR_BRIGHT = 8 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_cfg_t { pub endpt: pjsip_cfg_t__bindgen_ty_1, pub tsx: pjsip_cfg_t__bindgen_ty_2, pub regc: pjsip_cfg_t__bindgen_ty_3, pub tcp: pjsip_cfg_t__bindgen_ty_4, pub tls: pjsip_cfg_t__bindgen_ty_5 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_cfg_t__bindgen_ty_1 { pub allow_port_in_fromto_hdr: pj_bool_t, pub accept_replace_in_early_state: pj_bool_t, pub allow_tx_hash_in_uri: pj_bool_t, pub disable_rport: pj_bool_t, pub disable_tcp_switch: pj_bool_t, pub disable_tls_switch: pj_bool_t, pub follow_early_media_fork: pj_bool_t, pub req_has_via_alias: pj_bool_t, pub resolve_hostname_to_get_interface: pj_bool_t, pub disable_secure_dlg_check: pj_bool_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_cfg_t__bindgen_ty_2 { pub max_count: ::std::os::raw::c_uint, pub t1: ::std::os::raw::c_uint, pub t2: ::std::os::raw::c_uint, pub t4: ::std::os::raw::c_uint, pub td: ::std::os::raw::c_uint }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_cfg_t__bindgen_ty_3 { pub check_contact: pj_bool_t, pub add_xuid_param: pj_bool_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_cfg_t__bindgen_ty_4 { pub keep_alive_interval: ::std::os::raw::c_long }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_cfg_t__bindgen_ty_5 { pub keep_alive_interval: ::std::os::raw::c_long }

extern "C" {
    #[link_name = "\u{1}pjsip_sip_cfg_var"]
    pub static mut pjsip_sip_cfg_var: pjsip_cfg_t;
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_tpmgr { _unused: [u8; 0] }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsip_transport_type_e { PJSIP_TRANSPORT_UNSPECIFIED = 0, PJSIP_TRANSPORT_UDP = 1, PJSIP_TRANSPORT_TCP = 2, PJSIP_TRANSPORT_TLS = 3, PJSIP_TRANSPORT_SCTP = 4, PJSIP_TRANSPORT_LOOP = 5, PJSIP_TRANSPORT_LOOP_DGRAM = 6, PJSIP_TRANSPORT_START_OTHER = 7, PJSIP_TRANSPORT_IPV6 = 128, PJSIP_TRANSPORT_UDP6 = 129, PJSIP_TRANSPORT_TCP6 = 130, PJSIP_TRANSPORT_TLS6 = 131 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_endpoint { _unused: [u8; 0] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_resolver_t { _unused: [u8; 0] }

pub type pjsip_user_agent = pjsip_module;

impl pjsip_role_e { pub const PJSIP_UAC_ROLE: pjsip_role_e = pjsip_role_e::PJSIP_ROLE_UAC; }

impl pjsip_role_e { pub const PJSIP_UAS_ROLE: pjsip_role_e = pjsip_role_e::PJSIP_ROLE_UAS; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsip_role_e { PJSIP_ROLE_UAC = 0, PJSIP_ROLE_UAS = 1 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_buffer { pub start: *mut ::std::os::raw::c_char, pub cur: *mut ::std::os::raw::c_char, pub end: *mut ::std::os::raw::c_char }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_host_port { pub host: pj_str_t, pub port: ::std::os::raw::c_int }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_host_info { pub flag: ::std::os::raw::c_uint, pub type_: pjsip_transport_type_e, pub addr: pjsip_host_port }

extern "C" { pub fn pjsip_exception_to_status(exception_id: ::std::os::raw::c_int) -> pj_status_t; }

pub type pj_os_err_type = ::std::os::raw::c_int;
pub type va_list = __builtin_va_list;

extern "C" { pub fn pj_get_os_error() -> pj_status_t; }

extern "C" { pub fn pj_set_os_error(code: pj_status_t); }

extern "C" { pub fn pj_get_netos_error() -> pj_status_t; }

extern "C" { pub fn pj_set_netos_error(code: pj_status_t); }

extern "C" { pub fn pj_strerror(statcode: pj_status_t, buf: *mut ::std::os::raw::c_char, bufsize: pj_size_t) -> pj_str_t; }

extern "C" { pub fn pj_perror(log_level: ::std::os::raw::c_int, sender: *const ::std::os::raw::c_char, status: pj_status_t, title_fmt: *const ::std::os::raw::c_char, ...); }

pub type pj_error_callback = ::std::option::Option<unsafe extern "C" fn(e: pj_status_t, msg: *mut ::std::os::raw::c_char, max: pj_size_t) -> pj_str_t>;

extern "C" { pub fn pj_register_strerror(start_code: pj_status_t, err_space: pj_status_t, f: pj_error_callback) -> pj_status_t; }

extern "C" { pub fn pj_errno_clear_handlers(); }

extern "C" { pub fn pj_perror_1(sender: *const ::std::os::raw::c_char, status: pj_status_t, title_fmt: *const ::std::os::raw::c_char, ...); }

extern "C" { pub fn pj_perror_2(sender: *const ::std::os::raw::c_char, status: pj_status_t, title_fmt: *const ::std::os::raw::c_char, ...); }

extern "C" { pub fn pj_perror_3(sender: *const ::std::os::raw::c_char, status: pj_status_t, title_fmt: *const ::std::os::raw::c_char, ...); }

extern "C" { pub fn pj_perror_4(sender: *const ::std::os::raw::c_char, status: pj_status_t, title_fmt: *const ::std::os::raw::c_char, ...); }

extern "C" { pub fn pj_perror_5(sender: *const ::std::os::raw::c_char, status: pj_status_t, title_fmt: *const ::std::os::raw::c_char, ...); }

extern "C" { pub fn pjsip_strerror(status: pj_status_t, buffer: *mut ::std::os::raw::c_char, bufsize: pj_size_t) -> pj_str_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_list { pub prev: *mut ::std::os::raw::c_void, pub next: *mut ::std::os::raw::c_void }

extern "C" { pub fn pj_list_insert_before(pos: *mut pj_list_type, node: *mut pj_list_type); }

extern "C" { pub fn pj_list_insert_nodes_before(lst: *mut pj_list_type, nodes: *mut pj_list_type); }

extern "C" { pub fn pj_list_insert_after(pos: *mut pj_list_type, node: *mut pj_list_type); }

extern "C" { pub fn pj_list_insert_nodes_after(lst: *mut pj_list_type, nodes: *mut pj_list_type); }

extern "C" { pub fn pj_list_merge_first(list1: *mut pj_list_type, list2: *mut pj_list_type); }

extern "C" { pub fn pj_list_merge_last(list1: *mut pj_list_type, list2: *mut pj_list_type); }

extern "C" { pub fn pj_list_erase(node: *mut pj_list_type); }

extern "C" { pub fn pj_list_find_node(list: *mut pj_list_type, node: *mut pj_list_type) -> *mut pj_list_type; }

extern "C" { pub fn pj_list_search(list: *mut pj_list_type, value: *mut ::std::os::raw::c_void, comp: ::std::option::Option<unsafe extern "C" fn(value: *mut ::std::os::raw::c_void, node: *const pj_list_type) -> ::std::os::raw::c_int>) -> *mut pj_list_type; }

extern "C" { pub fn pj_list_size(list: *const pj_list_type) -> pj_size_t; }

extern "C" { pub fn pjlib_util_init() -> pj_status_t; }

pub type pj_cis_elem_t = pj_uint32_t;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pj_cis_buf_t { pub cis_buf: [pj_cis_elem_t; 256usize], pub use_mask: pj_cis_elem_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_cis_t { pub cis_buf: *mut pj_cis_elem_t, pub cis_id: ::std::os::raw::c_int }

extern "C" { pub fn pj_cis_buf_init(cs_buf: *mut pj_cis_buf_t); }

extern "C" { pub fn pj_cis_init(cs_buf: *mut pj_cis_buf_t, cis: *mut pj_cis_t) -> pj_status_t; }

extern "C" { pub fn pj_cis_dup(new_cis: *mut pj_cis_t, existing: *mut pj_cis_t) -> pj_status_t; }

extern "C" { pub fn pj_cis_add_range(cis: *mut pj_cis_t, cstart: ::std::os::raw::c_int, cend: ::std::os::raw::c_int); }

extern "C" { pub fn pj_cis_add_alpha(cis: *mut pj_cis_t); }

extern "C" { pub fn pj_cis_add_num(cis: *mut pj_cis_t); }

extern "C" { pub fn pj_cis_add_str(cis: *mut pj_cis_t, str: *const ::std::os::raw::c_char); }

extern "C" { pub fn pj_cis_add_cis(cis: *mut pj_cis_t, rhs: *const pj_cis_t); }

extern "C" { pub fn pj_cis_del_range(cis: *mut pj_cis_t, cstart: ::std::os::raw::c_int, cend: ::std::os::raw::c_int); }

extern "C" { pub fn pj_cis_del_str(cis: *mut pj_cis_t, str: *const ::std::os::raw::c_char); }

extern "C" { pub fn pj_cis_invert(cis: *mut pj_cis_t); }

pub const PJ_SCAN_AUTOSKIP_WS: _bindgen_ty_2 = _bindgen_ty_2::PJ_SCAN_AUTOSKIP_WS;
pub const PJ_SCAN_AUTOSKIP_WS_HEADER: _bindgen_ty_2 = _bindgen_ty_2::PJ_SCAN_AUTOSKIP_WS_HEADER;
pub const PJ_SCAN_AUTOSKIP_NEWLINE: _bindgen_ty_2 = _bindgen_ty_2::PJ_SCAN_AUTOSKIP_NEWLINE;

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_2 { PJ_SCAN_AUTOSKIP_WS = 1, PJ_SCAN_AUTOSKIP_WS_HEADER = 3, PJ_SCAN_AUTOSKIP_NEWLINE = 4 }

pub type pj_syn_err_func_ptr = ::std::option::Option<unsafe extern "C" fn(scanner: *mut pj_scanner)>;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_scanner { pub begin: *mut ::std::os::raw::c_char, pub end: *mut ::std::os::raw::c_char, pub curptr: *mut ::std::os::raw::c_char, pub line: ::std::os::raw::c_int, pub start_line: *mut ::std::os::raw::c_char, pub skip_ws: ::std::os::raw::c_int, pub callback: pj_syn_err_func_ptr }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_scan_state { pub curptr: *mut ::std::os::raw::c_char, pub line: ::std::os::raw::c_int, pub start_line: *mut ::std::os::raw::c_char }

extern "C" { pub fn pj_scan_init(scanner: *mut pj_scanner, bufstart: *mut ::std::os::raw::c_char, buflen: pj_size_t, options: ::std::os::raw::c_uint, callback: pj_syn_err_func_ptr); }

extern "C" { pub fn pj_scan_fini(scanner: *mut pj_scanner); }

extern "C" { pub fn pj_scan_peek(scanner: *mut pj_scanner, spec: *const pj_cis_t, out: *mut pj_str_t) -> ::std::os::raw::c_int; }

extern "C" { pub fn pj_scan_peek_n(scanner: *mut pj_scanner, len: pj_size_t, out: *mut pj_str_t) -> ::std::os::raw::c_int; }

extern "C" { pub fn pj_scan_peek_until(scanner: *mut pj_scanner, spec: *const pj_cis_t, out: *mut pj_str_t) -> ::std::os::raw::c_int; }

extern "C" { pub fn pj_scan_get(scanner: *mut pj_scanner, spec: *const pj_cis_t, out: *mut pj_str_t); }

extern "C" { pub fn pj_scan_get_unescape(scanner: *mut pj_scanner, spec: *const pj_cis_t, out: *mut pj_str_t); }

extern "C" { pub fn pj_scan_get_quote(scanner: *mut pj_scanner, begin_quote: ::std::os::raw::c_int, end_quote: ::std::os::raw::c_int, out: *mut pj_str_t); }

extern "C" { pub fn pj_scan_get_quotes(scanner: *mut pj_scanner, begin_quotes: *const ::std::os::raw::c_char, end_quotes: *const ::std::os::raw::c_char, qsize: ::std::os::raw::c_int, out: *mut pj_str_t); }

extern "C" { pub fn pj_scan_get_n(scanner: *mut pj_scanner, N: ::std::os::raw::c_uint, out: *mut pj_str_t); }

extern "C" { pub fn pj_scan_get_char(scanner: *mut pj_scanner) -> ::std::os::raw::c_int; }

extern "C" { pub fn pj_scan_get_until(scanner: *mut pj_scanner, spec: *const pj_cis_t, out: *mut pj_str_t); }

extern "C" { pub fn pj_scan_get_until_ch(scanner: *mut pj_scanner, until_char: ::std::os::raw::c_int, out: *mut pj_str_t); }

extern "C" { pub fn pj_scan_get_until_chr(scanner: *mut pj_scanner, until_spec: *const ::std::os::raw::c_char, out: *mut pj_str_t); }

extern "C" { pub fn pj_scan_advance_n(scanner: *mut pj_scanner, N: ::std::os::raw::c_uint, skip: pj_bool_t); }

extern "C" { pub fn pj_scan_strcmp(scanner: *mut pj_scanner, s: *const ::std::os::raw::c_char, len: ::std::os::raw::c_int) -> ::std::os::raw::c_int; }

extern "C" { pub fn pj_scan_stricmp(scanner: *mut pj_scanner, s: *const ::std::os::raw::c_char, len: ::std::os::raw::c_int) -> ::std::os::raw::c_int; }

extern "C" { pub fn pj_scan_stricmp_alnum(scanner: *mut pj_scanner, s: *const ::std::os::raw::c_char, len: ::std::os::raw::c_int) -> ::std::os::raw::c_int; }

extern "C" { pub fn pj_scan_get_newline(scanner: *mut pj_scanner); }

extern "C" { pub fn pj_scan_skip_whitespace(scanner: *mut pj_scanner); }

extern "C" { pub fn pj_scan_skip_line(scanner: *mut pj_scanner); }

extern "C" { pub fn pj_scan_save_state(scanner: *const pj_scanner, state: *mut pj_scan_state); }

extern "C" { pub fn pj_scan_restore_state(scanner: *mut pj_scanner, state: *mut pj_scan_state); }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_param { pub prev: *mut pjsip_param, pub next: *mut pjsip_param, pub name: pj_str_t, pub value: pj_str_t }

extern "C" { pub fn pjsip_param_find(param_list: *const pjsip_param, name: *const pj_str_t) -> *mut pjsip_param; }

extern "C" { pub fn pjsip_param_cmp(param_list1: *const pjsip_param, param_list2: *const pjsip_param, ig_nf: pj_bool_t) -> ::std::os::raw::c_int; }

extern "C" { pub fn pjsip_param_clone(pool: *mut pj_pool_t, dst_list: *mut pjsip_param, src_list: *const pjsip_param); }

extern "C" { pub fn pjsip_param_shallow_clone(pool: *mut pj_pool_t, dst_list: *mut pjsip_param, src_list: *const pjsip_param); }

extern "C" { pub fn pjsip_param_print_on(param_list: *const pjsip_param, buf: *mut ::std::os::raw::c_char, size: pj_size_t, pname_unres: *const pj_cis_t, pvalue_unres: *const pj_cis_t, sep: ::std::os::raw::c_int) -> pj_ssize_t; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsip_uri_context_e { PJSIP_URI_IN_REQ_URI = 0, PJSIP_URI_IN_FROMTO_HDR = 1, PJSIP_URI_IN_CONTACT_HDR = 2, PJSIP_URI_IN_ROUTING_HDR = 3, PJSIP_URI_IN_OTHER = 4 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_uri_vptr { pub p_get_scheme: ::std::option::Option<unsafe extern "C" fn(uri: *const ::std::os::raw::c_void) -> *const pj_str_t>, pub p_get_uri: ::std::option::Option<unsafe extern "C" fn(uri: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void>, pub p_print: ::std::option::Option<unsafe extern "C" fn(context: pjsip_uri_context_e, uri: *const ::std::os::raw::c_void, buf: *mut ::std::os::raw::c_char, size: pj_size_t) -> pj_ssize_t>, pub p_compare: ::std::option::Option<unsafe extern "C" fn(context: pjsip_uri_context_e, uri1: *const ::std::os::raw::c_void, uri2: *const ::std::os::raw::c_void) -> pj_status_t>, pub p_clone: ::std::option::Option<unsafe extern "C" fn(pool: *mut pj_pool_t, uri: *const ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void> }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_uri { pub vptr: *mut pjsip_uri_vptr }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_sip_uri { pub vptr: *mut pjsip_uri_vptr, pub user: pj_str_t, pub passwd: pj_str_t, pub host: pj_str_t, pub port: ::std::os::raw::c_int, pub user_param: pj_str_t, pub method_param: pj_str_t, pub transport_param: pj_str_t, pub ttl_param: ::std::os::raw::c_int, pub lr_param: ::std::os::raw::c_int, pub maddr_param: pj_str_t, pub other_param: pjsip_param, pub header_param: pjsip_param }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_name_addr { pub vptr: *mut pjsip_uri_vptr, pub display: pj_str_t, pub uri: *mut pjsip_uri }

extern "C" { pub fn pjsip_sip_uri_create(pool: *mut pj_pool_t, secure: pj_bool_t) -> *mut pjsip_sip_uri; }

extern "C" { pub fn pjsip_sip_uri_set_secure(uri: *mut pjsip_sip_uri, secure: pj_bool_t); }

extern "C" { pub fn pjsip_sip_uri_init(url: *mut pjsip_sip_uri, secure: pj_bool_t); }

extern "C" { pub fn pjsip_sip_uri_assign(pool: *mut pj_pool_t, url: *mut pjsip_sip_uri, rhs: *const pjsip_sip_uri); }

extern "C" { pub fn pjsip_name_addr_create(pool: *mut pj_pool_t) -> *mut pjsip_name_addr; }

extern "C" { pub fn pjsip_name_addr_init(name_addr: *mut pjsip_name_addr); }

extern "C" { pub fn pjsip_name_addr_assign(pool: *mut pj_pool_t, addr: *mut pjsip_name_addr, rhs: *const pjsip_name_addr); }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_other_uri { pub vptr: *mut pjsip_uri_vptr, pub scheme: pj_str_t, pub content: pj_str_t }

extern "C" { pub fn pjsip_other_uri_create(pool: *mut pj_pool_t) -> *mut pjsip_other_uri; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_tel_uri { pub vptr: *mut pjsip_uri_vptr, pub number: pj_str_t, pub context: pj_str_t, pub ext_param: pj_str_t, pub isub_param: pj_str_t, pub other_param: pjsip_param }

extern "C" { pub fn pjsip_tel_uri_create(pool: *mut pj_pool_t) -> *mut pjsip_tel_uri; }

extern "C" { pub fn pjsip_tel_nb_cmp(nb1: *const pj_str_t, nb2: *const pj_str_t) -> ::std::os::raw::c_int; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsip_method_e { PJSIP_INVITE_METHOD = 0, PJSIP_CANCEL_METHOD = 1, PJSIP_ACK_METHOD = 2, PJSIP_BYE_METHOD = 3, PJSIP_REGISTER_METHOD = 4, PJSIP_OPTIONS_METHOD = 5, PJSIP_OTHER_METHOD = 6 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_method { pub id: pjsip_method_e, pub name: pj_str_t }

extern "C" {
    #[link_name = "\u{1}pjsip_invite_method"]
    pub static mut pjsip_invite_method: pjsip_method;
}

extern "C" {
    #[link_name = "\u{1}pjsip_cancel_method"]
    pub static mut pjsip_cancel_method: pjsip_method;
}

extern "C" {
    #[link_name = "\u{1}pjsip_ack_method"]
    pub static mut pjsip_ack_method: pjsip_method;
}

extern "C" {
    #[link_name = "\u{1}pjsip_bye_method"]
    pub static mut pjsip_bye_method: pjsip_method;
}

extern "C" {
    #[link_name = "\u{1}pjsip_register_method"]
    pub static mut pjsip_register_method: pjsip_method;
}

extern "C" {
    #[link_name = "\u{1}pjsip_options_method"]
    pub static mut pjsip_options_method: pjsip_method;
}

extern "C" { pub fn pjsip_get_invite_method() -> *const pjsip_method; }

extern "C" { pub fn pjsip_get_cancel_method() -> *const pjsip_method; }

extern "C" { pub fn pjsip_get_ack_method() -> *const pjsip_method; }

extern "C" { pub fn pjsip_get_bye_method() -> *const pjsip_method; }

extern "C" { pub fn pjsip_get_register_method() -> *const pjsip_method; }

extern "C" { pub fn pjsip_get_options_method() -> *const pjsip_method; }

extern "C" { pub fn pjsip_method_init(m: *mut pjsip_method, pool: *mut pj_pool_t, str: *const pj_str_t); }

extern "C" { pub fn pjsip_method_init_np(m: *mut pjsip_method, str: *mut pj_str_t); }

extern "C" { pub fn pjsip_method_set(m: *mut pjsip_method, id: pjsip_method_e); }

extern "C" { pub fn pjsip_method_copy(pool: *mut pj_pool_t, method: *mut pjsip_method, rhs: *const pjsip_method); }

extern "C" { pub fn pjsip_method_cmp(m1: *const pjsip_method, m2: *const pjsip_method) -> ::std::os::raw::c_int; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsip_hdr_e { PJSIP_H_ACCEPT = 0, PJSIP_H_ACCEPT_ENCODING_UNIMP = 1, PJSIP_H_ACCEPT_LANGUAGE_UNIMP = 2, PJSIP_H_ALERT_INFO_UNIMP = 3, PJSIP_H_ALLOW = 4, PJSIP_H_AUTHENTICATION_INFO_UNIMP = 5, PJSIP_H_AUTHORIZATION = 6, PJSIP_H_CALL_ID = 7, PJSIP_H_CALL_INFO_UNIMP = 8, PJSIP_H_CONTACT = 9, PJSIP_H_CONTENT_DISPOSITION_UNIMP = 10, PJSIP_H_CONTENT_ENCODING_UNIMP = 11, PJSIP_H_CONTENT_LANGUAGE_UNIMP = 12, PJSIP_H_CONTENT_LENGTH = 13, PJSIP_H_CONTENT_TYPE = 14, PJSIP_H_CSEQ = 15, PJSIP_H_DATE_UNIMP = 16, PJSIP_H_ERROR_INFO_UNIMP = 17, PJSIP_H_EXPIRES = 18, PJSIP_H_FROM = 19, PJSIP_H_IN_REPLY_TO_UNIMP = 20, PJSIP_H_MAX_FORWARDS = 21, PJSIP_H_MIME_VERSION_UNIMP = 22, PJSIP_H_MIN_EXPIRES = 23, PJSIP_H_ORGANIZATION_UNIMP = 24, PJSIP_H_PRIORITY_UNIMP = 25, PJSIP_H_PROXY_AUTHENTICATE = 26, PJSIP_H_PROXY_AUTHORIZATION = 27, PJSIP_H_PROXY_REQUIRE_UNIMP = 28, PJSIP_H_RECORD_ROUTE = 29, PJSIP_H_REPLY_TO_UNIMP = 30, PJSIP_H_REQUIRE = 31, PJSIP_H_RETRY_AFTER = 32, PJSIP_H_ROUTE = 33, PJSIP_H_SERVER_UNIMP = 34, PJSIP_H_SUBJECT_UNIMP = 35, PJSIP_H_SUPPORTED = 36, PJSIP_H_TIMESTAMP_UNIMP = 37, PJSIP_H_TO = 38, PJSIP_H_UNSUPPORTED = 39, PJSIP_H_USER_AGENT_UNIMP = 40, PJSIP_H_VIA = 41, PJSIP_H_WARNING_UNIMP = 42, PJSIP_H_WWW_AUTHENTICATE = 43, PJSIP_H_OTHER = 44 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_hdr_vptr { pub clone: ::std::option::Option<unsafe extern "C" fn(pool: *mut pj_pool_t, hdr: *const ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void>, pub shallow_clone: ::std::option::Option<unsafe extern "C" fn(pool: *mut pj_pool_t, hdr: *const ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void>, pub print_on: ::std::option::Option<unsafe extern "C" fn(hdr: *mut ::std::os::raw::c_void, buf: *mut ::std::os::raw::c_char, len: pj_size_t) -> ::std::os::raw::c_int> }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_hdr { pub prev: *mut pjsip_hdr, pub next: *mut pjsip_hdr, pub type_: pjsip_hdr_e, pub name: pj_str_t, pub sname: pj_str_t, pub vptr: *mut pjsip_hdr_vptr }

extern "C" { pub fn pjsip_hdr_clone(pool: *mut pj_pool_t, hdr: *const ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void; }

extern "C" { pub fn pjsip_hdr_shallow_clone(pool: *mut pj_pool_t, hdr: *const ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void; }

extern "C" { pub fn pjsip_hdr_print_on(hdr: *mut ::std::os::raw::c_void, buf: *mut ::std::os::raw::c_char, len: pj_size_t) -> ::std::os::raw::c_int; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_request_line { pub method: pjsip_method, pub uri: *mut pjsip_uri }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_status_line { pub code: ::std::os::raw::c_int, pub reason: pj_str_t }

impl pjsip_status_code { pub const PJSIP_SC_TSX_TIMEOUT: pjsip_status_code = pjsip_status_code::PJSIP_SC_REQUEST_TIMEOUT; }

impl pjsip_status_code { pub const PJSIP_SC_TSX_TRANSPORT_ERROR: pjsip_status_code = pjsip_status_code::PJSIP_SC_SERVICE_UNAVAILABLE; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsip_status_code { PJSIP_SC_TRYING = 100, PJSIP_SC_RINGING = 180, PJSIP_SC_CALL_BEING_FORWARDED = 181, PJSIP_SC_QUEUED = 182, PJSIP_SC_PROGRESS = 183, PJSIP_SC_OK = 200, PJSIP_SC_ACCEPTED = 202, PJSIP_SC_MULTIPLE_CHOICES = 300, PJSIP_SC_MOVED_PERMANENTLY = 301, PJSIP_SC_MOVED_TEMPORARILY = 302, PJSIP_SC_USE_PROXY = 305, PJSIP_SC_ALTERNATIVE_SERVICE = 380, PJSIP_SC_BAD_REQUEST = 400, PJSIP_SC_UNAUTHORIZED = 401, PJSIP_SC_PAYMENT_REQUIRED = 402, PJSIP_SC_FORBIDDEN = 403, PJSIP_SC_NOT_FOUND = 404, PJSIP_SC_METHOD_NOT_ALLOWED = 405, PJSIP_SC_NOT_ACCEPTABLE = 406, PJSIP_SC_PROXY_AUTHENTICATION_REQUIRED = 407, PJSIP_SC_REQUEST_TIMEOUT = 408, PJSIP_SC_GONE = 410, PJSIP_SC_REQUEST_ENTITY_TOO_LARGE = 413, PJSIP_SC_REQUEST_URI_TOO_LONG = 414, PJSIP_SC_UNSUPPORTED_MEDIA_TYPE = 415, PJSIP_SC_UNSUPPORTED_URI_SCHEME = 416, PJSIP_SC_BAD_EXTENSION = 420, PJSIP_SC_EXTENSION_REQUIRED = 421, PJSIP_SC_SESSION_TIMER_TOO_SMALL = 422, PJSIP_SC_INTERVAL_TOO_BRIEF = 423, PJSIP_SC_TEMPORARILY_UNAVAILABLE = 480, PJSIP_SC_CALL_TSX_DOES_NOT_EXIST = 481, PJSIP_SC_LOOP_DETECTED = 482, PJSIP_SC_TOO_MANY_HOPS = 483, PJSIP_SC_ADDRESS_INCOMPLETE = 484, PJSIP_AC_AMBIGUOUS = 485, PJSIP_SC_BUSY_HERE = 486, PJSIP_SC_REQUEST_TERMINATED = 487, PJSIP_SC_NOT_ACCEPTABLE_HERE = 488, PJSIP_SC_BAD_EVENT = 489, PJSIP_SC_REQUEST_UPDATED = 490, PJSIP_SC_REQUEST_PENDING = 491, PJSIP_SC_UNDECIPHERABLE = 493, PJSIP_SC_INTERNAL_SERVER_ERROR = 500, PJSIP_SC_NOT_IMPLEMENTED = 501, PJSIP_SC_BAD_GATEWAY = 502, PJSIP_SC_SERVICE_UNAVAILABLE = 503, PJSIP_SC_SERVER_TIMEOUT = 504, PJSIP_SC_VERSION_NOT_SUPPORTED = 505, PJSIP_SC_MESSAGE_TOO_LARGE = 513, PJSIP_SC_PRECONDITION_FAILURE = 580, PJSIP_SC_BUSY_EVERYWHERE = 600, PJSIP_SC_DECLINE = 603, PJSIP_SC_DOES_NOT_EXIST_ANYWHERE = 604, PJSIP_SC_NOT_ACCEPTABLE_ANYWHERE = 606, PJSIP_SC__force_32bit = 2147483647 }

extern "C" { pub fn pjsip_get_status_text(status_code: ::std::os::raw::c_int) -> *const pj_str_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_media_type { pub type_: pj_str_t, pub subtype: pj_str_t, pub param: pjsip_param }

extern "C" { pub fn pjsip_media_type_init(mt: *mut pjsip_media_type, type_: *mut pj_str_t, subtype: *mut pj_str_t); }

extern "C" { pub fn pjsip_media_type_init2(mt: *mut pjsip_media_type, type_: *mut ::std::os::raw::c_char, subtype: *mut ::std::os::raw::c_char); }

extern "C" { pub fn pjsip_media_type_cmp(mt1: *const pjsip_media_type, mt2: *const pjsip_media_type, cmp_param: ::std::os::raw::c_int) -> ::std::os::raw::c_int; }

extern "C" { pub fn pjsip_media_type_cp(pool: *mut pj_pool_t, dst: *mut pjsip_media_type, src: *const pjsip_media_type); }

extern "C" { pub fn pjsip_media_type_print(buf: *mut ::std::os::raw::c_char, len: ::std::os::raw::c_uint, mt: *const pjsip_media_type) -> ::std::os::raw::c_int; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_msg_body { pub content_type: pjsip_media_type, pub data: *mut ::std::os::raw::c_void, pub len: ::std::os::raw::c_uint, pub print_body: ::std::option::Option<unsafe extern "C" fn(msg_body: *mut pjsip_msg_body, buf: *mut ::std::os::raw::c_char, size: pj_size_t) -> ::std::os::raw::c_int>, pub clone_data: ::std::option::Option<unsafe extern "C" fn(pool: *mut pj_pool_t, data: *const ::std::os::raw::c_void, len: ::std::os::raw::c_uint) -> *mut ::std::os::raw::c_void> }

extern "C" { pub fn pjsip_print_text_body(msg_body: *mut pjsip_msg_body, buf: *mut ::std::os::raw::c_char, size: pj_size_t) -> ::std::os::raw::c_int; }

extern "C" { pub fn pjsip_clone_text_data(pool: *mut pj_pool_t, data: *const ::std::os::raw::c_void, len: ::std::os::raw::c_uint) -> *mut ::std::os::raw::c_void; }

extern "C" { pub fn pjsip_msg_body_copy(pool: *mut pj_pool_t, dst_body: *mut pjsip_msg_body, src_body: *const pjsip_msg_body) -> pj_status_t; }

extern "C" { pub fn pjsip_msg_body_clone(pool: *mut pj_pool_t, body: *const pjsip_msg_body) -> *mut pjsip_msg_body; }

extern "C" { pub fn pjsip_msg_body_create(pool: *mut pj_pool_t, type_: *const pj_str_t, subtype: *const pj_str_t, text: *const pj_str_t) -> *mut pjsip_msg_body; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsip_msg_type_e { PJSIP_REQUEST_MSG = 0, PJSIP_RESPONSE_MSG = 1 }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsip_msg { pub type_: pjsip_msg_type_e, pub line: pjsip_msg__bindgen_ty_1, pub hdr: pjsip_hdr, pub body: *mut pjsip_msg_body }

#[repr(C)]
#[derive(Copy, Clone)]
pub union pjsip_msg__bindgen_ty_1 { pub req: pjsip_request_line, pub status: pjsip_status_line, _bindgen_union_align: [u32; 4usize] }

extern "C" { pub fn pjsip_msg_create(pool: *mut pj_pool_t, type_: pjsip_msg_type_e) -> *mut pjsip_msg; }

extern "C" { pub fn pjsip_msg_clone(pool: *mut pj_pool_t, msg: *const pjsip_msg) -> *mut pjsip_msg; }

extern "C" { pub fn pjsip_msg_find_hdr(msg: *const pjsip_msg, type_: pjsip_hdr_e, start: *const ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void; }

extern "C" { pub fn pjsip_msg_find_hdr_by_name(msg: *const pjsip_msg, name: *const pj_str_t, start: *const ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void; }

extern "C" { pub fn pjsip_msg_find_hdr_by_names(msg: *const pjsip_msg, name: *const pj_str_t, sname: *const pj_str_t, start: *const ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void; }

extern "C" { pub fn pjsip_msg_find_remove_hdr(msg: *mut pjsip_msg, hdr: pjsip_hdr_e, start: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void; }

extern "C" { pub fn pjsip_msg_print(msg: *const pjsip_msg, buf: *mut ::std::os::raw::c_char, size: pj_size_t) -> pj_ssize_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_generic_string_hdr { pub prev: *mut pjsip_generic_string_hdr, pub next: *mut pjsip_generic_string_hdr, pub type_: pjsip_hdr_e, pub name: pj_str_t, pub sname: pj_str_t, pub vptr: *mut pjsip_hdr_vptr, pub hvalue: pj_str_t }

extern "C" { pub fn pjsip_generic_string_hdr_create(pool: *mut pj_pool_t, hname: *const pj_str_t, hvalue: *const pj_str_t) -> *mut pjsip_generic_string_hdr; }

extern "C" { pub fn pjsip_generic_string_hdr_init(pool: *mut pj_pool_t, mem: *mut ::std::os::raw::c_void, hname: *const pj_str_t, hvalue: *const pj_str_t) -> *mut pjsip_generic_string_hdr; }

extern "C" { pub fn pjsip_generic_string_hdr_init2(h: *mut pjsip_generic_string_hdr, hname: *mut pj_str_t, hvalue: *mut pj_str_t); }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_generic_int_hdr { pub prev: *mut pjsip_generic_int_hdr, pub next: *mut pjsip_generic_int_hdr, pub type_: pjsip_hdr_e, pub name: pj_str_t, pub sname: pj_str_t, pub vptr: *mut pjsip_hdr_vptr, pub ivalue: pj_int32_t }

extern "C" { pub fn pjsip_generic_int_hdr_create(pool: *mut pj_pool_t, hname: *const pj_str_t, hvalue: ::std::os::raw::c_int) -> *mut pjsip_generic_int_hdr; }

extern "C" { pub fn pjsip_generic_int_hdr_init(pool: *mut pj_pool_t, mem: *mut ::std::os::raw::c_void, hname: *const pj_str_t, value: ::std::os::raw::c_int) -> *mut pjsip_generic_int_hdr; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_generic_array_hdr { pub prev: *mut pjsip_generic_array_hdr, pub next: *mut pjsip_generic_array_hdr, pub type_: pjsip_hdr_e, pub name: pj_str_t, pub sname: pj_str_t, pub vptr: *mut pjsip_hdr_vptr, pub count: ::std::os::raw::c_uint, pub values: [pj_str_t; 32usize] }

extern "C" { pub fn pjsip_generic_array_hdr_create(pool: *mut pj_pool_t, hname: *const pj_str_t) -> *mut pjsip_generic_array_hdr; }

extern "C" { pub fn pjsip_generic_array_hdr_init(pool: *mut pj_pool_t, mem: *mut ::std::os::raw::c_void, hname: *const pj_str_t) -> *mut pjsip_generic_array_hdr; }

pub type pjsip_accept_hdr = pjsip_generic_array_hdr;

extern "C" { pub fn pjsip_accept_hdr_create(pool: *mut pj_pool_t) -> *mut pjsip_accept_hdr; }

extern "C" { pub fn pjsip_accept_hdr_init(pool: *mut pj_pool_t, mem: *mut ::std::os::raw::c_void) -> *mut pjsip_accept_hdr; }

pub type pjsip_allow_hdr = pjsip_generic_array_hdr;

extern "C" { pub fn pjsip_allow_hdr_create(pool: *mut pj_pool_t) -> *mut pjsip_allow_hdr; }

extern "C" { pub fn pjsip_allow_hdr_init(pool: *mut pj_pool_t, mem: *mut ::std::os::raw::c_void) -> *mut pjsip_allow_hdr; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_cid_hdr { pub prev: *mut pjsip_cid_hdr, pub next: *mut pjsip_cid_hdr, pub type_: pjsip_hdr_e, pub name: pj_str_t, pub sname: pj_str_t, pub vptr: *mut pjsip_hdr_vptr, pub id: pj_str_t }

extern "C" { pub fn pjsip_cid_hdr_create(pool: *mut pj_pool_t) -> *mut pjsip_cid_hdr; }

extern "C" { pub fn pjsip_cid_hdr_init(pool: *mut pj_pool_t, mem: *mut ::std::os::raw::c_void) -> *mut pjsip_cid_hdr; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_clen_hdr { pub prev: *mut pjsip_clen_hdr, pub next: *mut pjsip_clen_hdr, pub type_: pjsip_hdr_e, pub name: pj_str_t, pub sname: pj_str_t, pub vptr: *mut pjsip_hdr_vptr, pub len: ::std::os::raw::c_int }

extern "C" { pub fn pjsip_clen_hdr_create(pool: *mut pj_pool_t) -> *mut pjsip_clen_hdr; }

extern "C" { pub fn pjsip_clen_hdr_init(pool: *mut pj_pool_t, mem: *mut ::std::os::raw::c_void) -> *mut pjsip_clen_hdr; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_cseq_hdr { pub prev: *mut pjsip_cseq_hdr, pub next: *mut pjsip_cseq_hdr, pub type_: pjsip_hdr_e, pub name: pj_str_t, pub sname: pj_str_t, pub vptr: *mut pjsip_hdr_vptr, pub cseq: pj_int32_t, pub method: pjsip_method }

extern "C" { pub fn pjsip_cseq_hdr_create(pool: *mut pj_pool_t) -> *mut pjsip_cseq_hdr; }

extern "C" { pub fn pjsip_cseq_hdr_init(pool: *mut pj_pool_t, mem: *mut ::std::os::raw::c_void) -> *mut pjsip_cseq_hdr; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_contact_hdr { pub prev: *mut pjsip_contact_hdr, pub next: *mut pjsip_contact_hdr, pub type_: pjsip_hdr_e, pub name: pj_str_t, pub sname: pj_str_t, pub vptr: *mut pjsip_hdr_vptr, pub star: ::std::os::raw::c_int, pub uri: *mut pjsip_uri, pub q1000: ::std::os::raw::c_int, pub expires: pj_int32_t, pub other_param: pjsip_param }

extern "C" { pub fn pjsip_contact_hdr_create(pool: *mut pj_pool_t) -> *mut pjsip_contact_hdr; }

extern "C" { pub fn pjsip_contact_hdr_init(pool: *mut pj_pool_t, mem: *mut ::std::os::raw::c_void) -> *mut pjsip_contact_hdr; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_ctype_hdr { pub prev: *mut pjsip_ctype_hdr, pub next: *mut pjsip_ctype_hdr, pub type_: pjsip_hdr_e, pub name: pj_str_t, pub sname: pj_str_t, pub vptr: *mut pjsip_hdr_vptr, pub media: pjsip_media_type }

extern "C" { pub fn pjsip_ctype_hdr_create(pool: *mut pj_pool_t) -> *mut pjsip_ctype_hdr; }

extern "C" { pub fn pjsip_ctype_hdr_init(pool: *mut pj_pool_t, mem: *mut ::std::os::raw::c_void) -> *mut pjsip_ctype_hdr; }

pub type pjsip_expires_hdr = pjsip_generic_int_hdr;

extern "C" { pub fn pjsip_expires_hdr_create(pool: *mut pj_pool_t, value: ::std::os::raw::c_int) -> *mut pjsip_expires_hdr; }

extern "C" { pub fn pjsip_expires_hdr_init(pool: *mut pj_pool_t, mem: *mut ::std::os::raw::c_void, value: ::std::os::raw::c_int) -> *mut pjsip_expires_hdr; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_fromto_hdr { pub prev: *mut pjsip_fromto_hdr, pub next: *mut pjsip_fromto_hdr, pub type_: pjsip_hdr_e, pub name: pj_str_t, pub sname: pj_str_t, pub vptr: *mut pjsip_hdr_vptr, pub uri: *mut pjsip_uri, pub tag: pj_str_t, pub other_param: pjsip_param }

pub type pjsip_from_hdr = pjsip_fromto_hdr;
pub type pjsip_to_hdr = pjsip_fromto_hdr;

extern "C" { pub fn pjsip_from_hdr_create(pool: *mut pj_pool_t) -> *mut pjsip_from_hdr; }

extern "C" { pub fn pjsip_from_hdr_init(pool: *mut pj_pool_t, mem: *mut ::std::os::raw::c_void) -> *mut pjsip_from_hdr; }

extern "C" { pub fn pjsip_to_hdr_create(pool: *mut pj_pool_t) -> *mut pjsip_to_hdr; }

extern "C" { pub fn pjsip_to_hdr_init(pool: *mut pj_pool_t, mem: *mut ::std::os::raw::c_void) -> *mut pjsip_to_hdr; }

extern "C" { pub fn pjsip_fromto_hdr_set_from(hdr: *mut pjsip_fromto_hdr) -> *mut pjsip_from_hdr; }

extern "C" { pub fn pjsip_fromto_hdr_set_to(hdr: *mut pjsip_fromto_hdr) -> *mut pjsip_to_hdr; }

pub type pjsip_max_fwd_hdr = pjsip_generic_int_hdr;

extern "C" { pub fn pjsip_max_fwd_hdr_create(pool: *mut pj_pool_t, value: ::std::os::raw::c_int) -> *mut pjsip_max_fwd_hdr; }

extern "C" { pub fn pjsip_max_fwd_hdr_init(pool: *mut pj_pool_t, mem: *mut ::std::os::raw::c_void, value: ::std::os::raw::c_int) -> *mut pjsip_max_fwd_hdr; }

pub type pjsip_min_expires_hdr = pjsip_generic_int_hdr;

extern "C" { pub fn pjsip_min_expires_hdr_create(pool: *mut pj_pool_t, value: ::std::os::raw::c_int) -> *mut pjsip_min_expires_hdr; }

extern "C" { pub fn pjsip_min_expires_hdr_init(pool: *mut pj_pool_t, mem: *mut ::std::os::raw::c_void, value: ::std::os::raw::c_int) -> *mut pjsip_min_expires_hdr; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_routing_hdr { pub prev: *mut pjsip_routing_hdr, pub next: *mut pjsip_routing_hdr, pub type_: pjsip_hdr_e, pub name: pj_str_t, pub sname: pj_str_t, pub vptr: *mut pjsip_hdr_vptr, pub name_addr: pjsip_name_addr, pub other_param: pjsip_param }

pub type pjsip_rr_hdr = pjsip_routing_hdr;
pub type pjsip_route_hdr = pjsip_routing_hdr;

extern "C" { pub fn pjsip_rr_hdr_create(pool: *mut pj_pool_t) -> *mut pjsip_rr_hdr; }

extern "C" { pub fn pjsip_rr_hdr_init(pool: *mut pj_pool_t, mem: *mut ::std::os::raw::c_void) -> *mut pjsip_rr_hdr; }

extern "C" { pub fn pjsip_route_hdr_create(pool: *mut pj_pool_t) -> *mut pjsip_route_hdr; }

extern "C" { pub fn pjsip_route_hdr_init(pool: *mut pj_pool_t, mem: *mut ::std::os::raw::c_void) -> *mut pjsip_route_hdr; }

extern "C" { pub fn pjsip_routing_hdr_set_rr(r: *mut pjsip_routing_hdr) -> *mut pjsip_rr_hdr; }

extern "C" { pub fn pjsip_routing_hdr_set_route(r: *mut pjsip_routing_hdr) -> *mut pjsip_route_hdr; }

pub type pjsip_require_hdr = pjsip_generic_array_hdr;

extern "C" { pub fn pjsip_require_hdr_create(pool: *mut pj_pool_t) -> *mut pjsip_require_hdr; }

extern "C" { pub fn pjsip_require_hdr_init(pool: *mut pj_pool_t, mem: *mut ::std::os::raw::c_void) -> *mut pjsip_require_hdr; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_retry_after_hdr { pub prev: *mut pjsip_retry_after_hdr, pub next: *mut pjsip_retry_after_hdr, pub type_: pjsip_hdr_e, pub name: pj_str_t, pub sname: pj_str_t, pub vptr: *mut pjsip_hdr_vptr, pub ivalue: pj_int32_t, pub param: pjsip_param, pub comment: pj_str_t }

extern "C" { pub fn pjsip_retry_after_hdr_create(pool: *mut pj_pool_t, value: ::std::os::raw::c_int) -> *mut pjsip_retry_after_hdr; }

extern "C" { pub fn pjsip_retry_after_hdr_init(pool: *mut pj_pool_t, mem: *mut ::std::os::raw::c_void, value: ::std::os::raw::c_int) -> *mut pjsip_retry_after_hdr; }

pub type pjsip_supported_hdr = pjsip_generic_array_hdr;

extern "C" { pub fn pjsip_supported_hdr_create(pool: *mut pj_pool_t) -> *mut pjsip_supported_hdr; }

extern "C" { pub fn pjsip_supported_hdr_init(pool: *mut pj_pool_t, mem: *mut ::std::os::raw::c_void) -> *mut pjsip_supported_hdr; }

pub type pjsip_unsupported_hdr = pjsip_generic_array_hdr;

extern "C" { pub fn pjsip_unsupported_hdr_create(pool: *mut pj_pool_t) -> *mut pjsip_unsupported_hdr; }

extern "C" { pub fn pjsip_unsupported_hdr_init(pool: *mut pj_pool_t, mem: *mut ::std::os::raw::c_void) -> *mut pjsip_unsupported_hdr; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_via_hdr { pub prev: *mut pjsip_via_hdr, pub next: *mut pjsip_via_hdr, pub type_: pjsip_hdr_e, pub name: pj_str_t, pub sname: pj_str_t, pub vptr: *mut pjsip_hdr_vptr, pub transport: pj_str_t, pub sent_by: pjsip_host_port, pub ttl_param: ::std::os::raw::c_int, pub rport_param: ::std::os::raw::c_int, pub maddr_param: pj_str_t, pub recvd_param: pj_str_t, pub branch_param: pj_str_t, pub other_param: pjsip_param, pub comment: pj_str_t }

extern "C" { pub fn pjsip_via_hdr_create(pool: *mut pj_pool_t) -> *mut pjsip_via_hdr; }

extern "C" { pub fn pjsip_via_hdr_init(pool: *mut pj_pool_t, mem: *mut ::std::os::raw::c_void) -> *mut pjsip_via_hdr; }

pub type pjsip_warning_hdr = pjsip_generic_string_hdr;

extern "C" { pub fn pjsip_warning_hdr_create(pool: *mut pj_pool_t, code: ::std::os::raw::c_int, host: *const pj_str_t, text: *const pj_str_t) -> *mut pjsip_warning_hdr; }

extern "C" { pub fn pjsip_warning_hdr_create_from_status(pool: *mut pj_pool_t, host: *const pj_str_t, status: pj_status_t) -> *mut pjsip_warning_hdr; }

pub type pjsip_accept_encoding_hdr = pjsip_generic_string_hdr;
pub type pjsip_accept_lang_hdr = pjsip_generic_string_hdr;
pub type pjsip_alert_info_hdr = pjsip_generic_string_hdr;
pub type pjsip_auth_info_hdr = pjsip_generic_string_hdr;
pub type pjsip_call_info_hdr = pjsip_generic_string_hdr;
pub type pjsip_content_disposition_hdr = pjsip_generic_string_hdr;
pub type pjsip_content_encoding_hdr = pjsip_generic_string_hdr;
pub type pjsip_content_lang_hdr = pjsip_generic_string_hdr;
pub type pjsip_date_hdr = pjsip_generic_string_hdr;
pub type pjsip_err_info_hdr = pjsip_generic_string_hdr;
pub type pjsip_in_reply_to_hdr = pjsip_generic_string_hdr;
pub type pjsip_mime_version_hdr = pjsip_generic_string_hdr;
pub type pjsip_organization_hdr = pjsip_generic_string_hdr;
pub type pjsip_priority_hdr = pjsip_generic_string_hdr;
pub type pjsip_proxy_require_hdr = pjsip_generic_string_hdr;
pub type pjsip_reply_to_hdr = pjsip_generic_string_hdr;
pub type pjsip_server_hdr = pjsip_generic_string_hdr;
pub type pjsip_subject_hdr = pjsip_generic_string_hdr;
pub type pjsip_timestamp_hdr = pjsip_generic_string_hdr;
pub type pjsip_user_agent_hdr = pjsip_generic_string_hdr;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_multipart_part { pub prev: *mut pjsip_multipart_part, pub next: *mut pjsip_multipart_part, pub hdr: pjsip_hdr, pub body: *mut pjsip_msg_body }

extern "C" { pub fn pjsip_multipart_create(pool: *mut pj_pool_t, ctype: *const pjsip_media_type, boundary: *const pj_str_t) -> *mut pjsip_msg_body; }

extern "C" { pub fn pjsip_multipart_create_part(pool: *mut pj_pool_t) -> *mut pjsip_multipart_part; }

extern "C" { pub fn pjsip_multipart_clone_part(pool: *mut pj_pool_t, part: *const pjsip_multipart_part) -> *mut pjsip_multipart_part; }

extern "C" { pub fn pjsip_multipart_add_part(pool: *mut pj_pool_t, mp: *mut pjsip_msg_body, part: *mut pjsip_multipart_part) -> pj_status_t; }

extern "C" { pub fn pjsip_multipart_get_first_part(mp: *const pjsip_msg_body) -> *mut pjsip_multipart_part; }

extern "C" { pub fn pjsip_multipart_get_next_part(mp: *const pjsip_msg_body, part: *mut pjsip_multipart_part) -> *mut pjsip_multipart_part; }

extern "C" { pub fn pjsip_multipart_find_part(mp: *const pjsip_msg_body, content_type: *const pjsip_media_type, start: *const pjsip_multipart_part) -> *mut pjsip_multipart_part; }

extern "C" { pub fn pjsip_multipart_parse(pool: *mut pj_pool_t, buf: *mut ::std::os::raw::c_char, len: pj_size_t, ctype: *const pjsip_media_type, options: ::std::os::raw::c_uint) -> *mut pjsip_msg_body; }

extern "C" { pub fn pjsip_multipart_get_raw(mp: *mut pjsip_msg_body, boundary: *mut pj_str_t, raw_data: *mut pj_str_t) -> pj_status_t; }

pub const PJSIP_PARSE_URI_AS_NAMEADDR: _bindgen_ty_3 = _bindgen_ty_3::PJSIP_PARSE_URI_AS_NAMEADDR;
pub const PJSIP_PARSE_URI_IN_FROM_TO_HDR: _bindgen_ty_3 = _bindgen_ty_3::PJSIP_PARSE_URI_IN_FROM_TO_HDR;

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_3 { PJSIP_PARSE_URI_AS_NAMEADDR = 1, PJSIP_PARSE_URI_IN_FROM_TO_HDR = 2 }

extern "C" {
    #[link_name = "\u{1}PJSIP_SYN_ERR_EXCEPTION"]
    pub static mut PJSIP_SYN_ERR_EXCEPTION: ::std::os::raw::c_int;
}

extern "C" {
    #[link_name = "\u{1}PJSIP_EINVAL_ERR_EXCEPTION"]
    pub static mut PJSIP_EINVAL_ERR_EXCEPTION: ::std::os::raw::c_int;
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_parser_err_report { pub prev: *mut pjsip_parser_err_report, pub next: *mut pjsip_parser_err_report, pub except_code: ::std::os::raw::c_int, pub line: ::std::os::raw::c_int, pub col: ::std::os::raw::c_int, pub hname: pj_str_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_parse_ctx { pub scanner: *mut pj_scanner, pub pool: *mut pj_pool_t, pub rdata: *mut pjsip_rx_data }

pub type pjsip_parse_hdr_func = ::std::option::Option<unsafe extern "C" fn(context: *mut pjsip_parse_ctx) -> *mut pjsip_hdr>;
pub type pjsip_parse_uri_func = ::std::option::Option<unsafe extern "C" fn(scanner: *mut pj_scanner, pool: *mut pj_pool_t, parse_params: pj_bool_t) -> *mut ::std::os::raw::c_void>;

extern "C" { pub fn pjsip_register_hdr_parser(hname: *const ::std::os::raw::c_char, hshortname: *const ::std::os::raw::c_char, fptr: pjsip_parse_hdr_func) -> pj_status_t; }

extern "C" { pub fn pjsip_unregister_hdr_parser(hname: *const ::std::os::raw::c_char, hshortname: *const ::std::os::raw::c_char, fptr: pjsip_parse_hdr_func) -> pj_status_t; }

extern "C" { pub fn pjsip_register_uri_parser(scheme: *mut ::std::os::raw::c_char, func: pjsip_parse_uri_func) -> pj_status_t; }

extern "C" { pub fn pjsip_unregister_uri_parser(scheme: *const ::std::os::raw::c_char, func: pjsip_parse_uri_func) -> pj_status_t; }

extern "C" { pub fn pjsip_parse_uri(pool: *mut pj_pool_t, buf: *mut ::std::os::raw::c_char, size: pj_size_t, options: ::std::os::raw::c_uint) -> *mut pjsip_uri; }

extern "C" { pub fn pjsip_parse_status_line(buf: *mut ::std::os::raw::c_char, size: pj_size_t, status_line: *mut pjsip_status_line) -> pj_status_t; }

extern "C" { pub fn pjsip_parse_msg(pool: *mut pj_pool_t, buf: *mut ::std::os::raw::c_char, size: pj_size_t, err_list: *mut pjsip_parser_err_report) -> *mut pjsip_msg; }

extern "C" { pub fn pjsip_parse_rdata(buf: *mut ::std::os::raw::c_char, size: pj_size_t, rdata: *mut pjsip_rx_data) -> *mut pjsip_msg; }

extern "C" { pub fn pjsip_find_msg(buf: *const ::std::os::raw::c_char, size: pj_size_t, is_datagram: pj_bool_t, msg_size: *mut pj_size_t) -> pj_status_t; }

extern "C" { pub fn pjsip_parse_hdr(pool: *mut pj_pool_t, hname: *const pj_str_t, line: *mut ::std::os::raw::c_char, size: pj_size_t, parsed_len: *mut ::std::os::raw::c_int) -> *mut ::std::os::raw::c_void; }

extern "C" { pub fn pjsip_parse_headers(pool: *mut pj_pool_t, input: *mut ::std::os::raw::c_char, size: pj_size_t, hlist: *mut pjsip_hdr, options: ::std::os::raw::c_uint) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_parser_const_t { pub pjsip_USER_STR: pj_str_t, pub pjsip_METHOD_STR: pj_str_t, pub pjsip_TRANSPORT_STR: pj_str_t, pub pjsip_MADDR_STR: pj_str_t, pub pjsip_LR_STR: pj_str_t, pub pjsip_SIP_STR: pj_str_t, pub pjsip_SIPS_STR: pj_str_t, pub pjsip_TEL_STR: pj_str_t, pub pjsip_BRANCH_STR: pj_str_t, pub pjsip_TTL_STR: pj_str_t, pub pjsip_RECEIVED_STR: pj_str_t, pub pjsip_Q_STR: pj_str_t, pub pjsip_EXPIRES_STR: pj_str_t, pub pjsip_TAG_STR: pj_str_t, pub pjsip_RPORT_STR: pj_str_t, pub pjsip_HOST_SPEC: pj_cis_t, pub pjsip_DIGIT_SPEC: pj_cis_t, pub pjsip_ALPHA_SPEC: pj_cis_t, pub pjsip_ALNUM_SPEC: pj_cis_t, pub pjsip_TOKEN_SPEC: pj_cis_t, pub pjsip_TOKEN_SPEC_ESC: pj_cis_t, pub pjsip_VIA_PARAM_SPEC: pj_cis_t, pub pjsip_VIA_PARAM_SPEC_ESC: pj_cis_t, pub pjsip_HEX_SPEC: pj_cis_t, pub pjsip_PARAM_CHAR_SPEC: pj_cis_t, pub pjsip_PARAM_CHAR_SPEC_ESC: pj_cis_t, pub pjsip_HDR_CHAR_SPEC: pj_cis_t, pub pjsip_HDR_CHAR_SPEC_ESC: pj_cis_t, pub pjsip_PROBE_USER_HOST_SPEC: pj_cis_t, pub pjsip_PASSWD_SPEC: pj_cis_t, pub pjsip_PASSWD_SPEC_ESC: pj_cis_t, pub pjsip_USER_SPEC: pj_cis_t, pub pjsip_USER_SPEC_ESC: pj_cis_t, pub pjsip_USER_SPEC_LENIENT: pj_cis_t, pub pjsip_USER_SPEC_LENIENT_ESC: pj_cis_t, pub pjsip_NOT_NEWLINE: pj_cis_t, pub pjsip_NOT_COMMA_OR_NEWLINE: pj_cis_t, pub pjsip_DISPLAY_SPEC: pj_cis_t, pub pjsip_OTHER_URI_CONTENT: pj_cis_t }

extern "C" { pub fn pjsip_parser_const() -> *const pjsip_parser_const_t; }

pub const PJSIP_PARSE_REMOVE_QUOTE: _bindgen_ty_4 = _bindgen_ty_4::PJSIP_PARSE_REMOVE_QUOTE;

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_4 { PJSIP_PARSE_REMOVE_QUOTE = 1 }

extern "C" { pub fn pjsip_parse_param_imp(scanner: *mut pj_scanner, pool: *mut pj_pool_t, pname: *mut pj_str_t, pvalue: *mut pj_str_t, opt: ::std::os::raw::c_uint); }

extern "C" { pub fn pjsip_parse_uri_param_imp(scanner: *mut pj_scanner, pool: *mut pj_pool_t, pname: *mut pj_str_t, pvalue: *mut pj_str_t, opt: ::std::os::raw::c_uint); }

extern "C" { pub fn pjsip_concat_param_imp(param: *mut pj_str_t, pool: *mut pj_pool_t, pname: *const pj_str_t, pvalue: *const pj_str_t, sepchar: ::std::os::raw::c_int); }

extern "C" { pub fn pjsip_parse_end_hdr_imp(scanner: *mut pj_scanner); }

extern "C" { pub fn pjsip_parse_generic_array_hdr_imp(hdr: *mut pjsip_generic_array_hdr, scanner: *mut pj_scanner); }

extern "C" { pub fn pj_lock_create_simple_mutex(pool: *mut pj_pool_t, name: *const ::std::os::raw::c_char, lock: *mut *mut pj_lock_t) -> pj_status_t; }

extern "C" { pub fn pj_lock_create_recursive_mutex(pool: *mut pj_pool_t, name: *const ::std::os::raw::c_char, lock: *mut *mut pj_lock_t) -> pj_status_t; }

extern "C" { pub fn pj_lock_create_null_mutex(pool: *mut pj_pool_t, name: *const ::std::os::raw::c_char, lock: *mut *mut pj_lock_t) -> pj_status_t; }

extern "C" { pub fn pj_lock_create_semaphore(pool: *mut pj_pool_t, name: *const ::std::os::raw::c_char, initial: ::std::os::raw::c_uint, max: ::std::os::raw::c_uint, lock: *mut *mut pj_lock_t) -> pj_status_t; }

extern "C" { pub fn pj_lock_acquire(lock: *mut pj_lock_t) -> pj_status_t; }

extern "C" { pub fn pj_lock_tryacquire(lock: *mut pj_lock_t) -> pj_status_t; }

extern "C" { pub fn pj_lock_release(lock: *mut pj_lock_t) -> pj_status_t; }

extern "C" { pub fn pj_lock_destroy(lock: *mut pj_lock_t) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_grp_lock_config { pub flags: ::std::os::raw::c_uint }

extern "C" { pub fn pj_grp_lock_config_default(cfg: *mut pj_grp_lock_config); }

extern "C" { pub fn pj_grp_lock_create(pool: *mut pj_pool_t, cfg: *const pj_grp_lock_config, p_grp_lock: *mut *mut pj_grp_lock_t) -> pj_status_t; }

extern "C" { pub fn pj_grp_lock_create_w_handler(pool: *mut pj_pool_t, cfg: *const pj_grp_lock_config, member: *mut ::std::os::raw::c_void, handler: ::std::option::Option<unsafe extern "C" fn(member: *mut ::std::os::raw::c_void)>, p_grp_lock: *mut *mut pj_grp_lock_t) -> pj_status_t; }

extern "C" { pub fn pj_grp_lock_destroy(grp_lock: *mut pj_grp_lock_t) -> pj_status_t; }

extern "C" { pub fn pj_grp_lock_replace(old_lock: *mut pj_grp_lock_t, new_lock: *mut pj_grp_lock_t) -> pj_status_t; }

extern "C" { pub fn pj_grp_lock_acquire(grp_lock: *mut pj_grp_lock_t) -> pj_status_t; }

extern "C" { pub fn pj_grp_lock_tryacquire(grp_lock: *mut pj_grp_lock_t) -> pj_status_t; }

extern "C" { pub fn pj_grp_lock_release(grp_lock: *mut pj_grp_lock_t) -> pj_status_t; }

extern "C" { pub fn pj_grp_lock_add_handler(grp_lock: *mut pj_grp_lock_t, pool: *mut pj_pool_t, member: *mut ::std::os::raw::c_void, handler: ::std::option::Option<unsafe extern "C" fn(member: *mut ::std::os::raw::c_void)>) -> pj_status_t; }

extern "C" { pub fn pj_grp_lock_del_handler(grp_lock: *mut pj_grp_lock_t, member: *mut ::std::os::raw::c_void, handler: ::std::option::Option<unsafe extern "C" fn(member: *mut ::std::os::raw::c_void)>) -> pj_status_t; }

extern "C" { pub fn pj_grp_lock_add_ref(grp_lock: *mut pj_grp_lock_t) -> pj_status_t; }

extern "C" { pub fn pj_grp_lock_dec_ref(grp_lock: *mut pj_grp_lock_t) -> pj_status_t; }

extern "C" { pub fn pj_grp_lock_get_ref(grp_lock: *mut pj_grp_lock_t) -> ::std::os::raw::c_int; }

extern "C" { pub fn pj_grp_lock_dump(grp_lock: *mut pj_grp_lock_t); }

extern "C" { pub fn pj_grp_lock_chain_lock(grp_lock: *mut pj_grp_lock_t, ext_lock: *mut pj_lock_t, pos: ::std::os::raw::c_int) -> pj_status_t; }

extern "C" { pub fn pj_grp_lock_unchain_lock(grp_lock: *mut pj_grp_lock_t, ext_lock: *mut pj_lock_t) -> pj_status_t; }

pub type pj_timer_id_t = ::std::os::raw::c_int;
pub type pj_timer_heap_callback = ::std::option::Option<unsafe extern "C" fn(timer_heap: *mut pj_timer_heap_t, entry: *mut pj_timer_entry)>;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_timer_entry { pub user_data: *mut ::std::os::raw::c_void, pub id: ::std::os::raw::c_int, pub cb: pj_timer_heap_callback, pub _timer_id: pj_timer_id_t, pub _timer_value: pj_time_val, pub _grp_lock: *mut pj_grp_lock_t }

extern "C" { pub fn pj_timer_heap_mem_size(count: pj_size_t) -> pj_size_t; }

extern "C" { pub fn pj_timer_heap_create(pool: *mut pj_pool_t, count: pj_size_t, ht: *mut *mut pj_timer_heap_t) -> pj_status_t; }

extern "C" { pub fn pj_timer_heap_destroy(ht: *mut pj_timer_heap_t); }

extern "C" { pub fn pj_timer_heap_set_lock(ht: *mut pj_timer_heap_t, lock: *mut pj_lock_t, auto_del: pj_bool_t); }

extern "C" { pub fn pj_timer_heap_set_max_timed_out_per_poll(ht: *mut pj_timer_heap_t, count: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint; }

extern "C" { pub fn pj_timer_entry_init(entry: *mut pj_timer_entry, id: ::std::os::raw::c_int, user_data: *mut ::std::os::raw::c_void, cb: pj_timer_heap_callback) -> *mut pj_timer_entry; }

extern "C" { pub fn pj_timer_entry_running(entry: *mut pj_timer_entry) -> pj_bool_t; }

extern "C" { pub fn pj_timer_heap_schedule(ht: *mut pj_timer_heap_t, entry: *mut pj_timer_entry, delay: *const pj_time_val) -> pj_status_t; }

extern "C" { pub fn pj_timer_heap_schedule_w_grp_lock(ht: *mut pj_timer_heap_t, entry: *mut pj_timer_entry, delay: *const pj_time_val, id_val: ::std::os::raw::c_int, grp_lock: *mut pj_grp_lock_t) -> pj_status_t; }

extern "C" { pub fn pj_timer_heap_cancel(ht: *mut pj_timer_heap_t, entry: *mut pj_timer_entry) -> ::std::os::raw::c_int; }

extern "C" { pub fn pj_timer_heap_cancel_if_active(ht: *mut pj_timer_heap_t, entry: *mut pj_timer_entry, id_val: ::std::os::raw::c_int) -> ::std::os::raw::c_int; }

extern "C" { pub fn pj_timer_heap_count(ht: *mut pj_timer_heap_t) -> pj_size_t; }

extern "C" { pub fn pj_timer_heap_earliest_time(ht: *mut pj_timer_heap_t, timeval: *mut pj_time_val) -> pj_status_t; }

extern "C" { pub fn pj_timer_heap_poll(ht: *mut pj_timer_heap_t, next_delay: *mut pj_time_val) -> ::std::os::raw::c_uint; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsip_event_id_e { PJSIP_EVENT_UNKNOWN = 0, PJSIP_EVENT_TIMER = 1, PJSIP_EVENT_TX_MSG = 2, PJSIP_EVENT_RX_MSG = 3, PJSIP_EVENT_TRANSPORT_ERROR = 4, PJSIP_EVENT_TSX_STATE = 5, PJSIP_EVENT_USER = 6 }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsip_event { pub prev: *mut pjsip_event, pub next: *mut pjsip_event, pub type_: pjsip_event_id_e, pub body: pjsip_event__bindgen_ty_1 }

#[repr(C)]
#[derive(Copy, Clone)]
pub union pjsip_event__bindgen_ty_1 { pub timer: pjsip_event__bindgen_ty_1__bindgen_ty_1, pub tsx_state: pjsip_event__bindgen_ty_1__bindgen_ty_2, pub tx_msg: pjsip_event__bindgen_ty_1__bindgen_ty_3, pub tx_error: pjsip_event__bindgen_ty_1__bindgen_ty_4, pub rx_msg: pjsip_event__bindgen_ty_1__bindgen_ty_5, pub user: pjsip_event__bindgen_ty_1__bindgen_ty_6, _bindgen_union_align: [u32; 4usize] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_event__bindgen_ty_1__bindgen_ty_1 { pub entry: *mut pj_timer_entry }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsip_event__bindgen_ty_1__bindgen_ty_2 { pub src: pjsip_event__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1, pub tsx: *mut pjsip_transaction, pub prev_state: ::std::os::raw::c_int, pub type_: pjsip_event_id_e }

#[repr(C)]
#[derive(Copy, Clone)]
pub union pjsip_event__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 { pub rdata: *mut pjsip_rx_data, pub tdata: *mut pjsip_tx_data, pub timer: *mut pj_timer_entry, pub status: pj_status_t, pub data: *mut ::std::os::raw::c_void, _bindgen_union_align: u32 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_event__bindgen_ty_1__bindgen_ty_3 { pub tdata: *mut pjsip_tx_data }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_event__bindgen_ty_1__bindgen_ty_4 { pub tdata: *mut pjsip_tx_data, pub tsx: *mut pjsip_transaction }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_event__bindgen_ty_1__bindgen_ty_5 { pub rdata: *mut pjsip_rx_data }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_event__bindgen_ty_1__bindgen_ty_6 { pub user1: *mut ::std::os::raw::c_void, pub user2: *mut ::std::os::raw::c_void, pub user3: *mut ::std::os::raw::c_void, pub user4: *mut ::std::os::raw::c_void }

extern "C" { pub fn pjsip_event_str(e: pjsip_event_id_e) -> *const ::std::os::raw::c_char; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_module { pub prev: *mut pjsip_module, pub next: *mut pjsip_module, pub name: pj_str_t, pub id: ::std::os::raw::c_int, pub priority: ::std::os::raw::c_int, pub load: ::std::option::Option<unsafe extern "C" fn(endpt: *mut pjsip_endpoint) -> pj_status_t>, pub start: ::std::option::Option<unsafe extern "C" fn() -> pj_status_t>, pub stop: ::std::option::Option<unsafe extern "C" fn() -> pj_status_t>, pub unload: ::std::option::Option<unsafe extern "C" fn() -> pj_status_t>, pub on_rx_request: ::std::option::Option<unsafe extern "C" fn(rdata: *mut pjsip_rx_data) -> pj_bool_t>, pub on_rx_response: ::std::option::Option<unsafe extern "C" fn(rdata: *mut pjsip_rx_data) -> pj_bool_t>, pub on_tx_request: ::std::option::Option<unsafe extern "C" fn(tdata: *mut pjsip_tx_data) -> pj_status_t>, pub on_tx_response: ::std::option::Option<unsafe extern "C" fn(tdata: *mut pjsip_tx_data) -> pj_status_t>, pub on_tsx_state: ::std::option::Option<unsafe extern "C" fn(tsx: *mut pjsip_transaction, event: *mut pjsip_event)> }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsip_module_priority { PJSIP_MOD_PRIORITY_TRANSPORT_LAYER = 8, PJSIP_MOD_PRIORITY_TSX_LAYER = 16, PJSIP_MOD_PRIORITY_UA_PROXY_LAYER = 32, PJSIP_MOD_PRIORITY_DIALOG_USAGE = 48, PJSIP_MOD_PRIORITY_APPLICATION = 64 }

extern "C" {
    #[link_name = "\u{1}PJ_AF_UNSPEC"]
    pub static mut PJ_AF_UNSPEC: pj_uint16_t;
}

extern "C" {
    #[link_name = "\u{1}PJ_AF_UNIX"]
    pub static mut PJ_AF_UNIX: pj_uint16_t;
}

extern "C" {
    #[link_name = "\u{1}PJ_AF_INET"]
    pub static mut PJ_AF_INET: pj_uint16_t;
}

extern "C" {
    #[link_name = "\u{1}PJ_AF_INET6"]
    pub static mut PJ_AF_INET6: pj_uint16_t;
}

extern "C" {
    #[link_name = "\u{1}PJ_AF_PACKET"]
    pub static mut PJ_AF_PACKET: pj_uint16_t;
}

extern "C" {
    #[link_name = "\u{1}PJ_AF_IRDA"]
    pub static mut PJ_AF_IRDA: pj_uint16_t;
}

extern "C" {
    #[link_name = "\u{1}PJ_SOCK_STREAM"]
    pub static mut PJ_SOCK_STREAM: pj_uint16_t;
}

extern "C" {
    #[link_name = "\u{1}PJ_SOCK_DGRAM"]
    pub static mut PJ_SOCK_DGRAM: pj_uint16_t;
}

extern "C" {
    #[link_name = "\u{1}PJ_SOCK_RAW"]
    pub static mut PJ_SOCK_RAW: pj_uint16_t;
}

extern "C" {
    #[link_name = "\u{1}PJ_SOCK_RDM"]
    pub static mut PJ_SOCK_RDM: pj_uint16_t;
}

extern "C" {
    #[link_name = "\u{1}PJ_SOL_SOCKET"]
    pub static mut PJ_SOL_SOCKET: pj_uint16_t;
}

extern "C" {
    #[link_name = "\u{1}PJ_SOL_IP"]
    pub static mut PJ_SOL_IP: pj_uint16_t;
}

extern "C" {
    #[link_name = "\u{1}PJ_SOL_TCP"]
    pub static mut PJ_SOL_TCP: pj_uint16_t;
}

extern "C" {
    #[link_name = "\u{1}PJ_SOL_UDP"]
    pub static mut PJ_SOL_UDP: pj_uint16_t;
}

extern "C" {
    #[link_name = "\u{1}PJ_SOL_IPV6"]
    pub static mut PJ_SOL_IPV6: pj_uint16_t;
}

extern "C" {
    #[link_name = "\u{1}PJ_IP_TOS"]
    pub static mut PJ_IP_TOS: pj_uint16_t;
}

extern "C" {
    #[link_name = "\u{1}PJ_IPTOS_LOWDELAY"]
    pub static mut PJ_IPTOS_LOWDELAY: pj_uint16_t;
}

extern "C" {
    #[link_name = "\u{1}PJ_IPTOS_THROUGHPUT"]
    pub static mut PJ_IPTOS_THROUGHPUT: pj_uint16_t;
}

extern "C" {
    #[link_name = "\u{1}PJ_IPTOS_RELIABILITY"]
    pub static mut PJ_IPTOS_RELIABILITY: pj_uint16_t;
}

extern "C" {
    #[link_name = "\u{1}PJ_IPTOS_MINCOST"]
    pub static mut PJ_IPTOS_MINCOST: pj_uint16_t;
}

extern "C" {
    #[link_name = "\u{1}PJ_IPV6_TCLASS"]
    pub static mut PJ_IPV6_TCLASS: pj_uint16_t;
}

extern "C" {
    #[link_name = "\u{1}PJ_SO_TYPE"]
    pub static mut PJ_SO_TYPE: pj_uint16_t;
}

extern "C" {
    #[link_name = "\u{1}PJ_SO_RCVBUF"]
    pub static mut PJ_SO_RCVBUF: pj_uint16_t;
}

extern "C" {
    #[link_name = "\u{1}PJ_SO_SNDBUF"]
    pub static mut PJ_SO_SNDBUF: pj_uint16_t;
}

extern "C" {
    #[link_name = "\u{1}PJ_TCP_NODELAY"]
    pub static mut PJ_TCP_NODELAY: pj_uint16_t;
}

extern "C" {
    #[link_name = "\u{1}PJ_SO_REUSEADDR"]
    pub static mut PJ_SO_REUSEADDR: pj_uint16_t;
}

extern "C" {
    #[link_name = "\u{1}PJ_SO_NOSIGPIPE"]
    pub static mut PJ_SO_NOSIGPIPE: pj_uint16_t;
}

extern "C" {
    #[link_name = "\u{1}PJ_SO_PRIORITY"]
    pub static mut PJ_SO_PRIORITY: pj_uint16_t;
}

extern "C" {
    #[link_name = "\u{1}PJ_IP_MULTICAST_IF"]
    pub static mut PJ_IP_MULTICAST_IF: pj_uint16_t;
}

extern "C" {
    #[link_name = "\u{1}PJ_IP_MULTICAST_TTL"]
    pub static mut PJ_IP_MULTICAST_TTL: pj_uint16_t;
}

extern "C" {
    #[link_name = "\u{1}PJ_IP_MULTICAST_LOOP"]
    pub static mut PJ_IP_MULTICAST_LOOP: pj_uint16_t;
}

extern "C" {
    #[link_name = "\u{1}PJ_IP_ADD_MEMBERSHIP"]
    pub static mut PJ_IP_ADD_MEMBERSHIP: pj_uint16_t;
}

extern "C" {
    #[link_name = "\u{1}PJ_IP_DROP_MEMBERSHIP"]
    pub static mut PJ_IP_DROP_MEMBERSHIP: pj_uint16_t;
}

extern "C" {
    #[link_name = "\u{1}PJ_MSG_OOB"]
    pub static mut PJ_MSG_OOB: ::std::os::raw::c_int;
}

extern "C" {
    #[link_name = "\u{1}PJ_MSG_PEEK"]
    pub static mut PJ_MSG_PEEK: ::std::os::raw::c_int;
}

extern "C" {
    #[link_name = "\u{1}PJ_MSG_DONTROUTE"]
    pub static mut PJ_MSG_DONTROUTE: ::std::os::raw::c_int;
}

impl pj_socket_sd_type { pub const PJ_SHUT_RD: pj_socket_sd_type = pj_socket_sd_type::PJ_SD_RECEIVE; }

impl pj_socket_sd_type { pub const PJ_SHUT_WR: pj_socket_sd_type = pj_socket_sd_type::PJ_SD_SEND; }

impl pj_socket_sd_type { pub const PJ_SHUT_RDWR: pj_socket_sd_type = pj_socket_sd_type::PJ_SD_BOTH; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_socket_sd_type { PJ_SD_RECEIVE = 0, PJ_SD_SEND = 1, PJ_SD_BOTH = 2 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_in_addr { pub s_addr: pj_uint32_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_sockaddr_in { pub sin_family: pj_uint16_t, pub sin_port: pj_uint16_t, pub sin_addr: pj_in_addr, pub sin_zero: [::std::os::raw::c_char; 8usize] }

#[repr(C)]
#[derive(Copy, Clone)]
pub union pj_in6_addr { pub s6_addr: [pj_uint8_t; 16usize], pub u6_addr32: [pj_uint32_t; 4usize], _bindgen_union_align: [u32; 4usize] }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pj_sockaddr_in6 { pub sin6_family: pj_uint16_t, pub sin6_port: pj_uint16_t, pub sin6_flowinfo: pj_uint32_t, pub sin6_addr: pj_in6_addr, pub sin6_scope_id: pj_uint32_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_addr_hdr { pub sa_family: pj_uint16_t }

#[repr(C)]
#[derive(Copy, Clone)]
pub union pj_sockaddr { pub addr: pj_addr_hdr, pub ipv4: pj_sockaddr_in, pub ipv6: pj_sockaddr_in6, _bindgen_union_align: [u32; 7usize] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_ip_mreq { pub imr_multiaddr: pj_in_addr, pub imr_interface: pj_in_addr }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_sockopt_params { pub cnt: ::std::os::raw::c_uint, pub options: [pj_sockopt_params__bindgen_ty_1; 4usize] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_sockopt_params__bindgen_ty_1 { pub level: ::std::os::raw::c_int, pub optname: ::std::os::raw::c_int, pub optval: *mut ::std::os::raw::c_void, pub optlen: ::std::os::raw::c_int }

extern "C" { pub fn pj_ntohs(netshort: pj_uint16_t) -> pj_uint16_t; }

extern "C" { pub fn pj_htons(hostshort: pj_uint16_t) -> pj_uint16_t; }

extern "C" { pub fn pj_ntohl(netlong: pj_uint32_t) -> pj_uint32_t; }

extern "C" { pub fn pj_htonl(hostlong: pj_uint32_t) -> pj_uint32_t; }

extern "C" { pub fn pj_inet_ntoa(inaddr: pj_in_addr) -> *mut ::std::os::raw::c_char; }

extern "C" { pub fn pj_inet_aton(cp: *const pj_str_t, inp: *mut pj_in_addr) -> ::std::os::raw::c_int; }

extern "C" { pub fn pj_inet_pton(af: ::std::os::raw::c_int, src: *const pj_str_t, dst: *mut ::std::os::raw::c_void) -> pj_status_t; }

extern "C" { pub fn pj_inet_ntop(af: ::std::os::raw::c_int, src: *const ::std::os::raw::c_void, dst: *mut ::std::os::raw::c_char, size: ::std::os::raw::c_int) -> pj_status_t; }

extern "C" { pub fn pj_inet_ntop2(af: ::std::os::raw::c_int, src: *const ::std::os::raw::c_void, dst: *mut ::std::os::raw::c_char, size: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char; }

extern "C" { pub fn pj_sockaddr_print(addr: *const pj_sockaddr_t, buf: *mut ::std::os::raw::c_char, size: ::std::os::raw::c_int, flags: ::std::os::raw::c_uint) -> *mut ::std::os::raw::c_char; }

extern "C" { pub fn pj_inet_addr(cp: *const pj_str_t) -> pj_in_addr; }

extern "C" { pub fn pj_inet_addr2(cp: *const ::std::os::raw::c_char) -> pj_in_addr; }

extern "C" { pub fn pj_sockaddr_in_init(addr: *mut pj_sockaddr_in, cp: *const pj_str_t, port: pj_uint16_t) -> pj_status_t; }

extern "C" { pub fn pj_sockaddr_init(af: ::std::os::raw::c_int, addr: *mut pj_sockaddr, cp: *const pj_str_t, port: pj_uint16_t) -> pj_status_t; }

extern "C" { pub fn pj_sockaddr_cmp(addr1: *const pj_sockaddr_t, addr2: *const pj_sockaddr_t) -> ::std::os::raw::c_int; }

extern "C" { pub fn pj_sockaddr_get_addr(addr: *const pj_sockaddr_t) -> *mut ::std::os::raw::c_void; }

extern "C" { pub fn pj_sockaddr_has_addr(addr: *const pj_sockaddr_t) -> pj_bool_t; }

extern "C" { pub fn pj_sockaddr_get_addr_len(addr: *const pj_sockaddr_t) -> ::std::os::raw::c_uint; }

extern "C" { pub fn pj_sockaddr_get_len(addr: *const pj_sockaddr_t) -> ::std::os::raw::c_uint; }

extern "C" { pub fn pj_sockaddr_copy_addr(dst: *mut pj_sockaddr, src: *const pj_sockaddr); }

extern "C" { pub fn pj_sockaddr_cp(dst: *mut pj_sockaddr_t, src: *const pj_sockaddr_t); }

extern "C" { pub fn pj_sockaddr_synthesize(dst_af: ::std::os::raw::c_int, dst: *mut pj_sockaddr_t, src: *const pj_sockaddr_t) -> pj_status_t; }

extern "C" { pub fn pj_sockaddr_in_get_addr(addr: *const pj_sockaddr_in) -> pj_in_addr; }

extern "C" { pub fn pj_sockaddr_in_set_addr(addr: *mut pj_sockaddr_in, hostaddr: pj_uint32_t); }

extern "C" { pub fn pj_sockaddr_in_set_str_addr(addr: *mut pj_sockaddr_in, cp: *const pj_str_t) -> pj_status_t; }

extern "C" { pub fn pj_sockaddr_set_str_addr(af: ::std::os::raw::c_int, addr: *mut pj_sockaddr, cp: *const pj_str_t) -> pj_status_t; }

extern "C" { pub fn pj_sockaddr_get_port(addr: *const pj_sockaddr_t) -> pj_uint16_t; }

extern "C" { pub fn pj_sockaddr_in_get_port(addr: *const pj_sockaddr_in) -> pj_uint16_t; }

extern "C" { pub fn pj_sockaddr_set_port(addr: *mut pj_sockaddr, hostport: pj_uint16_t) -> pj_status_t; }

extern "C" { pub fn pj_sockaddr_in_set_port(addr: *mut pj_sockaddr_in, hostport: pj_uint16_t); }

extern "C" { pub fn pj_sockaddr_parse(af: ::std::os::raw::c_int, options: ::std::os::raw::c_uint, str: *const pj_str_t, addr: *mut pj_sockaddr) -> pj_status_t; }

extern "C" { pub fn pj_sockaddr_parse2(af: ::std::os::raw::c_int, options: ::std::os::raw::c_uint, str: *const pj_str_t, hostpart: *mut pj_str_t, port: *mut pj_uint16_t, raf: *mut ::std::os::raw::c_int) -> pj_status_t; }

extern "C" { pub fn pj_gethostname() -> *const pj_str_t; }

extern "C" { pub fn pj_gethostaddr() -> pj_in_addr; }

extern "C" { pub fn pj_sock_socket(family: ::std::os::raw::c_int, type_: ::std::os::raw::c_int, protocol: ::std::os::raw::c_int, sock: *mut pj_sock_t) -> pj_status_t; }

extern "C" { pub fn pj_sock_close(sockfd: pj_sock_t) -> pj_status_t; }

extern "C" { pub fn pj_sock_bind(sockfd: pj_sock_t, my_addr: *const pj_sockaddr_t, addrlen: ::std::os::raw::c_int) -> pj_status_t; }

extern "C" { pub fn pj_sock_bind_in(sockfd: pj_sock_t, addr: pj_uint32_t, port: pj_uint16_t) -> pj_status_t; }

extern "C" { pub fn pj_sock_bind_random(sockfd: pj_sock_t, addr: *const pj_sockaddr_t, port_range: pj_uint16_t, max_try: pj_uint16_t) -> pj_status_t; }

extern "C" { pub fn pj_sock_listen(sockfd: pj_sock_t, backlog: ::std::os::raw::c_int) -> pj_status_t; }

extern "C" { pub fn pj_sock_accept(serverfd: pj_sock_t, newsock: *mut pj_sock_t, addr: *mut pj_sockaddr_t, addrlen: *mut ::std::os::raw::c_int) -> pj_status_t; }

extern "C" { pub fn pj_sock_connect(sockfd: pj_sock_t, serv_addr: *const pj_sockaddr_t, addrlen: ::std::os::raw::c_int) -> pj_status_t; }

extern "C" { pub fn pj_sock_getpeername(sockfd: pj_sock_t, addr: *mut pj_sockaddr_t, namelen: *mut ::std::os::raw::c_int) -> pj_status_t; }

extern "C" { pub fn pj_sock_getsockname(sockfd: pj_sock_t, addr: *mut pj_sockaddr_t, namelen: *mut ::std::os::raw::c_int) -> pj_status_t; }

extern "C" { pub fn pj_sock_getsockopt(sockfd: pj_sock_t, level: pj_uint16_t, optname: pj_uint16_t, optval: *mut ::std::os::raw::c_void, optlen: *mut ::std::os::raw::c_int) -> pj_status_t; }

extern "C" { pub fn pj_sock_setsockopt(sockfd: pj_sock_t, level: pj_uint16_t, optname: pj_uint16_t, optval: *const ::std::os::raw::c_void, optlen: ::std::os::raw::c_int) -> pj_status_t; }

extern "C" { pub fn pj_sock_setsockopt_params(sockfd: pj_sock_t, params: *const pj_sockopt_params) -> pj_status_t; }

extern "C" { pub fn pj_sock_setsockopt_sobuf(sockfd: pj_sock_t, optname: pj_uint16_t, auto_retry: pj_bool_t, buf_size: *mut ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pj_sock_recv(sockfd: pj_sock_t, buf: *mut ::std::os::raw::c_void, len: *mut pj_ssize_t, flags: ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pj_sock_recvfrom(sockfd: pj_sock_t, buf: *mut ::std::os::raw::c_void, len: *mut pj_ssize_t, flags: ::std::os::raw::c_uint, from: *mut pj_sockaddr_t, fromlen: *mut ::std::os::raw::c_int) -> pj_status_t; }

extern "C" { pub fn pj_sock_send(sockfd: pj_sock_t, buf: *const ::std::os::raw::c_void, len: *mut pj_ssize_t, flags: ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pj_sock_sendto(sockfd: pj_sock_t, buf: *const ::std::os::raw::c_void, len: *mut pj_ssize_t, flags: ::std::os::raw::c_uint, to: *const pj_sockaddr_t, tolen: ::std::os::raw::c_int) -> pj_status_t; }

extern "C" { pub fn pj_sock_shutdown(sockfd: pj_sock_t, how: ::std::os::raw::c_int) -> pj_status_t; }

pub const PJ_DNS_CLASS_IN: _bindgen_ty_5 = _bindgen_ty_5::PJ_DNS_CLASS_IN;

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_5 { PJ_DNS_CLASS_IN = 1 }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_dns_type { PJ_DNS_TYPE_A = 1, PJ_DNS_TYPE_NS = 2, PJ_DNS_TYPE_MD = 3, PJ_DNS_TYPE_MF = 4, PJ_DNS_TYPE_CNAME = 5, PJ_DNS_TYPE_SOA = 6, PJ_DNS_TYPE_MB = 7, PJ_DNS_TYPE_MG = 8, PJ_DNS_TYPE_MR = 9, PJ_DNS_TYPE_NULL = 10, PJ_DNS_TYPE_WKS = 11, PJ_DNS_TYPE_PTR = 12, PJ_DNS_TYPE_HINFO = 13, PJ_DNS_TYPE_MINFO = 14, PJ_DNS_TYPE_MX = 15, PJ_DNS_TYPE_TXT = 16, PJ_DNS_TYPE_RP = 17, PJ_DNS_TYPE_AFSB = 18, PJ_DNS_TYPE_X25 = 19, PJ_DNS_TYPE_ISDN = 20, PJ_DNS_TYPE_RT = 21, PJ_DNS_TYPE_NSAP = 22, PJ_DNS_TYPE_NSAP_PTR = 23, PJ_DNS_TYPE_SIG = 24, PJ_DNS_TYPE_KEY = 25, PJ_DNS_TYPE_PX = 26, PJ_DNS_TYPE_GPOS = 27, PJ_DNS_TYPE_AAAA = 28, PJ_DNS_TYPE_LOC = 29, PJ_DNS_TYPE_NXT = 30, PJ_DNS_TYPE_EID = 31, PJ_DNS_TYPE_NIMLOC = 32, PJ_DNS_TYPE_SRV = 33, PJ_DNS_TYPE_ATMA = 34, PJ_DNS_TYPE_NAPTR = 35, PJ_DNS_TYPE_KX = 36, PJ_DNS_TYPE_CERT = 37, PJ_DNS_TYPE_A6 = 38, PJ_DNS_TYPE_DNAME = 39, PJ_DNS_TYPE_OPT = 41, PJ_DNS_TYPE_APL = 42, PJ_DNS_TYPE_DS = 43, PJ_DNS_TYPE_SSHFP = 44, PJ_DNS_TYPE_IPSECKEY = 45, PJ_DNS_TYPE_RRSIG = 46, PJ_DNS_TYPE_NSEC = 47, PJ_DNS_TYPE_DNSKEY = 48 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_dns_hdr { pub id: pj_uint16_t, pub flags: pj_uint16_t, pub qdcount: pj_uint16_t, pub anscount: pj_uint16_t, pub nscount: pj_uint16_t, pub arcount: pj_uint16_t }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_dns_rcode { PJ_DNS_RCODE_FORMERR = 1, PJ_DNS_RCODE_SERVFAIL = 2, PJ_DNS_RCODE_NXDOMAIN = 3, PJ_DNS_RCODE_NOTIMPL = 4, PJ_DNS_RCODE_REFUSED = 5, PJ_DNS_RCODE_YXDOMAIN = 6, PJ_DNS_RCODE_YXRRSET = 7, PJ_DNS_RCODE_NXRRSET = 8, PJ_DNS_RCODE_NOTAUTH = 9, PJ_DNS_RCODE_NOTZONE = 10 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_dns_parsed_query { pub name: pj_str_t, pub type_: pj_uint16_t, pub dnsclass: pj_uint16_t }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pj_dns_parsed_rr { pub name: pj_str_t, pub type_: pj_uint16_t, pub dnsclass: pj_uint16_t, pub ttl: pj_uint32_t, pub rdlength: pj_uint16_t, pub data: *mut ::std::os::raw::c_void, pub rdata: pj_dns_parsed_rr_rdata }

#[repr(C)]
#[derive(Copy, Clone)]
pub union pj_dns_parsed_rr_rdata { pub srv: pj_dns_parsed_rr_rdata_srv, pub cname: pj_dns_parsed_rr_rdata_cname, pub ns: pj_dns_parsed_rr_rdata_ns, pub ptr: pj_dns_parsed_rr_rdata_ptr, pub a: pj_dns_parsed_rr_rdata_a, pub aaaa: pj_dns_parsed_rr_rdata_aaaa, _bindgen_union_align: [u32; 4usize] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_dns_parsed_rr_rdata_srv { pub prio: pj_uint16_t, pub weight: pj_uint16_t, pub port: pj_uint16_t, pub target: pj_str_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_dns_parsed_rr_rdata_cname { pub name: pj_str_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_dns_parsed_rr_rdata_ns { pub name: pj_str_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_dns_parsed_rr_rdata_ptr { pub name: pj_str_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_dns_parsed_rr_rdata_a { pub ip_addr: pj_in_addr }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pj_dns_parsed_rr_rdata_aaaa { pub ip_addr: pj_in6_addr }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_dns_parsed_packet { pub hdr: pj_dns_hdr, pub q: *mut pj_dns_parsed_query, pub ans: *mut pj_dns_parsed_rr, pub ns: *mut pj_dns_parsed_rr, pub arr: *mut pj_dns_parsed_rr }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_dns_dup_options { PJ_DNS_NO_QD = 1, PJ_DNS_NO_ANS = 2, PJ_DNS_NO_NS = 4, PJ_DNS_NO_AR = 8 }

extern "C" { pub fn pj_dns_make_query(packet: *mut ::std::os::raw::c_void, size: *mut ::std::os::raw::c_uint, id: pj_uint16_t, qtype: ::std::os::raw::c_int, name: *const pj_str_t) -> pj_status_t; }

extern "C" { pub fn pj_dns_parse_packet(pool: *mut pj_pool_t, packet: *const ::std::os::raw::c_void, size: ::std::os::raw::c_uint, p_res: *mut *mut pj_dns_parsed_packet) -> pj_status_t; }

extern "C" { pub fn pj_dns_packet_dup(pool: *mut pj_pool_t, p: *const pj_dns_parsed_packet, options: ::std::os::raw::c_uint, p_dst: *mut *mut pj_dns_parsed_packet); }

extern "C" { pub fn pj_dns_get_type_name(type_: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char; }

extern "C" { pub fn pj_dns_init_srv_rr(rec: *mut pj_dns_parsed_rr, res_name: *const pj_str_t, dnsclass: ::std::os::raw::c_uint, ttl: ::std::os::raw::c_uint, prio: ::std::os::raw::c_uint, weight: ::std::os::raw::c_uint, port: ::std::os::raw::c_uint, target: *const pj_str_t); }

extern "C" { pub fn pj_dns_init_cname_rr(rec: *mut pj_dns_parsed_rr, res_name: *const pj_str_t, dnsclass: ::std::os::raw::c_uint, ttl: ::std::os::raw::c_uint, name: *const pj_str_t); }

extern "C" { pub fn pj_dns_init_a_rr(rec: *mut pj_dns_parsed_rr, res_name: *const pj_str_t, dnsclass: ::std::os::raw::c_uint, ttl: ::std::os::raw::c_uint, ip_addr: *const pj_in_addr); }

extern "C" { pub fn pj_dns_init_aaaa_rr(rec: *mut pj_dns_parsed_rr, res_name: *const pj_str_t, dnsclass: ::std::os::raw::c_uint, ttl: ::std::os::raw::c_uint, ip_addr: *const pj_in6_addr); }

extern "C" { pub fn pj_dns_dump_packet(res: *const pj_dns_parsed_packet); }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_dns_resolver { _unused: [u8; 0] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_dns_async_query { _unused: [u8; 0] }

pub type pj_dns_callback = ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, status: pj_status_t, response: *mut pj_dns_parsed_packet)>;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_dns_settings { pub options: ::std::os::raw::c_uint, pub qretr_delay: ::std::os::raw::c_uint, pub qretr_count: ::std::os::raw::c_uint, pub cache_max_ttl: ::std::os::raw::c_uint, pub good_ns_ttl: ::std::os::raw::c_uint, pub bad_ns_ttl: ::std::os::raw::c_uint }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pj_dns_a_record { pub name: pj_str_t, pub alias: pj_str_t, pub addr_count: ::std::os::raw::c_uint, pub addr: [pj_in_addr; 8usize], pub buf_: [::std::os::raw::c_char; 128usize] }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pj_dns_addr_record { pub name: pj_str_t, pub alias: pj_str_t, pub addr_count: ::std::os::raw::c_uint, pub addr: [pj_dns_addr_record__bindgen_ty_1; 8usize], pub buf_: [::std::os::raw::c_char; 128usize] }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pj_dns_addr_record__bindgen_ty_1 { pub af: ::std::os::raw::c_int, pub ip: pj_dns_addr_record__bindgen_ty_1__bindgen_ty_1 }

#[repr(C)]
#[derive(Copy, Clone)]
pub union pj_dns_addr_record__bindgen_ty_1__bindgen_ty_1 { pub v4: pj_in_addr, pub v6: pj_in6_addr, _bindgen_union_align: [u32; 4usize] }

extern "C" { pub fn pj_dns_settings_default(s: *mut pj_dns_settings); }

extern "C" { pub fn pj_dns_resolver_create(pf: *mut pj_pool_factory, name: *const ::std::os::raw::c_char, options: ::std::os::raw::c_uint, timer: *mut pj_timer_heap_t, ioqueue: *mut pj_ioqueue_t, p_resolver: *mut *mut pj_dns_resolver) -> pj_status_t; }

extern "C" { pub fn pj_dns_resolver_set_ns(resolver: *mut pj_dns_resolver, count: ::std::os::raw::c_uint, servers: *const pj_str_t, ports: *const pj_uint16_t) -> pj_status_t; }

extern "C" { pub fn pj_dns_resolver_get_settings(resolver: *mut pj_dns_resolver, st: *mut pj_dns_settings) -> pj_status_t; }

extern "C" { pub fn pj_dns_resolver_set_settings(resolver: *mut pj_dns_resolver, st: *const pj_dns_settings) -> pj_status_t; }

extern "C" { pub fn pj_dns_resolver_handle_events(resolver: *mut pj_dns_resolver, timeout: *const pj_time_val); }

extern "C" { pub fn pj_dns_resolver_destroy(resolver: *mut pj_dns_resolver, notify: pj_bool_t) -> pj_status_t; }

extern "C" { pub fn pj_dns_resolver_start_query(resolver: *mut pj_dns_resolver, name: *const pj_str_t, type_: ::std::os::raw::c_int, options: ::std::os::raw::c_uint, cb: pj_dns_callback, user_data: *mut ::std::os::raw::c_void, p_query: *mut *mut pj_dns_async_query) -> pj_status_t; }

extern "C" { pub fn pj_dns_resolver_cancel_query(query: *mut pj_dns_async_query, notify: pj_bool_t) -> pj_status_t; }

extern "C" { pub fn pj_dns_parse_a_response(pkt: *const pj_dns_parsed_packet, rec: *mut pj_dns_a_record) -> pj_status_t; }

extern "C" { pub fn pj_dns_parse_addr_response(pkt: *const pj_dns_parsed_packet, rec: *mut pj_dns_addr_record) -> pj_status_t; }

extern "C" { pub fn pj_dns_resolver_add_entry(resolver: *mut pj_dns_resolver, pkt: *const pj_dns_parsed_packet, set_ttl: pj_bool_t) -> pj_status_t; }

extern "C" { pub fn pj_dns_resolver_get_cached_count(resolver: *mut pj_dns_resolver) -> ::std::os::raw::c_uint; }

extern "C" { pub fn pj_dns_resolver_dump(resolver: *mut pj_dns_resolver, detail: pj_bool_t); }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsip_server_addresses { pub count: ::std::os::raw::c_uint, pub entry: [pjsip_server_addresses__bindgen_ty_1; 8usize] }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsip_server_addresses__bindgen_ty_1 { pub type_: pjsip_transport_type_e, pub priority: ::std::os::raw::c_uint, pub weight: ::std::os::raw::c_uint, pub addr: pj_sockaddr, pub addr_len: ::std::os::raw::c_int }

pub type pjsip_resolver_callback = ::std::option::Option<unsafe extern "C" fn(status: pj_status_t, token: *mut ::std::os::raw::c_void, addr: *const pjsip_server_addresses)>;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_ext_resolver { pub resolve: ::std::option::Option<unsafe extern "C" fn(resolver: *mut pjsip_resolver_t, pool: *mut pj_pool_t, target: *const pjsip_host_info, token: *mut ::std::os::raw::c_void, cb: pjsip_resolver_callback)> }

extern "C" { pub fn pjsip_resolver_create(pool: *mut pj_pool_t, p_res: *mut *mut pjsip_resolver_t) -> pj_status_t; }

extern "C" { pub fn pjsip_resolver_set_resolver(res: *mut pjsip_resolver_t, dns_res: *mut pj_dns_resolver) -> pj_status_t; }

extern "C" { pub fn pjsip_resolver_set_ext_resolver(res: *mut pjsip_resolver_t, ext_res: *mut pjsip_ext_resolver) -> pj_status_t; }

extern "C" { pub fn pjsip_resolver_get_resolver(res: *mut pjsip_resolver_t) -> *mut pj_dns_resolver; }

extern "C" { pub fn pjsip_resolver_destroy(resolver: *mut pjsip_resolver_t); }

extern "C" { pub fn pjsip_resolve(resolver: *mut pjsip_resolver_t, pool: *mut pj_pool_t, target: *const pjsip_host_info, token: *mut ::std::os::raw::c_void, cb: pjsip_resolver_callback); }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_ioqueue_op_key_t { pub internal__: [*mut ::std::os::raw::c_void; 32usize], pub activesock_data: *mut ::std::os::raw::c_void, pub user_data: *mut ::std::os::raw::c_void }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_ioqueue_callback { pub on_read_complete: ::std::option::Option<unsafe extern "C" fn(key: *mut pj_ioqueue_key_t, op_key: *mut pj_ioqueue_op_key_t, bytes_read: pj_ssize_t)>, pub on_write_complete: ::std::option::Option<unsafe extern "C" fn(key: *mut pj_ioqueue_key_t, op_key: *mut pj_ioqueue_op_key_t, bytes_sent: pj_ssize_t)>, pub on_accept_complete: ::std::option::Option<unsafe extern "C" fn(key: *mut pj_ioqueue_key_t, op_key: *mut pj_ioqueue_op_key_t, sock: pj_sock_t, status: pj_status_t)>, pub on_connect_complete: ::std::option::Option<unsafe extern "C" fn(key: *mut pj_ioqueue_key_t, status: pj_status_t)> }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_ioqueue_operation_e { PJ_IOQUEUE_OP_NONE = 0, PJ_IOQUEUE_OP_READ = 1, PJ_IOQUEUE_OP_RECV = 2, PJ_IOQUEUE_OP_RECV_FROM = 4, PJ_IOQUEUE_OP_WRITE = 8, PJ_IOQUEUE_OP_SEND = 16, PJ_IOQUEUE_OP_SEND_TO = 32, PJ_IOQUEUE_OP_ACCEPT = 64, PJ_IOQUEUE_OP_CONNECT = 128 }

extern "C" { pub fn pj_ioqueue_name() -> *const ::std::os::raw::c_char; }

extern "C" { pub fn pj_ioqueue_create(pool: *mut pj_pool_t, max_fd: pj_size_t, ioqueue: *mut *mut pj_ioqueue_t) -> pj_status_t; }

extern "C" { pub fn pj_ioqueue_destroy(ioque: *mut pj_ioqueue_t) -> pj_status_t; }

extern "C" { pub fn pj_ioqueue_set_lock(ioque: *mut pj_ioqueue_t, lock: *mut pj_lock_t, auto_delete: pj_bool_t) -> pj_status_t; }

extern "C" { pub fn pj_ioqueue_set_default_concurrency(ioqueue: *mut pj_ioqueue_t, allow: pj_bool_t) -> pj_status_t; }

extern "C" { pub fn pj_ioqueue_register_sock(pool: *mut pj_pool_t, ioque: *mut pj_ioqueue_t, sock: pj_sock_t, user_data: *mut ::std::os::raw::c_void, cb: *const pj_ioqueue_callback, key: *mut *mut pj_ioqueue_key_t) -> pj_status_t; }

extern "C" { pub fn pj_ioqueue_register_sock2(pool: *mut pj_pool_t, ioque: *mut pj_ioqueue_t, sock: pj_sock_t, grp_lock: *mut pj_grp_lock_t, user_data: *mut ::std::os::raw::c_void, cb: *const pj_ioqueue_callback, key: *mut *mut pj_ioqueue_key_t) -> pj_status_t; }

extern "C" { pub fn pj_ioqueue_unregister(key: *mut pj_ioqueue_key_t) -> pj_status_t; }

extern "C" { pub fn pj_ioqueue_get_user_data(key: *mut pj_ioqueue_key_t) -> *mut ::std::os::raw::c_void; }

extern "C" { pub fn pj_ioqueue_set_user_data(key: *mut pj_ioqueue_key_t, user_data: *mut ::std::os::raw::c_void, old_data: *mut *mut ::std::os::raw::c_void) -> pj_status_t; }

extern "C" { pub fn pj_ioqueue_set_concurrency(key: *mut pj_ioqueue_key_t, allow: pj_bool_t) -> pj_status_t; }

extern "C" { pub fn pj_ioqueue_lock_key(key: *mut pj_ioqueue_key_t) -> pj_status_t; }

extern "C" { pub fn pj_ioqueue_trylock_key(key: *mut pj_ioqueue_key_t) -> pj_status_t; }

extern "C" { pub fn pj_ioqueue_unlock_key(key: *mut pj_ioqueue_key_t) -> pj_status_t; }

extern "C" { pub fn pj_ioqueue_op_key_init(op_key: *mut pj_ioqueue_op_key_t, size: pj_size_t); }

extern "C" { pub fn pj_ioqueue_is_pending(key: *mut pj_ioqueue_key_t, op_key: *mut pj_ioqueue_op_key_t) -> pj_bool_t; }

extern "C" { pub fn pj_ioqueue_post_completion(key: *mut pj_ioqueue_key_t, op_key: *mut pj_ioqueue_op_key_t, bytes_status: pj_ssize_t) -> pj_status_t; }

extern "C" { pub fn pj_ioqueue_accept(key: *mut pj_ioqueue_key_t, op_key: *mut pj_ioqueue_op_key_t, new_sock: *mut pj_sock_t, local: *mut pj_sockaddr_t, remote: *mut pj_sockaddr_t, addrlen: *mut ::std::os::raw::c_int) -> pj_status_t; }

extern "C" { pub fn pj_ioqueue_connect(key: *mut pj_ioqueue_key_t, addr: *const pj_sockaddr_t, addrlen: ::std::os::raw::c_int) -> pj_status_t; }

extern "C" { pub fn pj_ioqueue_poll(ioque: *mut pj_ioqueue_t, timeout: *const pj_time_val) -> ::std::os::raw::c_int; }

extern "C" { pub fn pj_ioqueue_recv(key: *mut pj_ioqueue_key_t, op_key: *mut pj_ioqueue_op_key_t, buffer: *mut ::std::os::raw::c_void, length: *mut pj_ssize_t, flags: pj_uint32_t) -> pj_status_t; }

extern "C" { pub fn pj_ioqueue_recvfrom(key: *mut pj_ioqueue_key_t, op_key: *mut pj_ioqueue_op_key_t, buffer: *mut ::std::os::raw::c_void, length: *mut pj_ssize_t, flags: pj_uint32_t, addr: *mut pj_sockaddr_t, addrlen: *mut ::std::os::raw::c_int) -> pj_status_t; }

extern "C" { pub fn pj_ioqueue_send(key: *mut pj_ioqueue_key_t, op_key: *mut pj_ioqueue_op_key_t, data: *const ::std::os::raw::c_void, length: *mut pj_ssize_t, flags: pj_uint32_t) -> pj_status_t; }

extern "C" { pub fn pj_ioqueue_sendto(key: *mut pj_ioqueue_key_t, op_key: *mut pj_ioqueue_op_key_t, data: *const ::std::os::raw::c_void, length: *mut pj_ssize_t, flags: pj_uint32_t, addr: *const pj_sockaddr_t, addrlen: ::std::os::raw::c_int) -> pj_status_t; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsip_transport_flags_e { PJSIP_TRANSPORT_RELIABLE = 1, PJSIP_TRANSPORT_SECURE = 2, PJSIP_TRANSPORT_DATAGRAM = 4 }

extern "C" { pub fn pjsip_transport_register_type(tp_flag: ::std::os::raw::c_uint, tp_name: *const ::std::os::raw::c_char, def_port: ::std::os::raw::c_int, p_tp_type: *mut ::std::os::raw::c_int) -> pj_status_t; }

extern "C" { pub fn pjsip_transport_get_type_from_name(name: *const pj_str_t) -> pjsip_transport_type_e; }

extern "C" { pub fn pjsip_transport_get_type_from_flag(flag: ::std::os::raw::c_uint) -> pjsip_transport_type_e; }

extern "C" { pub fn pjsip_transport_type_get_af(type_: pjsip_transport_type_e) -> ::std::os::raw::c_int; }

extern "C" { pub fn pjsip_transport_get_flag_from_type(type_: pjsip_transport_type_e) -> ::std::os::raw::c_uint; }

extern "C" { pub fn pjsip_transport_get_default_port_for_type(type_: pjsip_transport_type_e) -> ::std::os::raw::c_int; }

extern "C" { pub fn pjsip_transport_get_type_name(t: pjsip_transport_type_e) -> *const ::std::os::raw::c_char; }

extern "C" { pub fn pjsip_transport_get_type_desc(t: pjsip_transport_type_e) -> *const ::std::os::raw::c_char; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsip_tpselector_type { PJSIP_TPSELECTOR_NONE = 0, PJSIP_TPSELECTOR_TRANSPORT = 1, PJSIP_TPSELECTOR_LISTENER = 2 }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsip_tpselector { pub type_: pjsip_tpselector_type, pub u: pjsip_tpselector__bindgen_ty_1 }

#[repr(C)]
#[derive(Copy, Clone)]
pub union pjsip_tpselector__bindgen_ty_1 { pub transport: *mut pjsip_transport, pub listener: *mut pjsip_tpfactory, pub ptr: *mut ::std::os::raw::c_void, _bindgen_union_align: u32 }

extern "C" { pub fn pjsip_tpselector_add_ref(sel: *mut pjsip_tpselector); }

extern "C" { pub fn pjsip_tpselector_dec_ref(sel: *mut pjsip_tpselector); }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_rx_data_op_key { pub op_key: pj_ioqueue_op_key_t, pub rdata: *mut pjsip_rx_data }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsip_rx_data { pub tp_info: pjsip_rx_data__bindgen_ty_1, pub pkt_info: pjsip_rx_data__bindgen_ty_2, pub msg_info: pjsip_rx_data__bindgen_ty_3, pub endpt_info: pjsip_rx_data__bindgen_ty_4 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_rx_data__bindgen_ty_1 { pub pool: *mut pj_pool_t, pub transport: *mut pjsip_transport, pub tp_data: *mut ::std::os::raw::c_void, pub op_key: pjsip_rx_data_op_key }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsip_rx_data__bindgen_ty_2 { pub timestamp: pj_time_val, pub packet: [::std::os::raw::c_char; 4000usize], pub zero: pj_uint32_t, pub len: pj_ssize_t, pub src_addr: pj_sockaddr, pub src_addr_len: ::std::os::raw::c_int, pub src_name: [::std::os::raw::c_char; 46usize], pub src_port: ::std::os::raw::c_int }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_rx_data__bindgen_ty_3 { pub msg_buf: *mut ::std::os::raw::c_char, pub len: ::std::os::raw::c_int, pub msg: *mut pjsip_msg, pub info: *mut ::std::os::raw::c_char, pub cid: *mut pjsip_cid_hdr, pub from: *mut pjsip_from_hdr, pub to: *mut pjsip_to_hdr, pub via: *mut pjsip_via_hdr, pub cseq: *mut pjsip_cseq_hdr, pub max_fwd: *mut pjsip_max_fwd_hdr, pub route: *mut pjsip_route_hdr, pub record_route: *mut pjsip_rr_hdr, pub ctype: *mut pjsip_ctype_hdr, pub clen: *mut pjsip_clen_hdr, pub require: *mut pjsip_require_hdr, pub supported: *mut pjsip_supported_hdr, pub parse_err: pjsip_parser_err_report }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_rx_data__bindgen_ty_4 { pub mod_data: [*mut ::std::os::raw::c_void; 32usize] }

extern "C" { pub fn pjsip_rx_data_get_info(rdata: *mut pjsip_rx_data) -> *mut ::std::os::raw::c_char; }

extern "C" { pub fn pjsip_rx_data_clone(src: *const pjsip_rx_data, flags: ::std::os::raw::c_uint, p_rdata: *mut *mut pjsip_rx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_rx_data_free_cloned(rdata: *mut pjsip_rx_data) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_tx_data_op_key { pub key: pj_ioqueue_op_key_t, pub tdata: *mut pjsip_tx_data, pub token: *mut ::std::os::raw::c_void, pub callback: ::std::option::Option<unsafe extern "C" fn(arg1: *mut pjsip_transport, arg2: *mut ::std::os::raw::c_void, arg3: pj_ssize_t)> }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsip_tx_data { pub prev: *mut pjsip_tx_data, pub next: *mut pjsip_tx_data, pub pool: *mut pj_pool_t, pub obj_name: [::std::os::raw::c_char; 32usize], pub info: *mut ::std::os::raw::c_char, pub rx_timestamp: pj_time_val, pub mgr: *mut pjsip_tpmgr, pub op_key: pjsip_tx_data_op_key, pub lock: *mut pj_lock_t, pub msg: *mut pjsip_msg, pub saved_strict_route: *mut pjsip_route_hdr, pub buf: pjsip_buffer, pub ref_cnt: *mut pj_atomic_t, pub is_pending: ::std::os::raw::c_int, pub token: *mut ::std::os::raw::c_void, pub cb: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *mut pjsip_tx_data, arg3: pj_ssize_t)>, pub dest_info: pjsip_tx_data__bindgen_ty_1, pub tp_info: pjsip_tx_data__bindgen_ty_2, pub tp_sel: pjsip_tpselector, pub auth_retry: pj_bool_t, pub mod_data: [*mut ::std::os::raw::c_void; 32usize], pub via_addr: pjsip_host_port, pub via_tp: *const ::std::os::raw::c_void }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsip_tx_data__bindgen_ty_1 { pub name: pj_str_t, pub addr: pjsip_server_addresses, pub cur_addr: ::std::os::raw::c_uint }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsip_tx_data__bindgen_ty_2 { pub transport: *mut pjsip_transport, pub dst_addr: pj_sockaddr, pub dst_addr_len: ::std::os::raw::c_int, pub dst_name: [::std::os::raw::c_char; 46usize], pub dst_port: ::std::os::raw::c_int }

extern "C" { pub fn pjsip_tx_data_create(mgr: *mut pjsip_tpmgr, tdata: *mut *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_tx_data_add_ref(tdata: *mut pjsip_tx_data); }

extern "C" { pub fn pjsip_tx_data_dec_ref(tdata: *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_tx_data_encode(tdata: *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_tx_data_is_valid(tdata: *mut pjsip_tx_data) -> pj_bool_t; }

extern "C" { pub fn pjsip_tx_data_invalidate_msg(tdata: *mut pjsip_tx_data); }

extern "C" { pub fn pjsip_tx_data_get_info(tdata: *mut pjsip_tx_data) -> *mut ::std::os::raw::c_char; }

extern "C" { pub fn pjsip_tx_data_set_transport(tdata: *mut pjsip_tx_data, sel: *const pjsip_tpselector) -> pj_status_t; }

pub type pjsip_transport_callback = ::std::option::Option<unsafe extern "C" fn(tp: *mut pjsip_transport, token: *mut ::std::os::raw::c_void, sent_bytes: pj_ssize_t)>;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsip_transport_key { pub type_: ::std::os::raw::c_long, pub rem_addr: pj_sockaddr }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsip_transport_dir { PJSIP_TP_DIR_NONE = 0, PJSIP_TP_DIR_OUTGOING = 1, PJSIP_TP_DIR_INCOMING = 2 }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsip_transport { pub obj_name: [::std::os::raw::c_char; 32usize], pub pool: *mut pj_pool_t, pub ref_cnt: *mut pj_atomic_t, pub lock: *mut pj_lock_t, pub tracing: pj_bool_t, pub is_shutdown: pj_bool_t, pub is_destroying: pj_bool_t, pub key: pjsip_transport_key, pub type_name: *mut ::std::os::raw::c_char, pub flag: ::std::os::raw::c_uint, pub info: *mut ::std::os::raw::c_char, pub addr_len: ::std::os::raw::c_int, pub local_addr: pj_sockaddr, pub local_name: pjsip_host_port, pub remote_name: pjsip_host_port, pub dir: pjsip_transport_dir, pub endpt: *mut pjsip_endpoint, pub tpmgr: *mut pjsip_tpmgr, pub factory: *mut pjsip_tpfactory, pub idle_timer: pj_timer_entry, pub last_recv_ts: pj_timestamp, pub last_recv_len: pj_size_t, pub data: *mut ::std::os::raw::c_void, pub send_msg: ::std::option::Option<unsafe extern "C" fn(transport: *mut pjsip_transport, tdata: *mut pjsip_tx_data, rem_addr: *const pj_sockaddr_t, addr_len: ::std::os::raw::c_int, token: *mut ::std::os::raw::c_void, callback: pjsip_transport_callback) -> pj_status_t>, pub do_shutdown: ::std::option::Option<unsafe extern "C" fn(transport: *mut pjsip_transport) -> pj_status_t>, pub destroy: ::std::option::Option<unsafe extern "C" fn(transport: *mut pjsip_transport) -> pj_status_t> }

extern "C" { pub fn pjsip_transport_register(mgr: *mut pjsip_tpmgr, tp: *mut pjsip_transport) -> pj_status_t; }

extern "C" { pub fn pjsip_transport_shutdown(tp: *mut pjsip_transport) -> pj_status_t; }

extern "C" { pub fn pjsip_transport_shutdown2(tp: *mut pjsip_transport, force: pj_bool_t) -> pj_status_t; }

extern "C" { pub fn pjsip_transport_destroy(tp: *mut pjsip_transport) -> pj_status_t; }

extern "C" { pub fn pjsip_transport_add_ref(tp: *mut pjsip_transport) -> pj_status_t; }

extern "C" { pub fn pjsip_transport_dec_ref(tp: *mut pjsip_transport) -> pj_status_t; }

extern "C" { pub fn pjsip_tpmgr_receive_packet(mgr: *mut pjsip_tpmgr, rdata: *mut pjsip_rx_data) -> pj_ssize_t; }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsip_tpfactory { pub prev: *mut pjsip_tpfactory, pub next: *mut pjsip_tpfactory, pub obj_name: [::std::os::raw::c_char; 32usize], pub pool: *mut pj_pool_t, pub lock: *mut pj_lock_t, pub type_: pjsip_transport_type_e, pub type_name: *mut ::std::os::raw::c_char, pub flag: ::std::os::raw::c_uint, pub info: *mut ::std::os::raw::c_char, pub local_addr: pj_sockaddr, pub addr_name: pjsip_host_port, pub create_transport: ::std::option::Option<unsafe extern "C" fn(factory: *mut pjsip_tpfactory, mgr: *mut pjsip_tpmgr, endpt: *mut pjsip_endpoint, rem_addr: *const pj_sockaddr, addr_len: ::std::os::raw::c_int, transport: *mut *mut pjsip_transport) -> pj_status_t>, pub create_transport2: ::std::option::Option<unsafe extern "C" fn(factory: *mut pjsip_tpfactory, mgr: *mut pjsip_tpmgr, endpt: *mut pjsip_endpoint, rem_addr: *const pj_sockaddr, addr_len: ::std::os::raw::c_int, tdata: *mut pjsip_tx_data, transport: *mut *mut pjsip_transport) -> pj_status_t>, pub destroy: ::std::option::Option<unsafe extern "C" fn(factory: *mut pjsip_tpfactory) -> pj_status_t> }

extern "C" { pub fn pjsip_tpmgr_register_tpfactory(mgr: *mut pjsip_tpmgr, tpf: *mut pjsip_tpfactory) -> pj_status_t; }

extern "C" { pub fn pjsip_tpmgr_unregister_tpfactory(mgr: *mut pjsip_tpmgr, tpf: *mut pjsip_tpfactory) -> pj_status_t; }

pub type pjsip_rx_callback = ::std::option::Option<unsafe extern "C" fn(ep: *mut pjsip_endpoint, status: pj_status_t, rd: *mut pjsip_rx_data)>;
pub type pjsip_tx_callback = ::std::option::Option<unsafe extern "C" fn(ep: *mut pjsip_endpoint, td: *mut pjsip_tx_data) -> pj_status_t>;

extern "C" { pub fn pjsip_tpmgr_create(pool: *mut pj_pool_t, endpt: *mut pjsip_endpoint, rx_cb: pjsip_rx_callback, tx_cb: pjsip_tx_callback, p_mgr: *mut *mut pjsip_tpmgr) -> pj_status_t; }

extern "C" { pub fn pjsip_tpmgr_find_local_addr(tpmgr: *mut pjsip_tpmgr, pool: *mut pj_pool_t, type_: pjsip_transport_type_e, sel: *const pjsip_tpselector, ip_addr: *mut pj_str_t, port: *mut ::std::os::raw::c_int) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_tpmgr_fla2_param { pub tp_type: pjsip_transport_type_e, pub tp_sel: *const pjsip_tpselector, pub dst_host: pj_str_t, pub local_if: pj_bool_t, pub ret_addr: pj_str_t, pub ret_port: pj_uint16_t, pub ret_tp: *const ::std::os::raw::c_void }

extern "C" { pub fn pjsip_tpmgr_fla2_param_default(prm: *mut pjsip_tpmgr_fla2_param); }

extern "C" { pub fn pjsip_tpmgr_find_local_addr2(tpmgr: *mut pjsip_tpmgr, pool: *mut pj_pool_t, prm: *mut pjsip_tpmgr_fla2_param) -> pj_status_t; }

extern "C" { pub fn pjsip_tpmgr_get_transport_count(mgr: *mut pjsip_tpmgr) -> ::std::os::raw::c_uint; }

extern "C" { pub fn pjsip_tpmgr_destroy(mgr: *mut pjsip_tpmgr) -> pj_status_t; }

extern "C" { pub fn pjsip_tpmgr_dump_transports(mgr: *mut pjsip_tpmgr); }

extern "C" { pub fn pjsip_tpmgr_acquire_transport(mgr: *mut pjsip_tpmgr, type_: pjsip_transport_type_e, remote: *const pj_sockaddr_t, addr_len: ::std::os::raw::c_int, sel: *const pjsip_tpselector, tp: *mut *mut pjsip_transport) -> pj_status_t; }

extern "C" { pub fn pjsip_tpmgr_acquire_transport2(mgr: *mut pjsip_tpmgr, type_: pjsip_transport_type_e, remote: *const pj_sockaddr_t, addr_len: ::std::os::raw::c_int, sel: *const pjsip_tpselector, tdata: *mut pjsip_tx_data, tp: *mut *mut pjsip_transport) -> pj_status_t; }

pub type pjsip_tp_send_callback = ::std::option::Option<unsafe extern "C" fn(token: *mut ::std::os::raw::c_void, tdata: *mut pjsip_tx_data, bytes_sent: pj_ssize_t)>;

extern "C" { pub fn pjsip_transport_send(tr: *mut pjsip_transport, tdata: *mut pjsip_tx_data, addr: *const pj_sockaddr_t, addr_len: ::std::os::raw::c_int, token: *mut ::std::os::raw::c_void, cb: pjsip_tp_send_callback) -> pj_status_t; }

extern "C" { pub fn pjsip_tpmgr_send_raw(mgr: *mut pjsip_tpmgr, tp_type: pjsip_transport_type_e, sel: *const pjsip_tpselector, tdata: *mut pjsip_tx_data, raw_data: *const ::std::os::raw::c_void, data_len: pj_size_t, addr: *const pj_sockaddr_t, addr_len: ::std::os::raw::c_int, token: *mut ::std::os::raw::c_void, cb: pjsip_tp_send_callback) -> pj_status_t; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsip_transport_state { PJSIP_TP_STATE_CONNECTED = 0, PJSIP_TP_STATE_DISCONNECTED = 1, PJSIP_TP_STATE_SHUTDOWN = 2, PJSIP_TP_STATE_DESTROY = 3 }

pub type pjsip_tp_state_listener_key = ::std::os::raw::c_void;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_transport_state_info { pub status: pj_status_t, pub ext_info: *mut ::std::os::raw::c_void, pub user_data: *mut ::std::os::raw::c_void }

pub type pjsip_tp_state_callback = ::std::option::Option<unsafe extern "C" fn(tp: *mut pjsip_transport, state: pjsip_transport_state, info: *const pjsip_transport_state_info)>;

extern "C" { pub fn pjsip_tpmgr_set_state_cb(mgr: *mut pjsip_tpmgr, cb: pjsip_tp_state_callback) -> pj_status_t; }

extern "C" { pub fn pjsip_tpmgr_get_state_cb(mgr: *const pjsip_tpmgr) -> pjsip_tp_state_callback; }

extern "C" { pub fn pjsip_transport_add_state_listener(tp: *mut pjsip_transport, cb: pjsip_tp_state_callback, user_data: *mut ::std::os::raw::c_void, key: *mut *mut pjsip_tp_state_listener_key) -> pj_status_t; }

extern "C" { pub fn pjsip_transport_remove_state_listener(tp: *mut pjsip_transport, key: *mut pjsip_tp_state_listener_key, user_data: *const ::std::os::raw::c_void) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_tp_dropped_data { pub tp: *mut pjsip_transport, pub data: *mut ::std::os::raw::c_void, pub len: pj_size_t, pub status: pj_status_t }

pub type pjsip_tp_on_rx_dropped_cb = ::std::option::Option<unsafe extern "C" fn(data: *mut pjsip_tp_dropped_data)>;

extern "C" { pub fn pjsip_tpmgr_set_drop_data_cb(mgr: *mut pjsip_tpmgr, cb: pjsip_tp_on_rx_dropped_cb) -> pj_status_t; }

pub type pjsip_endpt_exit_callback = ::std::option::Option<unsafe extern "C" fn(endpt: *mut pjsip_endpoint)>;

extern "C" { pub fn pjsip_endpt_create(pf: *mut pj_pool_factory, name: *const ::std::os::raw::c_char, endpt: *mut *mut pjsip_endpoint) -> pj_status_t; }

extern "C" { pub fn pjsip_endpt_destroy(endpt: *mut pjsip_endpoint); }

extern "C" { pub fn pjsip_endpt_name(endpt: *const pjsip_endpoint) -> *const pj_str_t; }

extern "C" { pub fn pjsip_endpt_handle_events(endpt: *mut pjsip_endpoint, max_timeout: *const pj_time_val) -> pj_status_t; }

extern "C" { pub fn pjsip_endpt_handle_events2(endpt: *mut pjsip_endpoint, max_timeout: *const pj_time_val, count: *mut ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pjsip_endpt_schedule_timer(endpt: *mut pjsip_endpoint, entry: *mut pj_timer_entry, delay: *const pj_time_val) -> pj_status_t; }

extern "C" { pub fn pjsip_endpt_cancel_timer(endpt: *mut pjsip_endpoint, entry: *mut pj_timer_entry); }

extern "C" { pub fn pjsip_endpt_get_timer_heap(endpt: *mut pjsip_endpoint) -> *mut pj_timer_heap_t; }

extern "C" { pub fn pjsip_endpt_register_module(endpt: *mut pjsip_endpoint, module: *mut pjsip_module) -> pj_status_t; }

extern "C" { pub fn pjsip_endpt_unregister_module(endpt: *mut pjsip_endpoint, module: *mut pjsip_module) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_process_rdata_param { pub start_prio: ::std::os::raw::c_uint, pub start_mod: *mut ::std::os::raw::c_void, pub idx_after_start: ::std::os::raw::c_uint, pub silent: pj_bool_t }

extern "C" { pub fn pjsip_process_rdata_param_default(p: *mut pjsip_process_rdata_param); }

extern "C" { pub fn pjsip_endpt_process_rx_data(endpt: *mut pjsip_endpoint, rdata: *mut pjsip_rx_data, p: *mut pjsip_process_rdata_param, p_handled: *mut pj_bool_t) -> pj_status_t; }

extern "C" { pub fn pjsip_endpt_create_pool(endpt: *mut pjsip_endpoint, pool_name: *const ::std::os::raw::c_char, initial: pj_size_t, increment: pj_size_t) -> *mut pj_pool_t; }

extern "C" { pub fn pjsip_endpt_release_pool(endpt: *mut pjsip_endpoint, pool: *mut pj_pool_t); }

extern "C" { pub fn pjsip_endpt_find_tsx(endpt: *mut pjsip_endpoint, key: *const pj_str_t) -> *mut pjsip_transaction; }

extern "C" { pub fn pjsip_endpt_register_tsx(endpt: *mut pjsip_endpoint, tsx: *mut pjsip_transaction); }

extern "C" { pub fn pjsip_endpt_destroy_tsx(endpt: *mut pjsip_endpoint, tsx: *mut pjsip_transaction); }

extern "C" { pub fn pjsip_endpt_create_tdata(endpt: *mut pjsip_endpoint, p_tdata: *mut *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_endpt_create_resolver(endpt: *mut pjsip_endpoint, p_resv: *mut *mut pj_dns_resolver) -> pj_status_t; }

extern "C" { pub fn pjsip_endpt_set_resolver(endpt: *mut pjsip_endpoint, resv: *mut pj_dns_resolver) -> pj_status_t; }

extern "C" { pub fn pjsip_endpt_set_ext_resolver(endpt: *mut pjsip_endpoint, ext_res: *mut pjsip_ext_resolver) -> pj_status_t; }

extern "C" { pub fn pjsip_endpt_get_resolver(endpt: *mut pjsip_endpoint) -> *mut pj_dns_resolver; }

extern "C" { pub fn pjsip_endpt_resolve(endpt: *mut pjsip_endpoint, pool: *mut pj_pool_t, target: *mut pjsip_host_info, token: *mut ::std::os::raw::c_void, cb: pjsip_resolver_callback); }

extern "C" { pub fn pjsip_endpt_get_tpmgr(endpt: *mut pjsip_endpoint) -> *mut pjsip_tpmgr; }

extern "C" { pub fn pjsip_endpt_get_ioqueue(endpt: *mut pjsip_endpoint) -> *mut pj_ioqueue_t; }

extern "C" { pub fn pjsip_endpt_acquire_transport(endpt: *mut pjsip_endpoint, type_: pjsip_transport_type_e, remote: *const pj_sockaddr_t, addr_len: ::std::os::raw::c_int, sel: *const pjsip_tpselector, p_tp: *mut *mut pjsip_transport) -> pj_status_t; }

extern "C" { pub fn pjsip_endpt_acquire_transport2(endpt: *mut pjsip_endpoint, type_: pjsip_transport_type_e, remote: *const pj_sockaddr_t, addr_len: ::std::os::raw::c_int, sel: *const pjsip_tpselector, tdata: *mut pjsip_tx_data, p_tp: *mut *mut pjsip_transport) -> pj_status_t; }

extern "C" { pub fn pjsip_endpt_get_capability(endpt: *mut pjsip_endpoint, htype: ::std::os::raw::c_int, hname: *const pj_str_t) -> *const pjsip_hdr; }

extern "C" { pub fn pjsip_endpt_has_capability(endpt: *mut pjsip_endpoint, htype: ::std::os::raw::c_int, hname: *const pj_str_t, token: *const pj_str_t) -> pj_bool_t; }

extern "C" { pub fn pjsip_endpt_add_capability(endpt: *mut pjsip_endpoint, mod_: *mut pjsip_module, htype: ::std::os::raw::c_int, hname: *const pj_str_t, count: ::std::os::raw::c_uint, tags: *const pj_str_t) -> pj_status_t; }

extern "C" { pub fn pjsip_endpt_get_request_headers(e: *mut pjsip_endpoint) -> *const pjsip_hdr; }

extern "C" { pub fn pjsip_endpt_dump(endpt: *mut pjsip_endpoint, detail: pj_bool_t); }

extern "C" { pub fn pjsip_endpt_atexit(endpt: *mut pjsip_endpoint, func: pjsip_endpt_exit_callback) -> pj_status_t; }

extern "C" { pub fn pjsip_endpt_log_error(endpt: *mut pjsip_endpoint, sender: *const ::std::os::raw::c_char, error_code: pj_status_t, format: *const ::std::os::raw::c_char, ...); }

extern "C" { pub fn pjsip_endpt_send_tsx_event(endpt: *mut pjsip_endpoint, evt: *mut pjsip_event); }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_target { pub prev: *mut pjsip_target, pub next: *mut pjsip_target, pub uri: *mut pjsip_uri, pub q1000: ::std::os::raw::c_int, pub code: pjsip_status_code, pub reason: pj_str_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_target_set { pub head: pjsip_target, pub current: *mut pjsip_target }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsip_redirect_op { PJSIP_REDIRECT_REJECT = 0, PJSIP_REDIRECT_ACCEPT = 1, PJSIP_REDIRECT_ACCEPT_REPLACE = 2, PJSIP_REDIRECT_PENDING = 3, PJSIP_REDIRECT_STOP = 4 }

extern "C" { pub fn pjsip_target_set_add_uri(tset: *mut pjsip_target_set, pool: *mut pj_pool_t, uri: *const pjsip_uri, q1000: ::std::os::raw::c_int) -> pj_status_t; }

extern "C" { pub fn pjsip_target_set_add_from_msg(tset: *mut pjsip_target_set, pool: *mut pj_pool_t, msg: *const pjsip_msg) -> pj_status_t; }

extern "C" { pub fn pjsip_target_set_get_next(tset: *const pjsip_target_set) -> *mut pjsip_target; }

extern "C" { pub fn pjsip_target_set_set_current(tset: *mut pjsip_target_set, target: *mut pjsip_target) -> pj_status_t; }

extern "C" { pub fn pjsip_target_assign_status(target: *mut pjsip_target, pool: *mut pj_pool_t, status_code: ::std::os::raw::c_int, reason: *const pj_str_t) -> pj_status_t; }

extern "C" { pub fn pjsip_endpt_create_request(endpt: *mut pjsip_endpoint, method: *const pjsip_method, target: *const pj_str_t, from: *const pj_str_t, to: *const pj_str_t, contact: *const pj_str_t, call_id: *const pj_str_t, cseq: ::std::os::raw::c_int, text: *const pj_str_t, p_tdata: *mut *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_endpt_create_request_from_hdr(endpt: *mut pjsip_endpoint, method: *const pjsip_method, target: *const pjsip_uri, from: *const pjsip_from_hdr, to: *const pjsip_to_hdr, contact: *const pjsip_contact_hdr, call_id: *const pjsip_cid_hdr, cseq: ::std::os::raw::c_int, text: *const pj_str_t, p_tdata: *mut *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_endpt_create_response(endpt: *mut pjsip_endpoint, rdata: *const pjsip_rx_data, st_code: ::std::os::raw::c_int, st_text: *const pj_str_t, p_tdata: *mut *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_endpt_create_ack(endpt: *mut pjsip_endpoint, tdata: *const pjsip_tx_data, rdata: *const pjsip_rx_data, ack: *mut *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_endpt_create_cancel(endpt: *mut pjsip_endpoint, tdata: *const pjsip_tx_data, p_tdata: *mut *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_get_dest_info(target_uri: *const pjsip_uri, request_uri: *const pjsip_uri, pool: *mut pj_pool_t, dest_info: *mut pjsip_host_info) -> pj_status_t; }

extern "C" { pub fn pjsip_get_request_dest(tdata: *const pjsip_tx_data, dest_info: *mut pjsip_host_info) -> pj_status_t; }

extern "C" { pub fn pjsip_process_route_set(tdata: *mut pjsip_tx_data, dest_info: *mut pjsip_host_info) -> pj_status_t; }

extern "C" { pub fn pjsip_restore_strict_route_set(tdata: *mut pjsip_tx_data); }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_send_state { pub token: *mut ::std::os::raw::c_void, pub endpt: *mut pjsip_endpoint, pub tdata: *mut pjsip_tx_data, pub cur_transport: *mut pjsip_transport, pub app_cb: ::std::option::Option<unsafe extern "C" fn(arg1: *mut pjsip_send_state, sent: pj_ssize_t, cont: *mut pj_bool_t)> }

pub type pjsip_send_callback = ::std::option::Option<unsafe extern "C" fn(st: *mut pjsip_send_state, sent: pj_ssize_t, cont: *mut pj_bool_t)>;

extern "C" { pub fn pjsip_endpt_send_request_stateless(endpt: *mut pjsip_endpoint, tdata: *mut pjsip_tx_data, token: *mut ::std::os::raw::c_void, cb: pjsip_send_callback) -> pj_status_t; }

extern "C" { pub fn pjsip_endpt_send_raw(endpt: *mut pjsip_endpoint, tp_type: pjsip_transport_type_e, sel: *const pjsip_tpselector, raw_data: *const ::std::os::raw::c_void, data_len: pj_size_t, addr: *const pj_sockaddr_t, addr_len: ::std::os::raw::c_int, token: *mut ::std::os::raw::c_void, cb: pjsip_tp_send_callback) -> pj_status_t; }

extern "C" { pub fn pjsip_endpt_send_raw_to_uri(endpt: *mut pjsip_endpoint, dst_uri: *const pj_str_t, sel: *const pjsip_tpselector, raw_data: *const ::std::os::raw::c_void, data_len: pj_size_t, token: *mut ::std::os::raw::c_void, cb: pjsip_tp_send_callback) -> pj_status_t; }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsip_response_addr { pub transport: *mut pjsip_transport, pub addr: pj_sockaddr, pub addr_len: ::std::os::raw::c_int, pub dst_host: pjsip_host_info }

extern "C" { pub fn pjsip_get_response_addr(pool: *mut pj_pool_t, rdata: *mut pjsip_rx_data, res_addr: *mut pjsip_response_addr) -> pj_status_t; }

extern "C" { pub fn pjsip_endpt_send_response(endpt: *mut pjsip_endpoint, res_addr: *mut pjsip_response_addr, tdata: *mut pjsip_tx_data, token: *mut ::std::os::raw::c_void, cb: pjsip_send_callback) -> pj_status_t; }

extern "C" { pub fn pjsip_endpt_send_response2(endpt: *mut pjsip_endpoint, rdata: *mut pjsip_rx_data, tdata: *mut pjsip_tx_data, token: *mut ::std::os::raw::c_void, cb: pjsip_send_callback) -> pj_status_t; }

extern "C" { pub fn pjsip_endpt_respond_stateless(endpt: *mut pjsip_endpoint, rdata: *mut pjsip_rx_data, st_code: ::std::os::raw::c_int, st_text: *const pj_str_t, hdr_list: *const pjsip_hdr, body: *const pjsip_msg_body) -> pj_status_t; }

extern "C" { pub fn pjsip_endpt_respond(endpt: *mut pjsip_endpoint, tsx_user: *mut pjsip_module, rdata: *mut pjsip_rx_data, st_code: ::std::os::raw::c_int, st_text: *const pj_str_t, hdr_list: *const pjsip_hdr, body: *const pjsip_msg_body, p_tsx: *mut *mut pjsip_transaction) -> pj_status_t; }

pub type pjsip_endpt_send_callback = ::std::option::Option<unsafe extern "C" fn(token: *mut ::std::os::raw::c_void, e: *mut pjsip_event)>;

extern "C" { pub fn pjsip_endpt_send_request(endpt: *mut pjsip_endpoint, tdata: *mut pjsip_tx_data, timeout: pj_int32_t, token: *mut ::std::os::raw::c_void, cb: pjsip_endpt_send_callback) -> pj_status_t; }

extern "C" { pub fn pjsip_endpt_create_request_fwd(endpt: *mut pjsip_endpoint, rdata: *mut pjsip_rx_data, uri: *const pjsip_uri, branch: *const pj_str_t, options: ::std::os::raw::c_uint, tdata: *mut *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_endpt_create_response_fwd(endpt: *mut pjsip_endpoint, rdata: *mut pjsip_rx_data, options: ::std::os::raw::c_uint, tdata: *mut *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_calculate_branch_id(rdata: *mut pjsip_rx_data) -> pj_str_t; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_qos_type { PJ_QOS_TYPE_BEST_EFFORT = 0, PJ_QOS_TYPE_BACKGROUND = 1, PJ_QOS_TYPE_VIDEO = 2, PJ_QOS_TYPE_VOICE = 3, PJ_QOS_TYPE_CONTROL = 4, PJ_QOS_TYPE_SIGNALLING = 5 }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_qos_flag { PJ_QOS_PARAM_HAS_DSCP = 1, PJ_QOS_PARAM_HAS_SO_PRIO = 2, PJ_QOS_PARAM_HAS_WMM = 4 }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_qos_wmm_prio { PJ_QOS_WMM_PRIO_BULK_EFFORT = 0, PJ_QOS_WMM_PRIO_BULK = 1, PJ_QOS_WMM_PRIO_VIDEO = 2, PJ_QOS_WMM_PRIO_VOICE = 3 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_qos_params { pub flags: pj_uint8_t, pub dscp_val: pj_uint8_t, pub so_prio: pj_uint8_t, pub wmm_prio: pj_qos_wmm_prio }

extern "C" { pub fn pj_sock_set_qos_type(sock: pj_sock_t, type_: pj_qos_type) -> pj_status_t; }

extern "C" { pub fn pj_sock_get_qos_type(sock: pj_sock_t, p_type: *mut pj_qos_type) -> pj_status_t; }

extern "C" { pub fn pj_sock_apply_qos(sock: pj_sock_t, qos_type: pj_qos_type, qos_params: *mut pj_qos_params, log_level: ::std::os::raw::c_uint, log_sender: *const ::std::os::raw::c_char, sock_name: *const ::std::os::raw::c_char) -> pj_status_t; }

extern "C" { pub fn pj_sock_apply_qos2(sock: pj_sock_t, qos_type: pj_qos_type, qos_params: *const pj_qos_params, log_level: ::std::os::raw::c_uint, log_sender: *const ::std::os::raw::c_char, sock_name: *const ::std::os::raw::c_char) -> pj_status_t; }

extern "C" { pub fn pj_qos_get_params(type_: pj_qos_type, p_param: *mut pj_qos_params) -> pj_status_t; }

extern "C" { pub fn pj_qos_get_type(param: *const pj_qos_params, p_type: *mut pj_qos_type) -> pj_status_t; }

extern "C" { pub fn pj_sock_set_qos_params(sock: pj_sock_t, param: *mut pj_qos_params) -> pj_status_t; }

extern "C" { pub fn pj_sock_get_qos_params(sock: pj_sock_t, p_param: *mut pj_qos_params) -> pj_status_t; }

pub const PJSIP_UDP_TRANSPORT_KEEP_SOCKET: _bindgen_ty_6 = _bindgen_ty_6::PJSIP_UDP_TRANSPORT_KEEP_SOCKET;
pub const PJSIP_UDP_TRANSPORT_DESTROY_SOCKET: _bindgen_ty_6 = _bindgen_ty_6::PJSIP_UDP_TRANSPORT_DESTROY_SOCKET;

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_6 { PJSIP_UDP_TRANSPORT_KEEP_SOCKET = 1, PJSIP_UDP_TRANSPORT_DESTROY_SOCKET = 2 }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsip_udp_transport_cfg { pub af: ::std::os::raw::c_int, pub bind_addr: pj_sockaddr, pub addr_name: pjsip_host_port, pub async_cnt: ::std::os::raw::c_uint, pub qos_type: pj_qos_type, pub qos_params: pj_qos_params, pub sockopt_params: pj_sockopt_params }

extern "C" { pub fn pjsip_udp_transport_cfg_default(cfg: *mut pjsip_udp_transport_cfg, af: ::std::os::raw::c_int); }

extern "C" { pub fn pjsip_udp_transport_start2(endpt: *mut pjsip_endpoint, cfg: *const pjsip_udp_transport_cfg, p_transport: *mut *mut pjsip_transport) -> pj_status_t; }

extern "C" { pub fn pjsip_udp_transport_start(endpt: *mut pjsip_endpoint, local: *const pj_sockaddr_in, a_name: *const pjsip_host_port, async_cnt: ::std::os::raw::c_uint, p_transport: *mut *mut pjsip_transport) -> pj_status_t; }

extern "C" { pub fn pjsip_udp_transport_start6(endpt: *mut pjsip_endpoint, local: *const pj_sockaddr_in6, a_name: *const pjsip_host_port, async_cnt: ::std::os::raw::c_uint, p_transport: *mut *mut pjsip_transport) -> pj_status_t; }

extern "C" { pub fn pjsip_udp_transport_attach(endpt: *mut pjsip_endpoint, sock: pj_sock_t, a_name: *const pjsip_host_port, async_cnt: ::std::os::raw::c_uint, p_transport: *mut *mut pjsip_transport) -> pj_status_t; }

extern "C" { pub fn pjsip_udp_transport_attach2(endpt: *mut pjsip_endpoint, type_: pjsip_transport_type_e, sock: pj_sock_t, a_name: *const pjsip_host_port, async_cnt: ::std::os::raw::c_uint, p_transport: *mut *mut pjsip_transport) -> pj_status_t; }

extern "C" { pub fn pjsip_udp_transport_get_socket(transport: *mut pjsip_transport) -> pj_sock_t; }

extern "C" { pub fn pjsip_udp_transport_pause(transport: *mut pjsip_transport, option: ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pjsip_udp_transport_restart(transport: *mut pjsip_transport, option: ::std::os::raw::c_uint, sock: pj_sock_t, local: *const pj_sockaddr_in, a_name: *const pjsip_host_port) -> pj_status_t; }

extern "C" { pub fn pjsip_udp_transport_restart2(transport: *mut pjsip_transport, option: ::std::os::raw::c_uint, sock: pj_sock_t, local: *const pj_sockaddr, a_name: *const pjsip_host_port) -> pj_status_t; }

extern "C" { pub fn pjsip_loop_start(endpt: *mut pjsip_endpoint, transport: *mut *mut pjsip_transport) -> pj_status_t; }

extern "C" { pub fn pjsip_loop_set_discard(tp: *mut pjsip_transport, discard: pj_bool_t, prev_value: *mut pj_bool_t) -> pj_status_t; }

extern "C" { pub fn pjsip_loop_set_failure(tp: *mut pjsip_transport, fail_flag: ::std::os::raw::c_int, prev_value: *mut ::std::os::raw::c_int) -> pj_status_t; }

extern "C" { pub fn pjsip_loop_set_recv_delay(tp: *mut pjsip_transport, delay: ::std::os::raw::c_uint, prev_value: *mut ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pjsip_loop_set_send_callback_delay(tp: *mut pjsip_transport, delay: ::std::os::raw::c_uint, prev_value: *mut ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pjsip_loop_set_delay(tp: *mut pjsip_transport, delay: ::std::os::raw::c_uint) -> pj_status_t; }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsip_tcp_transport_cfg { pub af: ::std::os::raw::c_int, pub bind_addr: pj_sockaddr, pub reuse_addr: pj_bool_t, pub addr_name: pjsip_host_port, pub async_cnt: ::std::os::raw::c_uint, pub qos_type: pj_qos_type, pub qos_params: pj_qos_params, pub sockopt_params: pj_sockopt_params }

extern "C" { pub fn pjsip_tcp_transport_cfg_default(cfg: *mut pjsip_tcp_transport_cfg, af: ::std::os::raw::c_int); }

extern "C" { pub fn pjsip_tcp_transport_start(endpt: *mut pjsip_endpoint, local: *const pj_sockaddr_in, async_cnt: ::std::os::raw::c_uint, p_factory: *mut *mut pjsip_tpfactory) -> pj_status_t; }

extern "C" { pub fn pjsip_tcp_transport_start2(endpt: *mut pjsip_endpoint, local: *const pj_sockaddr_in, a_name: *const pjsip_host_port, async_cnt: ::std::os::raw::c_uint, p_factory: *mut *mut pjsip_tpfactory) -> pj_status_t; }

extern "C" { pub fn pjsip_tcp_transport_start3(endpt: *mut pjsip_endpoint, cfg: *const pjsip_tcp_transport_cfg, p_factory: *mut *mut pjsip_tpfactory) -> pj_status_t; }

extern "C" { pub fn pjsip_tcp_transport_get_socket(transport: *mut pjsip_transport) -> pj_sock_t; }

extern "C" { pub fn pjsip_tcp_transport_lis_start(factory: *mut pjsip_tpfactory, local: *const pj_sockaddr, a_name: *const pjsip_host_port) -> pj_status_t; }

extern "C" { pub fn pjsip_tcp_transport_restart(factory: *mut pjsip_tpfactory, local: *const pj_sockaddr, a_name: *const pjsip_host_port) -> pj_status_t; }

pub type pj_pool_callback = ::std::option::Option<unsafe extern "C" fn(pool: *mut pj_pool_t, size: pj_size_t)>;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_pool_block { pub prev: *mut pj_pool_block, pub next: *mut pj_pool_block, pub buf: *mut ::std::os::raw::c_uchar, pub cur: *mut ::std::os::raw::c_uchar, pub end: *mut ::std::os::raw::c_uchar }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_pool_t { pub prev: *mut pj_pool_t, pub next: *mut pj_pool_t, pub obj_name: [::std::os::raw::c_char; 32usize], pub factory: *mut pj_pool_factory, pub factory_data: *mut ::std::os::raw::c_void, pub capacity: pj_size_t, pub increment_size: pj_size_t, pub block_list: pj_pool_block, pub callback: pj_pool_callback }

extern "C" { pub fn pj_pool_create(factory: *mut pj_pool_factory, name: *const ::std::os::raw::c_char, initial_size: pj_size_t, increment_size: pj_size_t, callback: pj_pool_callback) -> *mut pj_pool_t; }

extern "C" { pub fn pj_pool_release(pool: *mut pj_pool_t); }

extern "C" { pub fn pj_pool_safe_release(ppool: *mut *mut pj_pool_t); }

extern "C" { pub fn pj_pool_getobjname(pool: *const pj_pool_t) -> *const ::std::os::raw::c_char; }

extern "C" { pub fn pj_pool_reset(pool: *mut pj_pool_t); }

extern "C" { pub fn pj_pool_get_capacity(pool: *mut pj_pool_t) -> pj_size_t; }

extern "C" { pub fn pj_pool_get_used_size(pool: *mut pj_pool_t) -> pj_size_t; }

extern "C" { pub fn pj_pool_alloc(pool: *mut pj_pool_t, size: pj_size_t) -> *mut ::std::os::raw::c_void; }

extern "C" { pub fn pj_pool_calloc(pool: *mut pj_pool_t, count: pj_size_t, elem: pj_size_t) -> *mut ::std::os::raw::c_void; }

extern "C" { pub fn pj_pool_alloc_from_block(block: *mut pj_pool_block, size: pj_size_t) -> *mut ::std::os::raw::c_void; }

extern "C" { pub fn pj_pool_allocate_find(pool: *mut pj_pool_t, size: pj_size_t) -> *mut ::std::os::raw::c_void; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_pool_factory_policy { pub block_alloc: ::std::option::Option<unsafe extern "C" fn(factory: *mut pj_pool_factory, size: pj_size_t) -> *mut ::std::os::raw::c_void>, pub block_free: ::std::option::Option<unsafe extern "C" fn(factory: *mut pj_pool_factory, mem: *mut ::std::os::raw::c_void, size: pj_size_t)>, pub callback: pj_pool_callback, pub flags: ::std::os::raw::c_uint }

extern "C" {
    #[link_name = "\u{1}PJ_NO_MEMORY_EXCEPTION"]
    pub static mut PJ_NO_MEMORY_EXCEPTION: ::std::os::raw::c_int;
}

extern "C" { pub fn pj_NO_MEMORY_EXCEPTION() -> ::std::os::raw::c_int; }

extern "C" {
    #[link_name = "\u{1}pj_pool_factory_default_policy"]
    pub static mut pj_pool_factory_default_policy: pj_pool_factory_policy;
}

extern "C" { pub fn pj_pool_factory_get_default_policy() -> *const pj_pool_factory_policy; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_pool_factory { pub policy: pj_pool_factory_policy, pub create_pool: ::std::option::Option<unsafe extern "C" fn(factory: *mut pj_pool_factory, name: *const ::std::os::raw::c_char, initial_size: pj_size_t, increment_size: pj_size_t, callback: pj_pool_callback) -> *mut pj_pool_t>, pub release_pool: ::std::option::Option<unsafe extern "C" fn(factory: *mut pj_pool_factory, pool: *mut pj_pool_t)>, pub dump_status: ::std::option::Option<unsafe extern "C" fn(factory: *mut pj_pool_factory, detail: pj_bool_t)>, pub on_block_alloc: ::std::option::Option<unsafe extern "C" fn(factory: *mut pj_pool_factory, size: pj_size_t) -> pj_bool_t>, pub on_block_free: ::std::option::Option<unsafe extern "C" fn(factory: *mut pj_pool_factory, size: pj_size_t)> }

extern "C" { pub fn pj_pool_create_int(factory: *mut pj_pool_factory, name: *const ::std::os::raw::c_char, initial_size: pj_size_t, increment_size: pj_size_t, callback: pj_pool_callback) -> *mut pj_pool_t; }

extern "C" { pub fn pj_pool_init_int(pool: *mut pj_pool_t, name: *const ::std::os::raw::c_char, increment_size: pj_size_t, callback: pj_pool_callback); }

extern "C" { pub fn pj_pool_destroy_int(pool: *mut pj_pool_t); }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pj_caching_pool { pub factory: pj_pool_factory, pub capacity: pj_size_t, pub max_capacity: pj_size_t, pub used_count: pj_size_t, pub used_size: pj_size_t, pub peak_used_size: pj_size_t, pub free_list: [pj_list; 16usize], pub used_list: pj_list, pub pool_buf: [::std::os::raw::c_char; 256usize], pub lock: *mut pj_lock_t }

extern "C" { pub fn pj_caching_pool_init(ch_pool: *mut pj_caching_pool, policy: *const pj_pool_factory_policy, max_capacity: pj_size_t); }

extern "C" { pub fn pj_caching_pool_destroy(ch_pool: *mut pj_caching_pool); }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_ssl_sock_t { _unused: [u8; 0] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_ssl_cert_t { _unused: [u8; 0] }

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_ssl_cert_verify_flag_t { PJ_SSL_CERT_ESUCCESS = 0, PJ_SSL_CERT_EISSUER_NOT_FOUND = 1, PJ_SSL_CERT_EUNTRUSTED = 2, PJ_SSL_CERT_EVALIDITY_PERIOD = 4, PJ_SSL_CERT_EINVALID_FORMAT = 8, PJ_SSL_CERT_EINVALID_PURPOSE = 16, PJ_SSL_CERT_EISSUER_MISMATCH = 32, PJ_SSL_CERT_ECRL_FAILURE = 64, PJ_SSL_CERT_EREVOKED = 128, PJ_SSL_CERT_ECHAIN_TOO_LONG = 256, PJ_SSL_CERT_EIDENTITY_NOT_MATCH = 1073741824, PJ_SSL_CERT_EUNKNOWN = -2147483648 }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_ssl_cert_name_type { PJ_SSL_CERT_NAME_UNKNOWN = 0, PJ_SSL_CERT_NAME_RFC822 = 1, PJ_SSL_CERT_NAME_DNS = 2, PJ_SSL_CERT_NAME_URI = 3, PJ_SSL_CERT_NAME_IP = 4 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_ssl_cert_info { pub version: ::std::os::raw::c_uint, pub serial_no: [pj_uint8_t; 20usize], pub subject: pj_ssl_cert_info__bindgen_ty_1, pub issuer: pj_ssl_cert_info__bindgen_ty_2, pub validity: pj_ssl_cert_info__bindgen_ty_3, pub subj_alt_name: pj_ssl_cert_info__bindgen_ty_4, pub raw: pj_str_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_ssl_cert_info__bindgen_ty_1 { pub cn: pj_str_t, pub info: pj_str_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_ssl_cert_info__bindgen_ty_2 { pub cn: pj_str_t, pub info: pj_str_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_ssl_cert_info__bindgen_ty_3 { pub start: pj_time_val, pub end: pj_time_val, pub gmt: pj_bool_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_ssl_cert_info__bindgen_ty_4 { pub cnt: ::std::os::raw::c_uint, pub entry: *mut pj_ssl_cert_info__bindgen_ty_4__bindgen_ty_1 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_ssl_cert_info__bindgen_ty_4__bindgen_ty_1 { pub type_: pj_ssl_cert_name_type, pub name: pj_str_t }

extern "C" { pub fn pj_ssl_cert_load_from_files(pool: *mut pj_pool_t, CA_file: *const pj_str_t, cert_file: *const pj_str_t, privkey_file: *const pj_str_t, privkey_pass: *const pj_str_t, p_cert: *mut *mut pj_ssl_cert_t) -> pj_status_t; }

extern "C" { pub fn pj_ssl_cert_load_from_files2(pool: *mut pj_pool_t, CA_file: *const pj_str_t, CA_path: *const pj_str_t, cert_file: *const pj_str_t, privkey_file: *const pj_str_t, privkey_pass: *const pj_str_t, p_cert: *mut *mut pj_ssl_cert_t) -> pj_status_t; }

extern "C" { pub fn pj_ssl_cert_info_dump(ci: *const pj_ssl_cert_info, indent: *const ::std::os::raw::c_char, buf: *mut ::std::os::raw::c_char, buf_size: pj_size_t) -> pj_ssize_t; }

extern "C" { pub fn pj_ssl_cert_get_verify_status_strings(verify_status: pj_uint32_t, error_strings: *mut *const ::std::os::raw::c_char, count: *mut ::std::os::raw::c_uint) -> pj_status_t; }

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_ssl_cipher { PJ_TLS_UNKNOWN_CIPHER = -1, PJ_TLS_NULL_WITH_NULL_NULL = 0, PJ_TLS_RSA_WITH_NULL_MD5 = 1, PJ_TLS_RSA_WITH_NULL_SHA = 2, PJ_TLS_RSA_WITH_NULL_SHA256 = 59, PJ_TLS_RSA_WITH_RC4_128_MD5 = 4, PJ_TLS_RSA_WITH_RC4_128_SHA = 5, PJ_TLS_RSA_WITH_3DES_EDE_CBC_SHA = 10, PJ_TLS_RSA_WITH_AES_128_CBC_SHA = 47, PJ_TLS_RSA_WITH_AES_256_CBC_SHA = 53, PJ_TLS_RSA_WITH_AES_128_CBC_SHA256 = 60, PJ_TLS_RSA_WITH_AES_256_CBC_SHA256 = 61, PJ_TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA = 13, PJ_TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA = 16, PJ_TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA = 19, PJ_TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA = 22, PJ_TLS_DH_DSS_WITH_AES_128_CBC_SHA = 48, PJ_TLS_DH_RSA_WITH_AES_128_CBC_SHA = 49, PJ_TLS_DHE_DSS_WITH_AES_128_CBC_SHA = 50, PJ_TLS_DHE_RSA_WITH_AES_128_CBC_SHA = 51, PJ_TLS_DH_DSS_WITH_AES_256_CBC_SHA = 54, PJ_TLS_DH_RSA_WITH_AES_256_CBC_SHA = 55, PJ_TLS_DHE_DSS_WITH_AES_256_CBC_SHA = 56, PJ_TLS_DHE_RSA_WITH_AES_256_CBC_SHA = 57, PJ_TLS_DH_DSS_WITH_AES_128_CBC_SHA256 = 62, PJ_TLS_DH_RSA_WITH_AES_128_CBC_SHA256 = 63, PJ_TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 = 64, PJ_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 = 103, PJ_TLS_DH_DSS_WITH_AES_256_CBC_SHA256 = 104, PJ_TLS_DH_RSA_WITH_AES_256_CBC_SHA256 = 105, PJ_TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 = 106, PJ_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 = 107, PJ_TLS_DH_anon_WITH_RC4_128_MD5 = 24, PJ_TLS_DH_anon_WITH_3DES_EDE_CBC_SHA = 27, PJ_TLS_DH_anon_WITH_AES_128_CBC_SHA = 52, PJ_TLS_DH_anon_WITH_AES_256_CBC_SHA = 58, PJ_TLS_DH_anon_WITH_AES_128_CBC_SHA256 = 108, PJ_TLS_DH_anon_WITH_AES_256_CBC_SHA256 = 109, PJ_TLS_RSA_EXPORT_WITH_RC4_40_MD5 = 3, PJ_TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 = 6, PJ_TLS_RSA_WITH_IDEA_CBC_SHA = 7, PJ_TLS_RSA_EXPORT_WITH_DES40_CBC_SHA = 8, PJ_TLS_RSA_WITH_DES_CBC_SHA = 9, PJ_TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA = 11, PJ_TLS_DH_DSS_WITH_DES_CBC_SHA = 12, PJ_TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA = 14, PJ_TLS_DH_RSA_WITH_DES_CBC_SHA = 15, PJ_TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA = 17, PJ_TLS_DHE_DSS_WITH_DES_CBC_SHA = 18, PJ_TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA = 20, PJ_TLS_DHE_RSA_WITH_DES_CBC_SHA = 21, PJ_TLS_DH_anon_EXPORT_WITH_RC4_40_MD5 = 23, PJ_TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA = 25, PJ_TLS_DH_anon_WITH_DES_CBC_SHA = 26, PJ_SSL_FORTEZZA_KEA_WITH_NULL_SHA = 28, PJ_SSL_FORTEZZA_KEA_WITH_FORTEZZA_CBC_SHA = 29, PJ_SSL_FORTEZZA_KEA_WITH_RC4_128_SHA = 30, PJ_SSL_CK_RC4_128_WITH_MD5 = 65664, PJ_SSL_CK_RC4_128_EXPORT40_WITH_MD5 = 131200, PJ_SSL_CK_RC2_128_CBC_WITH_MD5 = 196736, PJ_SSL_CK_RC2_128_CBC_EXPORT40_WITH_MD5 = 262272, PJ_SSL_CK_IDEA_128_CBC_WITH_MD5 = 327808, PJ_SSL_CK_DES_64_CBC_WITH_MD5 = 393280, PJ_SSL_CK_DES_192_EDE3_CBC_WITH_MD5 = 458944 }

extern "C" { pub fn pj_ssl_cipher_get_availables(ciphers: *mut pj_ssl_cipher, cipher_num: *mut ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pj_ssl_cipher_is_supported(cipher: pj_ssl_cipher) -> pj_bool_t; }

extern "C" { pub fn pj_ssl_cipher_name(cipher: pj_ssl_cipher) -> *const ::std::os::raw::c_char; }

extern "C" { pub fn pj_ssl_cipher_id(cipher_name: *const ::std::os::raw::c_char) -> pj_ssl_cipher; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_ssl_curve { PJ_TLS_UNKNOWN_CURVE = 0, PJ_TLS_CURVE_SECT163K1 = 1, PJ_TLS_CURVE_SECT163R1 = 2, PJ_TLS_CURVE_SECT163R2 = 3, PJ_TLS_CURVE_SECT193R1 = 4, PJ_TLS_CURVE_SECT193R2 = 5, PJ_TLS_CURVE_SECT233K1 = 6, PJ_TLS_CURVE_SECT233R1 = 7, PJ_TLS_CURVE_SECT239K1 = 8, PJ_TLS_CURVE_SECT283K1 = 9, PJ_TLS_CURVE_SECT283R1 = 10, PJ_TLS_CURVE_SECT409K1 = 11, PJ_TLS_CURVE_SECT409R1 = 12, PJ_TLS_CURVE_SECT571K1 = 13, PJ_TLS_CURVE_SECT571R1 = 14, PJ_TLS_CURVE_SECP160K1 = 15, PJ_TLS_CURVE_SECP160R1 = 16, PJ_TLS_CURVE_SECP160R2 = 17, PJ_TLS_CURVE_SECP192K1 = 18, PJ_TLS_CURVE_SECP192R1 = 19, PJ_TLS_CURVE_SECP224K1 = 20, PJ_TLS_CURVE_SECP224R1 = 21, PJ_TLS_CURVE_SECP256K1 = 22, PJ_TLS_CURVE_SECP256R1 = 23, PJ_TLS_CURVE_SECP384R1 = 24, PJ_TLS_CURVE_SECP521R1 = 25, PJ_TLS_CURVE_BRAINPOOLP256R1 = 26, PJ_TLS_CURVE_BRAINPOOLP384R1 = 27, PJ_TLS_CURVE_BRAINPOOLP512R1 = 28, PJ_TLS_CURVE_ARBITRARY_EXPLICIT_PRIME_CURVES = 65281, PJ_TLS_CURVE_ARBITRARY_EXPLICIT_CHAR2_CURVES = 65282 }

extern "C" { pub fn pj_ssl_curve_get_availables(curves: *mut pj_ssl_curve, curve_num: *mut ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pj_ssl_curve_is_supported(curve: pj_ssl_curve) -> pj_bool_t; }

extern "C" { pub fn pj_ssl_curve_name(curve: pj_ssl_curve) -> *const ::std::os::raw::c_char; }

extern "C" { pub fn pj_ssl_curve_id(curve_name: *const ::std::os::raw::c_char) -> pj_ssl_curve; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_ssl_entropy { PJ_SSL_ENTROPY_NONE = 0, PJ_SSL_ENTROPY_EGD = 1, PJ_SSL_ENTROPY_RANDOM = 2, PJ_SSL_ENTROPY_URANDOM = 3, PJ_SSL_ENTROPY_FILE = 4, PJ_SSL_ENTROPY_UNKNOWN = 15 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_ssl_sock_cb { pub on_data_read: ::std::option::Option<unsafe extern "C" fn(ssock: *mut pj_ssl_sock_t, data: *mut ::std::os::raw::c_void, size: pj_size_t, status: pj_status_t, remainder: *mut pj_size_t) -> pj_bool_t>, pub on_data_recvfrom: ::std::option::Option<unsafe extern "C" fn(ssock: *mut pj_ssl_sock_t, data: *mut ::std::os::raw::c_void, size: pj_size_t, src_addr: *const pj_sockaddr_t, addr_len: ::std::os::raw::c_int, status: pj_status_t) -> pj_bool_t>, pub on_data_sent: ::std::option::Option<unsafe extern "C" fn(ssock: *mut pj_ssl_sock_t, send_key: *mut pj_ioqueue_op_key_t, sent: pj_ssize_t) -> pj_bool_t>, pub on_accept_complete: ::std::option::Option<unsafe extern "C" fn(ssock: *mut pj_ssl_sock_t, newsock: *mut pj_ssl_sock_t, src_addr: *const pj_sockaddr_t, src_addr_len: ::std::os::raw::c_int) -> pj_bool_t>, pub on_connect_complete: ::std::option::Option<unsafe extern "C" fn(ssock: *mut pj_ssl_sock_t, status: pj_status_t) -> pj_bool_t> }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_ssl_sock_proto { PJ_SSL_SOCK_PROTO_DEFAULT = 0, PJ_SSL_SOCK_PROTO_SSL2 = 1, PJ_SSL_SOCK_PROTO_SSL3 = 2, PJ_SSL_SOCK_PROTO_TLS1 = 4, PJ_SSL_SOCK_PROTO_TLS1_1 = 8, PJ_SSL_SOCK_PROTO_TLS1_2 = 16, PJ_SSL_SOCK_PROTO_SSL23 = 65535, PJ_SSL_SOCK_PROTO_DTLS1 = 65536 }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pj_ssl_sock_info { pub established: pj_bool_t, pub proto: pj_uint32_t, pub cipher: pj_ssl_cipher, pub local_addr: pj_sockaddr, pub remote_addr: pj_sockaddr, pub local_cert_info: *mut pj_ssl_cert_info, pub remote_cert_info: *mut pj_ssl_cert_info, pub verify_status: pj_uint32_t, pub last_native_err: ::std::os::raw::c_ulong, pub grp_lock: *mut pj_grp_lock_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_ssl_sock_param { pub grp_lock: *mut pj_grp_lock_t, pub sock_af: ::std::os::raw::c_int, pub sock_type: ::std::os::raw::c_int, pub ioqueue: *mut pj_ioqueue_t, pub timer_heap: *mut pj_timer_heap_t, pub cb: pj_ssl_sock_cb, pub user_data: *mut ::std::os::raw::c_void, pub proto: pj_uint32_t, pub async_cnt: ::std::os::raw::c_uint, pub concurrency: ::std::os::raw::c_int, pub whole_data: pj_bool_t, pub send_buffer_size: pj_size_t, pub read_buffer_size: pj_size_t, pub ciphers_num: ::std::os::raw::c_uint, pub ciphers: *mut pj_ssl_cipher, pub curves_num: ::std::os::raw::c_uint, pub curves: *mut pj_ssl_curve, pub sigalgs: pj_str_t, pub entropy_type: pj_ssl_entropy_t, pub entropy_path: pj_str_t, pub timeout: pj_time_val, pub verify_peer: pj_bool_t, pub require_client_cert: pj_bool_t, pub server_name: pj_str_t, pub reuse_addr: pj_bool_t, pub qos_type: pj_qos_type, pub qos_params: pj_qos_params, pub qos_ignore_error: pj_bool_t, pub sockopt_params: pj_sockopt_params, pub sockopt_ignore_error: pj_bool_t }

extern "C" { pub fn pj_ssl_sock_param_default(param: *mut pj_ssl_sock_param); }

extern "C" { pub fn pj_ssl_sock_param_copy(pool: *mut pj_pool_t, dst: *mut pj_ssl_sock_param, src: *const pj_ssl_sock_param); }

extern "C" { pub fn pj_ssl_sock_create(pool: *mut pj_pool_t, param: *const pj_ssl_sock_param, p_ssock: *mut *mut pj_ssl_sock_t) -> pj_status_t; }

extern "C" { pub fn pj_ssl_sock_set_certificate(ssock: *mut pj_ssl_sock_t, pool: *mut pj_pool_t, cert: *const pj_ssl_cert_t) -> pj_status_t; }

extern "C" { pub fn pj_ssl_sock_close(ssock: *mut pj_ssl_sock_t) -> pj_status_t; }

extern "C" { pub fn pj_ssl_sock_set_user_data(ssock: *mut pj_ssl_sock_t, user_data: *mut ::std::os::raw::c_void) -> pj_status_t; }

extern "C" { pub fn pj_ssl_sock_get_user_data(ssock: *mut pj_ssl_sock_t) -> *mut ::std::os::raw::c_void; }

extern "C" { pub fn pj_ssl_sock_get_info(ssock: *mut pj_ssl_sock_t, info: *mut pj_ssl_sock_info) -> pj_status_t; }

extern "C" { pub fn pj_ssl_sock_start_read(ssock: *mut pj_ssl_sock_t, pool: *mut pj_pool_t, buff_size: ::std::os::raw::c_uint, flags: pj_uint32_t) -> pj_status_t; }

extern "C" { pub fn pj_ssl_sock_start_read2(ssock: *mut pj_ssl_sock_t, pool: *mut pj_pool_t, buff_size: ::std::os::raw::c_uint, readbuf: *mut *mut ::std::os::raw::c_void, flags: pj_uint32_t) -> pj_status_t; }

extern "C" { pub fn pj_ssl_sock_start_recvfrom(ssock: *mut pj_ssl_sock_t, pool: *mut pj_pool_t, buff_size: ::std::os::raw::c_uint, flags: pj_uint32_t) -> pj_status_t; }

extern "C" { pub fn pj_ssl_sock_start_recvfrom2(ssock: *mut pj_ssl_sock_t, pool: *mut pj_pool_t, buff_size: ::std::os::raw::c_uint, readbuf: *mut *mut ::std::os::raw::c_void, flags: pj_uint32_t) -> pj_status_t; }

extern "C" { pub fn pj_ssl_sock_send(ssock: *mut pj_ssl_sock_t, send_key: *mut pj_ioqueue_op_key_t, data: *const ::std::os::raw::c_void, size: *mut pj_ssize_t, flags: ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pj_ssl_sock_sendto(ssock: *mut pj_ssl_sock_t, send_key: *mut pj_ioqueue_op_key_t, data: *const ::std::os::raw::c_void, size: *mut pj_ssize_t, flags: ::std::os::raw::c_uint, addr: *const pj_sockaddr_t, addr_len: ::std::os::raw::c_int) -> pj_status_t; }

extern "C" { pub fn pj_ssl_sock_start_accept(ssock: *mut pj_ssl_sock_t, pool: *mut pj_pool_t, local_addr: *const pj_sockaddr_t, addr_len: ::std::os::raw::c_int) -> pj_status_t; }

extern "C" { pub fn pj_ssl_sock_start_accept2(ssock: *mut pj_ssl_sock_t, pool: *mut pj_pool_t, local_addr: *const pj_sockaddr_t, addr_len: ::std::os::raw::c_int, newsock_param: *const pj_ssl_sock_param) -> pj_status_t; }

extern "C" { pub fn pj_ssl_sock_start_connect(ssock: *mut pj_ssl_sock_t, pool: *mut pj_pool_t, localaddr: *const pj_sockaddr_t, remaddr: *const pj_sockaddr_t, addr_len: ::std::os::raw::c_int) -> pj_status_t; }

extern "C" { pub fn pj_ssl_sock_renegotiate(ssock: *mut pj_ssl_sock_t) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t { pub __val: [::std::os::raw::c_ulong; 32usize] }

extern "C" { pub fn pj_str(str: *mut ::std::os::raw::c_char) -> pj_str_t; }

extern "C" { pub fn pj_strassign(dst: *mut pj_str_t, src: *mut pj_str_t) -> *mut pj_str_t; }

extern "C" { pub fn pj_strcpy(dst: *mut pj_str_t, src: *const pj_str_t) -> *mut pj_str_t; }

extern "C" { pub fn pj_strcpy2(dst: *mut pj_str_t, src: *const ::std::os::raw::c_char) -> *mut pj_str_t; }

extern "C" { pub fn pj_strncpy(dst: *mut pj_str_t, src: *const pj_str_t, max: pj_ssize_t) -> *mut pj_str_t; }

extern "C" { pub fn pj_strncpy_with_null(dst: *mut pj_str_t, src: *const pj_str_t, max: pj_ssize_t) -> *mut pj_str_t; }

extern "C" { pub fn pj_strdup(pool: *mut pj_pool_t, dst: *mut pj_str_t, src: *const pj_str_t) -> *mut pj_str_t; }

extern "C" { pub fn pj_strdup_with_null(pool: *mut pj_pool_t, dst: *mut pj_str_t, src: *const pj_str_t) -> *mut pj_str_t; }

extern "C" { pub fn pj_strdup2(pool: *mut pj_pool_t, dst: *mut pj_str_t, src: *const ::std::os::raw::c_char) -> *mut pj_str_t; }

extern "C" { pub fn pj_strdup2_with_null(pool: *mut pj_pool_t, dst: *mut pj_str_t, src: *const ::std::os::raw::c_char) -> *mut pj_str_t; }

extern "C" { pub fn pj_strdup3(pool: *mut pj_pool_t, src: *const ::std::os::raw::c_char) -> pj_str_t; }

extern "C" { pub fn pj_strcmp(str1: *const pj_str_t, str2: *const pj_str_t) -> ::std::os::raw::c_int; }

extern "C" { pub fn pj_strcmp2(str1: *const pj_str_t, str2: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int; }

extern "C" { pub fn pj_strncmp(str1: *const pj_str_t, str2: *const pj_str_t, len: pj_size_t) -> ::std::os::raw::c_int; }

extern "C" { pub fn pj_strncmp2(str1: *const pj_str_t, str2: *const ::std::os::raw::c_char, len: pj_size_t) -> ::std::os::raw::c_int; }

extern "C" { pub fn pj_stricmp(str1: *const pj_str_t, str2: *const pj_str_t) -> ::std::os::raw::c_int; }

extern "C" { pub fn pj_stricmp2(str1: *const pj_str_t, str2: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int; }

extern "C" { pub fn pj_strnicmp(str1: *const pj_str_t, str2: *const pj_str_t, len: pj_size_t) -> ::std::os::raw::c_int; }

extern "C" { pub fn pj_strnicmp2(str1: *const pj_str_t, str2: *const ::std::os::raw::c_char, len: pj_size_t) -> ::std::os::raw::c_int; }

extern "C" { pub fn pj_strcat(dst: *mut pj_str_t, src: *const pj_str_t); }

extern "C" { pub fn pj_strcat2(dst: *mut pj_str_t, src: *const ::std::os::raw::c_char); }

extern "C" { pub fn pj_strspn(str: *const pj_str_t, set_char: *const pj_str_t) -> pj_ssize_t; }

extern "C" { pub fn pj_strspn2(str: *const pj_str_t, set_char: *const ::std::os::raw::c_char) -> pj_ssize_t; }

extern "C" { pub fn pj_strcspn(str: *const pj_str_t, set_char: *const pj_str_t) -> pj_ssize_t; }

extern "C" { pub fn pj_strcspn2(str: *const pj_str_t, set_char: *const ::std::os::raw::c_char) -> pj_ssize_t; }

extern "C" { pub fn pj_strtok(str: *const pj_str_t, delim: *const pj_str_t, tok: *mut pj_str_t, start_idx: pj_size_t) -> pj_ssize_t; }

extern "C" { pub fn pj_strtok2(str: *const pj_str_t, delim: *const ::std::os::raw::c_char, tok: *mut pj_str_t, start_idx: pj_size_t) -> pj_ssize_t; }

extern "C" { pub fn pj_strstr(str: *const pj_str_t, substr: *const pj_str_t) -> *mut ::std::os::raw::c_char; }

extern "C" { pub fn pj_stristr(str: *const pj_str_t, substr: *const pj_str_t) -> *mut ::std::os::raw::c_char; }

extern "C" { pub fn pj_strltrim(str: *mut pj_str_t) -> *mut pj_str_t; }

extern "C" { pub fn pj_strrtrim(str: *mut pj_str_t) -> *mut pj_str_t; }

extern "C" { pub fn pj_strtrim(str: *mut pj_str_t) -> *mut pj_str_t; }

extern "C" { pub fn pj_create_random_string(str: *mut ::std::os::raw::c_char, length: pj_size_t) -> *mut ::std::os::raw::c_char; }

extern "C" { pub fn pj_strtol(str: *const pj_str_t) -> ::std::os::raw::c_long; }

extern "C" { pub fn pj_strtol2(str: *const pj_str_t, value: *mut ::std::os::raw::c_long) -> pj_status_t; }

extern "C" { pub fn pj_strtoul(str: *const pj_str_t) -> ::std::os::raw::c_ulong; }

extern "C" { pub fn pj_strtoul2(str: *const pj_str_t, endptr: *mut pj_str_t, base: ::std::os::raw::c_uint) -> ::std::os::raw::c_ulong; }

extern "C" { pub fn pj_strtoul3(str: *const pj_str_t, value: *mut ::std::os::raw::c_ulong, base: ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pj_strtof(str: *const pj_str_t) -> f32; }

extern "C" { pub fn pj_utoa(val: ::std::os::raw::c_ulong, buf: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int; }

extern "C" { pub fn pj_utoa_pad(val: ::std::os::raw::c_ulong, buf: *mut ::std::os::raw::c_char, min_dig: ::std::os::raw::c_int, pad: ::std::os::raw::c_int) -> ::std::os::raw::c_int; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsip_ssl_method { PJSIP_SSL_UNSPECIFIED_METHOD = 0, PJSIP_SSLV2_METHOD = 20, PJSIP_SSLV3_METHOD = 30, PJSIP_TLSV1_METHOD = 31, PJSIP_TLSV1_1_METHOD = 32, PJSIP_TLSV1_2_METHOD = 33, PJSIP_SSLV23_METHOD = 23 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_tls_setting { pub ca_list_file: pj_str_t, pub ca_list_path: pj_str_t, pub cert_file: pj_str_t, pub privkey_file: pj_str_t, pub password: pj_str_t, pub method: pjsip_ssl_method, pub proto: pj_uint32_t, pub ciphers_num: ::std::os::raw::c_uint, pub ciphers: *mut pj_ssl_cipher, pub curves_num: ::std::os::raw::c_uint, pub curves: *mut pj_ssl_curve, pub sigalgs: pj_str_t, pub entropy_type: pj_ssl_entropy_t, pub entropy_path: pj_str_t, pub verify_server: pj_bool_t, pub verify_client: pj_bool_t, pub require_client_cert: pj_bool_t, pub timeout: pj_time_val, pub reuse_addr: pj_bool_t, pub qos_type: pj_qos_type, pub qos_params: pj_qos_params, pub qos_ignore_error: pj_bool_t, pub sockopt_params: pj_sockopt_params, pub sockopt_ignore_error: pj_bool_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_tls_state_info { pub ssl_sock_info: *mut pj_ssl_sock_info }

extern "C" { pub fn pjsip_tls_transport_start(endpt: *mut pjsip_endpoint, opt: *const pjsip_tls_setting, local: *const pj_sockaddr_in, a_name: *const pjsip_host_port, async_cnt: ::std::os::raw::c_uint, p_factory: *mut *mut pjsip_tpfactory) -> pj_status_t; }

extern "C" { pub fn pjsip_tls_transport_start2(endpt: *mut pjsip_endpoint, opt: *const pjsip_tls_setting, local: *const pj_sockaddr, a_name: *const pjsip_host_port, async_cnt: ::std::os::raw::c_uint, p_factory: *mut *mut pjsip_tpfactory) -> pj_status_t; }

extern "C" { pub fn pjsip_tls_transport_lis_start(factory: *mut pjsip_tpfactory, local: *const pj_sockaddr, a_name: *const pjsip_host_port) -> pj_status_t; }

extern "C" { pub fn pjsip_tls_transport_restart(factory: *mut pjsip_tpfactory, local: *const pj_sockaddr, a_name: *const pjsip_host_port) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_common_credential { pub realm: pj_str_t, pub other_param: pjsip_param }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_digest_credential { pub realm: pj_str_t, pub other_param: pjsip_param, pub username: pj_str_t, pub nonce: pj_str_t, pub uri: pj_str_t, pub response: pj_str_t, pub algorithm: pj_str_t, pub cnonce: pj_str_t, pub opaque: pj_str_t, pub qop: pj_str_t, pub nc: pj_str_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_pgp_credential { pub realm: pj_str_t, pub other_param: pjsip_param, pub version: pj_str_t, pub signature: pj_str_t, pub signed_by: pj_str_t, pub nonce: pj_str_t }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsip_authorization_hdr { pub prev: *mut pjsip_authorization_hdr, pub next: *mut pjsip_authorization_hdr, pub type_: pjsip_hdr_e, pub name: pj_str_t, pub sname: pj_str_t, pub vptr: *mut pjsip_hdr_vptr, pub scheme: pj_str_t, pub credential: pjsip_authorization_hdr__bindgen_ty_1 }

#[repr(C)]
#[derive(Copy, Clone)]
pub union pjsip_authorization_hdr__bindgen_ty_1 { pub common: pjsip_common_credential, pub digest: pjsip_digest_credential, pub pgp: pjsip_pgp_credential, _bindgen_union_align: [u32; 26usize] }

pub type pjsip_proxy_authorization_hdr = pjsip_authorization_hdr;

extern "C" { pub fn pjsip_authorization_hdr_create(pool: *mut pj_pool_t) -> *mut pjsip_authorization_hdr; }

extern "C" { pub fn pjsip_proxy_authorization_hdr_create(pool: *mut pj_pool_t) -> *mut pjsip_proxy_authorization_hdr; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_common_challenge { pub realm: pj_str_t, pub other_param: pjsip_param }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_digest_challenge { pub realm: pj_str_t, pub other_param: pjsip_param, pub domain: pj_str_t, pub nonce: pj_str_t, pub opaque: pj_str_t, pub stale: ::std::os::raw::c_int, pub algorithm: pj_str_t, pub qop: pj_str_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_pgp_challenge { pub realm: pj_str_t, pub other_param: pjsip_param, pub version: pj_str_t, pub micalgorithm: pj_str_t, pub pubalgorithm: pj_str_t, pub nonce: pj_str_t }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsip_www_authenticate_hdr { pub prev: *mut pjsip_www_authenticate_hdr, pub next: *mut pjsip_www_authenticate_hdr, pub type_: pjsip_hdr_e, pub name: pj_str_t, pub sname: pj_str_t, pub vptr: *mut pjsip_hdr_vptr, pub scheme: pj_str_t, pub challenge: pjsip_www_authenticate_hdr__bindgen_ty_1 }

#[repr(C)]
#[derive(Copy, Clone)]
pub union pjsip_www_authenticate_hdr__bindgen_ty_1 { pub common: pjsip_common_challenge, pub digest: pjsip_digest_challenge, pub pgp: pjsip_pgp_challenge, _bindgen_union_align: [u32; 19usize] }

pub type pjsip_proxy_authenticate_hdr = pjsip_www_authenticate_hdr;

extern "C" { pub fn pjsip_www_authenticate_hdr_create(pool: *mut pj_pool_t) -> *mut pjsip_www_authenticate_hdr; }

extern "C" { pub fn pjsip_proxy_authenticate_hdr_create(pool: *mut pj_pool_t) -> *mut pjsip_proxy_authenticate_hdr; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsip_cred_data_type { PJSIP_CRED_DATA_PLAIN_PASSWD = 0, PJSIP_CRED_DATA_DIGEST = 1, PJSIP_CRED_DATA_EXT_AKA = 16 }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsip_auth_qop_type { PJSIP_AUTH_QOP_NONE = 0, PJSIP_AUTH_QOP_AUTH = 1, PJSIP_AUTH_QOP_AUTH_INT = 2, PJSIP_AUTH_QOP_UNKNOWN = 3 }

pub type pjsip_cred_cb = ::std::option::Option<unsafe extern "C" fn(pool: *mut pj_pool_t, chal: *const pjsip_digest_challenge, cred: *const pjsip_cred_info, method: *const pj_str_t, auth: *mut pjsip_digest_credential) -> pj_status_t>;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsip_cred_info { pub realm: pj_str_t, pub scheme: pj_str_t, pub username: pj_str_t, pub data_type: ::std::os::raw::c_int, pub data: pj_str_t, pub ext: pjsip_cred_info__bindgen_ty_1 }

#[repr(C)]
#[derive(Copy, Clone)]
pub union pjsip_cred_info__bindgen_ty_1 { pub aka: pjsip_cred_info__bindgen_ty_1__bindgen_ty_1, _bindgen_union_align: [u32; 7usize] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_cred_info__bindgen_ty_1__bindgen_ty_1 { pub k: pj_str_t, pub op: pj_str_t, pub amf: pj_str_t, pub cb: pjsip_cred_cb }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_cached_auth_hdr { pub prev: *mut pjsip_cached_auth_hdr, pub next: *mut pjsip_cached_auth_hdr, pub method: pjsip_method, pub hdr: *mut pjsip_authorization_hdr }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_cached_auth { pub prev: *mut pjsip_cached_auth, pub next: *mut pjsip_cached_auth, pub pool: *mut pj_pool_t, pub realm: pj_str_t, pub is_proxy: pj_bool_t, pub qop_value: pjsip_auth_qop_type, pub stale_cnt: ::std::os::raw::c_uint, pub nc: pj_uint32_t, pub cnonce: pj_str_t, pub last_chal: *mut pjsip_www_authenticate_hdr }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_auth_clt_pref { pub initial_auth: pj_bool_t, pub algorithm: pj_str_t }

extern "C" { pub fn pjsip_auth_clt_pref_dup(pool: *mut pj_pool_t, dst: *mut pjsip_auth_clt_pref, src: *const pjsip_auth_clt_pref); }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_auth_clt_sess { pub pool: *mut pj_pool_t, pub endpt: *mut pjsip_endpoint, pub pref: pjsip_auth_clt_pref, pub cred_cnt: ::std::os::raw::c_uint, pub cred_info: *mut pjsip_cred_info, pub cached_auth: pjsip_cached_auth }

extern "C" { pub fn pjsip_cred_info_dup(pool: *mut pj_pool_t, dst: *mut pjsip_cred_info, src: *const pjsip_cred_info); }

extern "C" { pub fn pjsip_cred_info_cmp(cred1: *const pjsip_cred_info, cred2: *const pjsip_cred_info) -> ::std::os::raw::c_int; }

pub type pjsip_auth_lookup_cred = ::std::option::Option<unsafe extern "C" fn(pool: *mut pj_pool_t, realm: *const pj_str_t, acc_name: *const pj_str_t, cred_info: *mut pjsip_cred_info) -> pj_status_t>;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_auth_lookup_cred_param { pub realm: pj_str_t, pub acc_name: pj_str_t, pub rdata: *mut pjsip_rx_data }

pub type pjsip_auth_lookup_cred2 = ::std::option::Option<unsafe extern "C" fn(pool: *mut pj_pool_t, param: *const pjsip_auth_lookup_cred_param, cred_info: *mut pjsip_cred_info) -> pj_status_t>;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_auth_srv { pub realm: pj_str_t, pub is_proxy: pj_bool_t, pub lookup: pjsip_auth_lookup_cred, pub lookup2: pjsip_auth_lookup_cred2 }

extern "C" { pub fn pjsip_auth_clt_init(sess: *mut pjsip_auth_clt_sess, endpt: *mut pjsip_endpoint, pool: *mut pj_pool_t, options: ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pjsip_auth_clt_deinit(sess: *mut pjsip_auth_clt_sess) -> pj_status_t; }

extern "C" { pub fn pjsip_auth_clt_clone(pool: *mut pj_pool_t, sess: *mut pjsip_auth_clt_sess, rhs: *const pjsip_auth_clt_sess) -> pj_status_t; }

extern "C" { pub fn pjsip_auth_clt_set_credentials(sess: *mut pjsip_auth_clt_sess, cred_cnt: ::std::os::raw::c_int, c: *const pjsip_cred_info) -> pj_status_t; }

extern "C" { pub fn pjsip_auth_clt_set_prefs(sess: *mut pjsip_auth_clt_sess, p: *const pjsip_auth_clt_pref) -> pj_status_t; }

extern "C" { pub fn pjsip_auth_clt_get_prefs(sess: *mut pjsip_auth_clt_sess, p: *mut pjsip_auth_clt_pref) -> pj_status_t; }

extern "C" { pub fn pjsip_auth_clt_init_req(sess: *mut pjsip_auth_clt_sess, tdata: *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_auth_clt_reinit_req(sess: *mut pjsip_auth_clt_sess, rdata: *const pjsip_rx_data, old_request: *mut pjsip_tx_data, new_request: *mut *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_auth_srv_init(pool: *mut pj_pool_t, auth_srv: *mut pjsip_auth_srv, realm: *const pj_str_t, lookup: pjsip_auth_lookup_cred, options: ::std::os::raw::c_uint) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_auth_srv_init_param { pub realm: *const pj_str_t, pub lookup2: pjsip_auth_lookup_cred2, pub options: ::std::os::raw::c_uint }

extern "C" { pub fn pjsip_auth_srv_init2(pool: *mut pj_pool_t, auth_srv: *mut pjsip_auth_srv, param: *const pjsip_auth_srv_init_param) -> pj_status_t; }

extern "C" { pub fn pjsip_auth_srv_verify(auth_srv: *mut pjsip_auth_srv, rdata: *mut pjsip_rx_data, status_code: *mut ::std::os::raw::c_int) -> pj_status_t; }

extern "C" { pub fn pjsip_auth_srv_challenge(auth_srv: *mut pjsip_auth_srv, qop: *const pj_str_t, nonce: *const pj_str_t, opaque: *const pj_str_t, stale: pj_bool_t, tdata: *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_auth_create_digest(result: *mut pj_str_t, nonce: *const pj_str_t, nc: *const pj_str_t, cnonce: *const pj_str_t, qop: *const pj_str_t, uri: *const pj_str_t, realm: *const pj_str_t, cred_info: *const pjsip_cred_info, method: *const pj_str_t); }

extern "C" { pub fn pjsip_auth_create_aka_response(pool: *mut pj_pool_t, chal: *const pjsip_digest_challenge, cred: *const pjsip_cred_info, method: *const pj_str_t, auth: *mut pjsip_digest_credential) -> pj_status_t; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsip_tsx_state_e { PJSIP_TSX_STATE_NULL = 0, PJSIP_TSX_STATE_CALLING = 1, PJSIP_TSX_STATE_TRYING = 2, PJSIP_TSX_STATE_PROCEEDING = 3, PJSIP_TSX_STATE_COMPLETED = 4, PJSIP_TSX_STATE_CONFIRMED = 5, PJSIP_TSX_STATE_TERMINATED = 6, PJSIP_TSX_STATE_DESTROYED = 7, PJSIP_TSX_STATE_MAX = 8 }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsip_transaction { pub pool: *mut pj_pool_t, pub tsx_user: *mut pjsip_module, pub endpt: *mut pjsip_endpoint, pub terminating: pj_bool_t, pub grp_lock: *mut pj_grp_lock_t, pub mutex_b: *mut pj_mutex_t, pub obj_name: [::std::os::raw::c_char; 32usize], pub role: pjsip_role_e, pub method: pjsip_method, pub cseq: pj_int32_t, pub transaction_key: pj_str_t, pub hashed_key: pj_uint32_t, pub branch: pj_str_t, pub status_code: ::std::os::raw::c_int, pub status_text: pj_str_t, pub state: pjsip_tsx_state_e, pub handle_200resp: ::std::os::raw::c_int, pub tracing: ::std::os::raw::c_int, pub state_handler: ::std::option::Option<unsafe extern "C" fn(arg1: *mut pjsip_transaction, arg2: *mut pjsip_event) -> pj_status_t>, pub transport: *mut pjsip_transport, pub is_reliable: pj_bool_t, pub addr: pj_sockaddr, pub addr_len: ::std::os::raw::c_int, pub res_addr: pjsip_response_addr, pub transport_flag: ::std::os::raw::c_uint, pub transport_err: pj_status_t, pub tp_sel: pjsip_tpselector, pub pending_tx: *mut pjsip_tx_data, pub tp_st_key: *mut pjsip_tp_state_listener_key, pub last_tx: *mut pjsip_tx_data, pub retransmit_count: ::std::os::raw::c_int, pub retransmit_timer: pj_timer_entry, pub timeout_timer: pj_timer_entry, pub mod_data: [*mut ::std::os::raw::c_void; 32usize] }

extern "C" { pub fn pjsip_tsx_layer_init_module(endpt: *mut pjsip_endpoint) -> pj_status_t; }

extern "C" { pub fn pjsip_tsx_layer_instance() -> *mut pjsip_module; }

extern "C" { pub fn pjsip_tsx_layer_destroy() -> pj_status_t; }

extern "C" { pub fn pjsip_tsx_layer_get_tsx_count() -> ::std::os::raw::c_uint; }

extern "C" { pub fn pjsip_tsx_layer_find_tsx(key: *const pj_str_t, lock: pj_bool_t) -> *mut pjsip_transaction; }

extern "C" { pub fn pjsip_tsx_layer_find_tsx2(key: *const pj_str_t, add_ref: pj_bool_t) -> *mut pjsip_transaction; }

extern "C" { pub fn pjsip_tsx_create_uac(tsx_user: *mut pjsip_module, tdata: *mut pjsip_tx_data, p_tsx: *mut *mut pjsip_transaction) -> pj_status_t; }

extern "C" { pub fn pjsip_tsx_create_uac2(tsx_user: *mut pjsip_module, tdata: *mut pjsip_tx_data, grp_lock: *mut pj_grp_lock_t, p_tsx: *mut *mut pjsip_transaction) -> pj_status_t; }

extern "C" { pub fn pjsip_tsx_create_uas(tsx_user: *mut pjsip_module, rdata: *mut pjsip_rx_data, p_tsx: *mut *mut pjsip_transaction) -> pj_status_t; }

extern "C" { pub fn pjsip_tsx_create_uas2(tsx_user: *mut pjsip_module, rdata: *mut pjsip_rx_data, grp_lock: *mut pj_grp_lock_t, p_tsx: *mut *mut pjsip_transaction) -> pj_status_t; }

extern "C" { pub fn pjsip_tsx_set_transport(tsx: *mut pjsip_transaction, sel: *const pjsip_tpselector) -> pj_status_t; }

extern "C" { pub fn pjsip_tsx_recv_msg(tsx: *mut pjsip_transaction, rdata: *mut pjsip_rx_data); }

extern "C" { pub fn pjsip_tsx_send_msg(tsx: *mut pjsip_transaction, tdata: *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_tsx_retransmit_no_state(tsx: *mut pjsip_transaction, tdata: *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_tsx_create_key(pool: *mut pj_pool_t, key: *mut pj_str_t, role: pjsip_role_e, method: *const pjsip_method, rdata: *const pjsip_rx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_tsx_terminate(tsx: *mut pjsip_transaction, code: ::std::os::raw::c_int) -> pj_status_t; }

extern "C" { pub fn pjsip_tsx_stop_retransmit(tsx: *mut pjsip_transaction) -> pj_status_t; }

extern "C" { pub fn pjsip_tsx_set_timeout(tsx: *mut pjsip_transaction, millisec: ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pjsip_rdata_get_tsx(rdata: *mut pjsip_rx_data) -> *mut pjsip_transaction; }

extern "C" { pub fn pjsip_tsx_layer_dump(detail: pj_bool_t); }

extern "C" { pub fn pjsip_tsx_state_str(state: pjsip_tsx_state_e) -> *const ::std::os::raw::c_char; }

extern "C" { pub fn pjsip_role_name(role: pjsip_role_e) -> *const ::std::os::raw::c_char; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_ua_init_param { pub on_dlg_forked: ::std::option::Option<unsafe extern "C" fn(first_set: *mut pjsip_dialog, res: *mut pjsip_rx_data) -> *mut pjsip_dialog> }

extern "C" { pub fn pjsip_ua_init_module(endpt: *mut pjsip_endpoint, prm: *const pjsip_ua_init_param) -> pj_status_t; }

extern "C" { pub fn pjsip_ua_instance() -> *mut pjsip_user_agent; }

extern "C" { pub fn pjsip_ua_get_dlg_set_count() -> pj_uint32_t; }

extern "C" { pub fn pjsip_ua_find_dialog(call_id: *const pj_str_t, local_tag: *const pj_str_t, remote_tag: *const pj_str_t, lock_dialog: pj_bool_t) -> *mut pjsip_dialog; }

extern "C" { pub fn pjsip_ua_destroy() -> pj_status_t; }

extern "C" { pub fn pjsip_ua_dump(detail: pj_bool_t); }

extern "C" { pub fn pjsip_ua_get_endpt(ua: *mut pjsip_user_agent) -> *mut pjsip_endpoint; }

extern "C" { pub fn pjsip_ua_register_dlg(ua: *mut pjsip_user_agent, dlg: *mut pjsip_dialog) -> pj_status_t; }

extern "C" { pub fn pjsip_ua_unregister_dlg(ua: *mut pjsip_user_agent, dlg: *mut pjsip_dialog) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_dlg_party { pub info: *mut pjsip_fromto_hdr, pub info_str: pj_str_t, pub tag_hval: pj_uint32_t, pub contact: *mut pjsip_contact_hdr, pub first_cseq: pj_int32_t, pub cseq: pj_int32_t }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsip_dialog_state { PJSIP_DIALOG_STATE_NULL = 0, PJSIP_DIALOG_STATE_ESTABLISHED = 1 }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsip_dialog_cap_status { PJSIP_DIALOG_CAP_UNSUPPORTED = 0, PJSIP_DIALOG_CAP_SUPPORTED = 1, PJSIP_DIALOG_CAP_UNKNOWN = 2 }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsip_dialog { pub prev: *mut pjsip_dialog, pub next: *mut pjsip_dialog, pub obj_name: [::std::os::raw::c_char; 32usize], pub pool: *mut pj_pool_t, pub mutex_: *mut pj_mutex_t, pub ua: *mut pjsip_user_agent, pub endpt: *mut pjsip_endpoint, pub dlg_set: *mut ::std::os::raw::c_void, pub state: pjsip_dialog_state, pub target: *mut pjsip_uri, pub target_set: pjsip_target_set, pub inv_hdr: pjsip_hdr, pub local: pjsip_dlg_party, pub remote: pjsip_dlg_party, pub rem_cap_hdr: pjsip_hdr, pub role: pjsip_role_e, pub uac_has_2xx: pj_bool_t, pub secure: pj_bool_t, pub add_allow: pj_bool_t, pub call_id: *mut pjsip_cid_hdr, pub route_set: pjsip_route_hdr, pub route_set_frozen: pj_bool_t, pub auth_sess: pjsip_auth_clt_sess, pub sess_count: ::std::os::raw::c_int, pub tsx_count: ::std::os::raw::c_int, pub tp_sel: pjsip_tpselector, pub usage_cnt: ::std::os::raw::c_uint, pub usage: [*mut pjsip_module; 32usize], pub mod_data: [*mut ::std::os::raw::c_void; 32usize], pub via_addr: pjsip_host_port, pub via_tp: *const ::std::os::raw::c_void }

extern "C" { pub fn pjsip_method_creates_dialog(m: *const pjsip_method) -> pj_bool_t; }

extern "C" { pub fn pjsip_dlg_create_uac(ua: *mut pjsip_user_agent, local_uri: *const pj_str_t, local_contact: *const pj_str_t, remote_uri: *const pj_str_t, target: *const pj_str_t, p_dlg: *mut *mut pjsip_dialog) -> pj_status_t; }

extern "C" { pub fn pjsip_dlg_create_uas_and_inc_lock(ua: *mut pjsip_user_agent, rdata: *mut pjsip_rx_data, contact: *const pj_str_t, p_dlg: *mut *mut pjsip_dialog) -> pj_status_t; }

extern "C" { pub fn pjsip_dlg_set_transport(dlg: *mut pjsip_dialog, sel: *const pjsip_tpselector) -> pj_status_t; }

extern "C" { pub fn pjsip_dlg_set_via_sent_by(dlg: *mut pjsip_dialog, via_addr: *mut pjsip_host_port, via_tp: *mut pjsip_transport) -> pj_status_t; }

extern "C" { pub fn pjsip_dlg_fork(original_dlg: *const pjsip_dialog, rdata: *const pjsip_rx_data, new_dlg: *mut *mut pjsip_dialog) -> pj_status_t; }

extern "C" { pub fn pjsip_dlg_terminate(dlg: *mut pjsip_dialog) -> pj_status_t; }

extern "C" { pub fn pjsip_dlg_set_route_set(dlg: *mut pjsip_dialog, route_set: *const pjsip_route_hdr) -> pj_status_t; }

extern "C" { pub fn pjsip_dlg_inc_session(dlg: *mut pjsip_dialog, mod_: *mut pjsip_module) -> pj_status_t; }

extern "C" { pub fn pjsip_dlg_dec_session(dlg: *mut pjsip_dialog, mod_: *mut pjsip_module) -> pj_status_t; }

extern "C" { pub fn pjsip_dlg_add_usage(dlg: *mut pjsip_dialog, module: *mut pjsip_module, mod_data: *mut ::std::os::raw::c_void) -> pj_status_t; }

extern "C" { pub fn pjsip_dlg_has_usage(dlg: *mut pjsip_dialog, module: *mut pjsip_module) -> pj_bool_t; }

extern "C" { pub fn pjsip_dlg_set_mod_data(dlg: *mut pjsip_dialog, mod_id: ::std::os::raw::c_int, data: *mut ::std::os::raw::c_void) -> pj_status_t; }

extern "C" { pub fn pjsip_dlg_get_mod_data(dlg: *mut pjsip_dialog, mod_id: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_void; }

extern "C" { pub fn pjsip_dlg_inc_lock(dlg: *mut pjsip_dialog); }

extern "C" { pub fn pjsip_dlg_try_inc_lock(dlg: *mut pjsip_dialog) -> pj_status_t; }

extern "C" { pub fn pjsip_dlg_dec_lock(dlg: *mut pjsip_dialog); }

extern "C" { pub fn pjsip_rdata_get_dlg(rdata: *mut pjsip_rx_data) -> *mut pjsip_dialog; }

extern "C" { pub fn pjsip_tdata_get_dlg(tdata: *mut pjsip_tx_data) -> *mut pjsip_dialog; }

extern "C" { pub fn pjsip_tsx_get_dlg(tsx: *mut pjsip_transaction) -> *mut pjsip_dialog; }

extern "C" { pub fn pjsip_dlg_create_request(dlg: *mut pjsip_dialog, method: *const pjsip_method, cseq: ::std::os::raw::c_int, tdata: *mut *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_dlg_send_request(dlg: *mut pjsip_dialog, tdata: *mut pjsip_tx_data, mod_data_id: ::std::os::raw::c_int, mod_data: *mut ::std::os::raw::c_void) -> pj_status_t; }

extern "C" { pub fn pjsip_dlg_create_response(dlg: *mut pjsip_dialog, rdata: *mut pjsip_rx_data, st_code: ::std::os::raw::c_int, st_text: *const pj_str_t, tdata: *mut *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_dlg_modify_response(dlg: *mut pjsip_dialog, tdata: *mut pjsip_tx_data, st_code: ::std::os::raw::c_int, st_text: *const pj_str_t) -> pj_status_t; }

extern "C" { pub fn pjsip_dlg_send_response(dlg: *mut pjsip_dialog, tsx: *mut pjsip_transaction, tdata: *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_dlg_respond(dlg: *mut pjsip_dialog, rdata: *mut pjsip_rx_data, st_code: ::std::os::raw::c_int, st_text: *const pj_str_t, hdr_list: *const pjsip_hdr, body: *const pjsip_msg_body) -> pj_status_t; }

extern "C" { pub fn pjsip_dlg_remote_has_cap(dlg: *mut pjsip_dialog, htype: ::std::os::raw::c_int, hname: *const pj_str_t, token: *const pj_str_t) -> pjsip_dialog_cap_status; }

extern "C" { pub fn pjsip_dlg_get_remote_cap_hdr(dlg: *mut pjsip_dialog, htype: ::std::os::raw::c_int, hname: *const pj_str_t) -> *const pjsip_hdr; }

extern "C" { pub fn pjsip_dlg_set_remote_cap_hdr(dlg: *mut pjsip_dialog, cap_hdr: *const pjsip_generic_array_hdr) -> pj_status_t; }

extern "C" { pub fn pjsip_dlg_remove_remote_cap_hdr(dlg: *mut pjsip_dialog, htype: ::std::os::raw::c_int, hname: *const pj_str_t) -> pj_status_t; }

extern "C" { pub fn pjsip_dlg_update_remote_cap(dlg: *mut pjsip_dialog, msg: *const pjsip_msg, strict: pj_bool_t) -> pj_status_t; }

extern "C" { pub fn pjsip_dlg_on_tsx_state(dlg: *mut pjsip_dialog, tsx: *mut pjsip_transaction, e: *mut pjsip_event); }

extern "C" { pub fn pjsip_dlg_on_rx_request(dlg: *mut pjsip_dialog, rdata: *mut pjsip_rx_data); }

extern "C" { pub fn pjsip_dlg_on_rx_response(dlg: *mut pjsip_dialog, rdata: *mut pjsip_rx_data); }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_type { PJMEDIA_TYPE_NONE = 0, PJMEDIA_TYPE_AUDIO = 1, PJMEDIA_TYPE_VIDEO = 2, PJMEDIA_TYPE_APPLICATION = 3, PJMEDIA_TYPE_UNKNOWN = 4 }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_tp_proto { PJMEDIA_TP_PROTO_NONE = 0, PJMEDIA_TP_PROTO_RTP_AVP = 1, PJMEDIA_TP_PROTO_RTP_SAVP = 2, PJMEDIA_TP_PROTO_UNKNOWN = 3 }

impl pjmedia_dir { pub const PJMEDIA_DIR_CAPTURE: pjmedia_dir = pjmedia_dir::PJMEDIA_DIR_ENCODING; }

impl pjmedia_dir { pub const PJMEDIA_DIR_PLAYBACK: pjmedia_dir = pjmedia_dir::PJMEDIA_DIR_DECODING; }

impl pjmedia_dir { pub const PJMEDIA_DIR_RENDER: pjmedia_dir = pjmedia_dir::PJMEDIA_DIR_DECODING; }

impl pjmedia_dir { pub const PJMEDIA_DIR_CAPTURE_PLAYBACK: pjmedia_dir = pjmedia_dir::PJMEDIA_DIR_ENCODING_DECODING; }

impl pjmedia_dir { pub const PJMEDIA_DIR_CAPTURE_RENDER: pjmedia_dir = pjmedia_dir::PJMEDIA_DIR_ENCODING_DECODING; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_dir { PJMEDIA_DIR_NONE = 0, PJMEDIA_DIR_ENCODING = 1, PJMEDIA_DIR_DECODING = 2, PJMEDIA_DIR_ENCODING_DECODING = 3 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_endpt { _unused: [u8; 0] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_stream { _unused: [u8; 0] }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_coord_base { PJMEDIA_COORD_BASE_LEFT_TOP = 0, PJMEDIA_COORD_BASE_LEFT_BOTTOM = 1 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_ratio { pub num: ::std::os::raw::c_int, pub denum: ::std::os::raw::c_int }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_coord { pub x: ::std::os::raw::c_int, pub y: ::std::os::raw::c_int }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_rect_size { pub w: ::std::os::raw::c_uint, pub h: ::std::os::raw::c_uint }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_rect { pub coord: pjmedia_coord, pub size: pjmedia_rect_size }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_orient { PJMEDIA_ORIENT_UNKNOWN = 0, PJMEDIA_ORIENT_NATURAL = 1, PJMEDIA_ORIENT_ROTATE_90DEG = 2, PJMEDIA_ORIENT_ROTATE_180DEG = 3, PJMEDIA_ORIENT_ROTATE_270DEG = 4 }

extern "C" { pub fn pjmedia_type_name(t: pjmedia_type) -> *const ::std::os::raw::c_char; }

extern "C" {
    #[link_name = "\u{1}pjmedia_linear2ulaw_tab"]
    pub static mut pjmedia_linear2ulaw_tab: [pj_uint8_t; 16384usize];
}

extern "C" {
    #[link_name = "\u{1}pjmedia_linear2alaw_tab"]
    pub static mut pjmedia_linear2alaw_tab: [pj_uint8_t; 16384usize];
}

extern "C" {
    #[link_name = "\u{1}pjmedia_ulaw2linear_tab"]
    pub static mut pjmedia_ulaw2linear_tab: [pj_int16_t; 256usize];
}

extern "C" {
    #[link_name = "\u{1}pjmedia_alaw2linear_tab"]
    pub static mut pjmedia_alaw2linear_tab: [pj_int16_t; 256usize];
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjmedia_clock_src { pub media_type: pjmedia_type, pub clock_rate: ::std::os::raw::c_uint, pub ptime_usec: ::std::os::raw::c_uint, pub timestamp: pj_timestamp, pub last_update: pj_timestamp }

extern "C" { pub fn pjmedia_clock_src_init(clocksrc: *mut pjmedia_clock_src, media_type: pjmedia_type, clock_rate: ::std::os::raw::c_uint, ptime_usec: ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pjmedia_clock_src_update(clocksrc: *mut pjmedia_clock_src, timestamp: *const pj_timestamp) -> pj_status_t; }

extern "C" { pub fn pjmedia_clock_src_get_current_timestamp(clocksrc: *const pjmedia_clock_src, timestamp: *mut pj_timestamp) -> pj_status_t; }

extern "C" { pub fn pjmedia_clock_src_get_time_msec(clocksrc: *const pjmedia_clock_src) -> pj_uint32_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_clock { _unused: [u8; 0] }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_clock_options { PJMEDIA_CLOCK_NO_ASYNC = 1, PJMEDIA_CLOCK_NO_HIGHEST_PRIO = 2 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_clock_param { pub usec_interval: ::std::os::raw::c_uint, pub clock_rate: ::std::os::raw::c_uint }

pub type pjmedia_clock_callback = ::std::option::Option<unsafe extern "C" fn(ts: *const pj_timestamp, user_data: *mut ::std::os::raw::c_void)>;

extern "C" { pub fn pjmedia_clock_create(pool: *mut pj_pool_t, clock_rate: ::std::os::raw::c_uint, channel_count: ::std::os::raw::c_uint, samples_per_frame: ::std::os::raw::c_uint, options: ::std::os::raw::c_uint, cb: pjmedia_clock_callback, user_data: *mut ::std::os::raw::c_void, p_clock: *mut *mut pjmedia_clock) -> pj_status_t; }

extern "C" { pub fn pjmedia_clock_create2(pool: *mut pj_pool_t, param: *const pjmedia_clock_param, options: ::std::os::raw::c_uint, cb: pjmedia_clock_callback, user_data: *mut ::std::os::raw::c_void, p_clock: *mut *mut pjmedia_clock) -> pj_status_t; }

extern "C" { pub fn pjmedia_clock_start(clock: *mut pjmedia_clock) -> pj_status_t; }

extern "C" { pub fn pjmedia_clock_stop(clock: *mut pjmedia_clock) -> pj_status_t; }

extern "C" { pub fn pjmedia_clock_modify(clock: *mut pjmedia_clock, param: *const pjmedia_clock_param) -> pj_status_t; }

extern "C" { pub fn pjmedia_clock_wait(clock: *mut pjmedia_clock, wait: pj_bool_t, ts: *mut pj_timestamp) -> pj_bool_t; }

extern "C" { pub fn pjmedia_clock_destroy(clock: *mut pjmedia_clock) -> pj_status_t; }

impl pjmedia_format_id { pub const PJMEDIA_FORMAT_PCM: pjmedia_format_id = pjmedia_format_id::PJMEDIA_FORMAT_L16; }

impl pjmedia_format_id { pub const PJMEDIA_FORMAT_ALAW: pjmedia_format_id = pjmedia_format_id::PJMEDIA_FORMAT_PCMA; }

impl pjmedia_format_id { pub const PJMEDIA_FORMAT_ULAW: pjmedia_format_id = pjmedia_format_id::PJMEDIA_FORMAT_PCMU; }

impl pjmedia_format_id { pub const PJMEDIA_FORMAT_RGB32: pjmedia_format_id = pjmedia_format_id::PJMEDIA_FORMAT_RGBA; }

impl pjmedia_format_id { pub const PJMEDIA_FORMAT_IYUV: pjmedia_format_id = pjmedia_format_id::PJMEDIA_FORMAT_I420; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_format_id { PJMEDIA_FORMAT_L16 = 0, PJMEDIA_FORMAT_PCMA = 1463897153, PJMEDIA_FORMAT_PCMU = 1463897205, PJMEDIA_FORMAT_AMR = 1380794656, PJMEDIA_FORMAT_G729 = 959592263, PJMEDIA_FORMAT_ILBC = 1128418377, PJMEDIA_FORMAT_RGB24 = 859981650, PJMEDIA_FORMAT_RGBA = 1094862674, PJMEDIA_FORMAT_BGRA = 1095911234, PJMEDIA_FORMAT_DIB = 541215044, PJMEDIA_FORMAT_GBRP = 1347568199, PJMEDIA_FORMAT_AYUV = 1448433985, PJMEDIA_FORMAT_YUY2 = 844715353, PJMEDIA_FORMAT_UYVY = 1498831189, PJMEDIA_FORMAT_YVYU = 1431918169, PJMEDIA_FORMAT_I420 = 808596553, PJMEDIA_FORMAT_YV12 = 842094169, PJMEDIA_FORMAT_NV21 = 825382478, PJMEDIA_FORMAT_I422 = 842150985, PJMEDIA_FORMAT_I420JPEG = 808596554, PJMEDIA_FORMAT_I422JPEG = 842150986, PJMEDIA_FORMAT_H261 = 825635400, PJMEDIA_FORMAT_H263 = 859189832, PJMEDIA_FORMAT_H263P = 859189840, PJMEDIA_FORMAT_H264 = 875967048, PJMEDIA_FORMAT_MJPEG = 1196444237, PJMEDIA_FORMAT_MPEG1VIDEO = 1446072397, PJMEDIA_FORMAT_MPEG2VIDEO = 1446137933, PJMEDIA_FORMAT_MPEG4 = 877088845 }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_format_detail_type { PJMEDIA_FORMAT_DETAIL_NONE = 0, PJMEDIA_FORMAT_DETAIL_AUDIO = 1, PJMEDIA_FORMAT_DETAIL_VIDEO = 2, PJMEDIA_FORMAT_DETAIL_MAX = 3 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_audio_format_detail { pub clock_rate: ::std::os::raw::c_uint, pub channel_count: ::std::os::raw::c_uint, pub frame_time_usec: ::std::os::raw::c_uint, pub bits_per_sample: ::std::os::raw::c_uint, pub avg_bps: pj_uint32_t, pub max_bps: pj_uint32_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_video_format_detail { pub size: pjmedia_rect_size, pub fps: pjmedia_ratio, pub avg_bps: pj_uint32_t, pub max_bps: pj_uint32_t }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjmedia_format { pub id: pj_uint32_t, pub type_: pjmedia_type, pub detail_type: pjmedia_format_detail_type, pub det: pjmedia_format__bindgen_ty_1 }

#[repr(C)]
#[derive(Copy, Clone)]
pub union pjmedia_format__bindgen_ty_1 { pub aud: pjmedia_audio_format_detail, pub vid: pjmedia_video_format_detail, pub user: [::std::os::raw::c_char; 1usize], _bindgen_union_align: [u32; 6usize] }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_color_model { PJMEDIA_COLOR_MODEL_NONE = 0, PJMEDIA_COLOR_MODEL_RGB = 1, PJMEDIA_COLOR_MODEL_YUV = 2 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_video_apply_fmt_param { pub size: pjmedia_rect_size, pub buffer: *mut pj_uint8_t, pub framebytes: pj_size_t, pub strides: [::std::os::raw::c_int; 4usize], pub planes: [*mut pj_uint8_t; 4usize], pub plane_bytes: [pj_size_t; 4usize] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_video_format_info { pub id: pj_uint32_t, pub name: [::std::os::raw::c_char; 8usize], pub color_model: pjmedia_color_model, pub bpp: pj_uint8_t, pub plane_cnt: pj_uint8_t, pub apply_fmt: ::std::option::Option<unsafe extern "C" fn(vfi: *const pjmedia_video_format_info, vafp: *mut pjmedia_video_apply_fmt_param) -> pj_status_t> }

extern "C" { pub fn pjmedia_format_init_video(fmt: *mut pjmedia_format, fmt_id: pj_uint32_t, width: ::std::os::raw::c_uint, height: ::std::os::raw::c_uint, fps_num: ::std::os::raw::c_uint, fps_denum: ::std::os::raw::c_uint); }

extern "C" { pub fn pjmedia_format_copy(dst: *mut pjmedia_format, src: *const pjmedia_format) -> *mut pjmedia_format; }

extern "C" { pub fn pjmedia_format_get_audio_format_detail(fmt: *const pjmedia_format, assert_valid: pj_bool_t) -> *mut pjmedia_audio_format_detail; }

extern "C" { pub fn pjmedia_format_get_video_format_detail(fmt: *const pjmedia_format, assert_valid: pj_bool_t) -> *mut pjmedia_video_format_detail; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_video_format_mgr { _unused: [u8; 0] }

extern "C" { pub fn pjmedia_video_format_mgr_create(pool: *mut pj_pool_t, max_fmt: ::std::os::raw::c_uint, options: ::std::os::raw::c_uint, p_mgr: *mut *mut pjmedia_video_format_mgr) -> pj_status_t; }

extern "C" { pub fn pjmedia_video_format_mgr_instance() -> *mut pjmedia_video_format_mgr; }

extern "C" { pub fn pjmedia_video_format_mgr_set_instance(mgr: *mut pjmedia_video_format_mgr); }

extern "C" { pub fn pjmedia_get_video_format_info(mgr: *mut pjmedia_video_format_mgr, id: pj_uint32_t) -> *const pjmedia_video_format_info; }

extern "C" { pub fn pjmedia_register_video_format_info(mgr: *mut pjmedia_video_format_mgr, vfi: *mut pjmedia_video_format_info) -> pj_status_t; }

extern "C" { pub fn pjmedia_video_format_mgr_destroy(mgr: *mut pjmedia_video_format_mgr); }

pub type pjmedia_obj_sig = pj_uint32_t;

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_event_type { PJMEDIA_EVENT_NONE = 0, PJMEDIA_EVENT_FMT_CHANGED = 1212370246, PJMEDIA_EVENT_WND_CLOSING = 1279479383, PJMEDIA_EVENT_WND_CLOSED = 1329811031, PJMEDIA_EVENT_WND_RESIZED = 1515343447, PJMEDIA_EVENT_MOUSE_BTN_DOWN = 1313100621, PJMEDIA_EVENT_KEYFRAME_FOUND = 1179797065, PJMEDIA_EVENT_KEYFRAME_MISSING = 1297237577, PJMEDIA_EVENT_ORIENT_CHANGED = 1414419023 }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjmedia_event_fmt_changed_data { pub dir: pjmedia_dir, pub new_fmt: pjmedia_format }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_event_dummy_data { pub dummy: ::std::os::raw::c_int }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_event_wnd_resized_data { pub new_size: pjmedia_rect_size }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_event_wnd_closing_data { pub cancel: pj_bool_t }

pub type pjmedia_event_wnd_closed_data = pjmedia_event_dummy_data;
pub type pjmedia_event_mouse_btn_down_data = pjmedia_event_dummy_data;
pub type pjmedia_event_keyframe_found_data = pjmedia_event_dummy_data;
pub type pjmedia_event_keyframe_missing_data = pjmedia_event_dummy_data;
pub type pjmedia_event_user_data = [::std::os::raw::c_char; 40usize];

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjmedia_event { pub type_: pjmedia_event_type, pub timestamp: pj_timestamp, pub src: *const ::std::os::raw::c_void, pub epub: *const ::std::os::raw::c_void, pub data: pjmedia_event__bindgen_ty_1 }

#[repr(C)]
#[derive(Copy, Clone)]
pub union pjmedia_event__bindgen_ty_1 { pub fmt_changed: pjmedia_event_fmt_changed_data, pub wnd_resized: pjmedia_event_wnd_resized_data, pub wnd_closing: pjmedia_event_wnd_closing_data, pub wnd_closed: pjmedia_event_wnd_closed_data, pub mouse_btn_down: pjmedia_event_mouse_btn_down_data, pub keyframe_found: pjmedia_event_keyframe_found_data, pub keyframe_missing: pjmedia_event_keyframe_missing_data, pub user: pjmedia_event_user_data, pub ptr: *mut ::std::os::raw::c_void, _bindgen_union_align: [u32; 10usize] }

pub type pjmedia_event_cb = ::std::option::Option<unsafe extern "C" fn(event: *mut pjmedia_event, user_data: *mut ::std::os::raw::c_void) -> pj_status_t>;

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_event_publish_flag { PJMEDIA_EVENT_PUBLISH_DEFAULT = 0, PJMEDIA_EVENT_PUBLISH_POST_EVENT = 1 }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_event_mgr_flag { PJMEDIA_EVENT_MGR_NO_THREAD = 1 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_event_mgr { _unused: [u8; 0] }

extern "C" { pub fn pjmedia_event_mgr_create(pool: *mut pj_pool_t, options: ::std::os::raw::c_uint, mgr: *mut *mut pjmedia_event_mgr) -> pj_status_t; }

extern "C" { pub fn pjmedia_event_mgr_instance() -> *mut pjmedia_event_mgr; }

extern "C" { pub fn pjmedia_event_mgr_set_instance(mgr: *mut pjmedia_event_mgr); }

extern "C" { pub fn pjmedia_event_mgr_destroy(mgr: *mut pjmedia_event_mgr); }

extern "C" { pub fn pjmedia_event_init(event: *mut pjmedia_event, type_: pjmedia_event_type, ts: *const pj_timestamp, src: *const ::std::os::raw::c_void); }

extern "C" { pub fn pjmedia_event_subscribe(mgr: *mut pjmedia_event_mgr, cb: pjmedia_event_cb, user_data: *mut ::std::os::raw::c_void, epub: *mut ::std::os::raw::c_void) -> pj_status_t; }

extern "C" { pub fn pjmedia_event_unsubscribe(mgr: *mut pjmedia_event_mgr, cb: pjmedia_event_cb, user_data: *mut ::std::os::raw::c_void, epub: *mut ::std::os::raw::c_void) -> pj_status_t; }

extern "C" { pub fn pjmedia_event_publish(mgr: *mut pjmedia_event_mgr, epub: *mut ::std::os::raw::c_void, event: *mut pjmedia_event, flag: pjmedia_event_publish_flag) -> pj_status_t; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_frame_type { PJMEDIA_FRAME_TYPE_NONE = 0, PJMEDIA_FRAME_TYPE_AUDIO = 1, PJMEDIA_FRAME_TYPE_EXTENDED = 2, PJMEDIA_FRAME_TYPE_VIDEO = 3 }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjmedia_frame { pub type_: pjmedia_frame_type, pub buf: *mut ::std::os::raw::c_void, pub size: pj_size_t, pub timestamp: pj_timestamp, pub bit_info: pj_uint32_t }

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct pjmedia_frame_ext { pub base: pjmedia_frame, pub samples_cnt: pj_uint16_t, pub subframe_cnt: pj_uint16_t }

#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_frame_ext_subframe { pub bitlen: pj_uint16_t, pub data: [pj_uint8_t; 1usize] }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_sys_info_flag { PJ_SYS_HAS_IOS_BG = 1 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_sys_info { pub machine: pj_str_t, pub os_name: pj_str_t, pub os_ver: pj_uint32_t, pub sdk_name: pj_str_t, pub sdk_ver: pj_uint32_t, pub info: pj_str_t, pub flags: pj_uint32_t }

extern "C" { pub fn pj_get_sys_info() -> *const pj_sys_info; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_thread_create_flags { PJ_THREAD_SUSPENDED = 1 }

pub type pj_thread_proc = ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int>;
pub type pj_thread_desc = [::std::os::raw::c_long; 64usize];

extern "C" { pub fn pj_getpid() -> pj_uint32_t; }

extern "C" { pub fn pj_thread_create(pool: *mut pj_pool_t, thread_name: *const ::std::os::raw::c_char, proc_: pj_thread_proc, arg: *mut ::std::os::raw::c_void, stack_size: pj_size_t, flags: ::std::os::raw::c_uint, thread: *mut *mut pj_thread_t) -> pj_status_t; }

extern "C" { pub fn pj_thread_register(thread_name: *const ::std::os::raw::c_char, desc: *mut ::std::os::raw::c_long, thread: *mut *mut pj_thread_t) -> pj_status_t; }

extern "C" { pub fn pj_thread_is_registered() -> pj_bool_t; }

extern "C" { pub fn pj_thread_get_prio(thread: *mut pj_thread_t) -> ::std::os::raw::c_int; }

extern "C" { pub fn pj_thread_set_prio(thread: *mut pj_thread_t, prio: ::std::os::raw::c_int) -> pj_status_t; }

extern "C" { pub fn pj_thread_get_prio_min(thread: *mut pj_thread_t) -> ::std::os::raw::c_int; }

extern "C" { pub fn pj_thread_get_prio_max(thread: *mut pj_thread_t) -> ::std::os::raw::c_int; }

extern "C" { pub fn pj_thread_get_os_handle(thread: *mut pj_thread_t) -> *mut ::std::os::raw::c_void; }

extern "C" { pub fn pj_thread_get_name(thread: *mut pj_thread_t) -> *const ::std::os::raw::c_char; }

extern "C" { pub fn pj_thread_resume(thread: *mut pj_thread_t) -> pj_status_t; }

extern "C" { pub fn pj_thread_this() -> *mut pj_thread_t; }

extern "C" { pub fn pj_thread_join(thread: *mut pj_thread_t) -> pj_status_t; }

extern "C" { pub fn pj_thread_destroy(thread: *mut pj_thread_t) -> pj_status_t; }

extern "C" { pub fn pj_thread_sleep(msec: ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pj_symbianos_poll(priority: ::std::os::raw::c_int, ms_timeout: ::std::os::raw::c_int) -> pj_bool_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_symbianos_params { pub rsocketserv: *mut ::std::os::raw::c_void, pub rconnection: *mut ::std::os::raw::c_void, pub rhostresolver: *mut ::std::os::raw::c_void, pub rhostresolver6: *mut ::std::os::raw::c_void }

extern "C" { pub fn pj_symbianos_set_params(prm: *mut pj_symbianos_params) -> pj_status_t; }

extern "C" { pub fn pj_symbianos_set_connection_status(up: pj_bool_t); }

extern "C" { pub fn pj_thread_local_alloc(index: *mut ::std::os::raw::c_long) -> pj_status_t; }

extern "C" { pub fn pj_thread_local_free(index: ::std::os::raw::c_long); }

extern "C" { pub fn pj_thread_local_set(index: ::std::os::raw::c_long, value: *mut ::std::os::raw::c_void) -> pj_status_t; }

extern "C" { pub fn pj_thread_local_get(index: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_void; }

extern "C" { pub fn pj_atomic_create(pool: *mut pj_pool_t, initial: pj_atomic_value_t, atomic: *mut *mut pj_atomic_t) -> pj_status_t; }

extern "C" { pub fn pj_atomic_destroy(atomic_var: *mut pj_atomic_t) -> pj_status_t; }

extern "C" { pub fn pj_atomic_set(atomic_var: *mut pj_atomic_t, value: pj_atomic_value_t); }

extern "C" { pub fn pj_atomic_get(atomic_var: *mut pj_atomic_t) -> pj_atomic_value_t; }

extern "C" { pub fn pj_atomic_inc(atomic_var: *mut pj_atomic_t); }

extern "C" { pub fn pj_atomic_inc_and_get(atomic_var: *mut pj_atomic_t) -> pj_atomic_value_t; }

extern "C" { pub fn pj_atomic_dec(atomic_var: *mut pj_atomic_t); }

extern "C" { pub fn pj_atomic_dec_and_get(atomic_var: *mut pj_atomic_t) -> pj_atomic_value_t; }

extern "C" { pub fn pj_atomic_add(atomic_var: *mut pj_atomic_t, value: pj_atomic_value_t); }

extern "C" { pub fn pj_atomic_add_and_get(atomic_var: *mut pj_atomic_t, value: pj_atomic_value_t) -> pj_atomic_value_t; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_mutex_type_e { PJ_MUTEX_DEFAULT = 0, PJ_MUTEX_SIMPLE = 1, PJ_MUTEX_RECURSE = 2 }

extern "C" { pub fn pj_mutex_create(pool: *mut pj_pool_t, name: *const ::std::os::raw::c_char, type_: ::std::os::raw::c_int, mutex: *mut *mut pj_mutex_t) -> pj_status_t; }

extern "C" { pub fn pj_mutex_create_simple(pool: *mut pj_pool_t, name: *const ::std::os::raw::c_char, mutex: *mut *mut pj_mutex_t) -> pj_status_t; }

extern "C" { pub fn pj_mutex_create_recursive(pool: *mut pj_pool_t, name: *const ::std::os::raw::c_char, mutex: *mut *mut pj_mutex_t) -> pj_status_t; }

extern "C" { pub fn pj_mutex_lock(mutex: *mut pj_mutex_t) -> pj_status_t; }

extern "C" { pub fn pj_mutex_unlock(mutex: *mut pj_mutex_t) -> pj_status_t; }

extern "C" { pub fn pj_mutex_trylock(mutex: *mut pj_mutex_t) -> pj_status_t; }

extern "C" { pub fn pj_mutex_destroy(mutex: *mut pj_mutex_t) -> pj_status_t; }

extern "C" { pub fn pj_mutex_is_locked(mutex: *mut pj_mutex_t) -> pj_bool_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_rwmutex_t { _unused: [u8; 0] }

extern "C" { pub fn pj_rwmutex_create(pool: *mut pj_pool_t, name: *const ::std::os::raw::c_char, mutex: *mut *mut pj_rwmutex_t) -> pj_status_t; }

extern "C" { pub fn pj_rwmutex_lock_read(mutex: *mut pj_rwmutex_t) -> pj_status_t; }

extern "C" { pub fn pj_rwmutex_lock_write(mutex: *mut pj_rwmutex_t) -> pj_status_t; }

extern "C" { pub fn pj_rwmutex_unlock_read(mutex: *mut pj_rwmutex_t) -> pj_status_t; }

extern "C" { pub fn pj_rwmutex_unlock_write(mutex: *mut pj_rwmutex_t) -> pj_status_t; }

extern "C" { pub fn pj_rwmutex_destroy(mutex: *mut pj_rwmutex_t) -> pj_status_t; }

extern "C" { pub fn pj_enter_critical_section(); }

extern "C" { pub fn pj_leave_critical_section(); }

extern "C" { pub fn pj_sem_create(pool: *mut pj_pool_t, name: *const ::std::os::raw::c_char, initial: ::std::os::raw::c_uint, max: ::std::os::raw::c_uint, sem: *mut *mut pj_sem_t) -> pj_status_t; }

extern "C" { pub fn pj_sem_wait(sem: *mut pj_sem_t) -> pj_status_t; }

extern "C" { pub fn pj_sem_trywait(sem: *mut pj_sem_t) -> pj_status_t; }

extern "C" { pub fn pj_sem_post(sem: *mut pj_sem_t) -> pj_status_t; }

extern "C" { pub fn pj_sem_destroy(sem: *mut pj_sem_t) -> pj_status_t; }

extern "C" { pub fn pj_event_create(pool: *mut pj_pool_t, name: *const ::std::os::raw::c_char, manual_reset: pj_bool_t, initial: pj_bool_t, event: *mut *mut pj_event_t) -> pj_status_t; }

extern "C" { pub fn pj_event_wait(event: *mut pj_event_t) -> pj_status_t; }

extern "C" { pub fn pj_event_trywait(event: *mut pj_event_t) -> pj_status_t; }

extern "C" { pub fn pj_event_set(event: *mut pj_event_t) -> pj_status_t; }

extern "C" { pub fn pj_event_pulse(event: *mut pj_event_t) -> pj_status_t; }

extern "C" { pub fn pj_event_reset(event: *mut pj_event_t) -> pj_status_t; }

extern "C" { pub fn pj_event_destroy(event: *mut pj_event_t) -> pj_status_t; }

extern "C" { pub fn pj_gettimeofday(tv: *mut pj_time_val) -> pj_status_t; }

extern "C" { pub fn pj_time_decode(tv: *const pj_time_val, pt: *mut pj_parsed_time) -> pj_status_t; }

extern "C" { pub fn pj_time_encode(pt: *const pj_parsed_time, tv: *mut pj_time_val) -> pj_status_t; }

extern "C" { pub fn pj_time_local_to_gmt(tv: *mut pj_time_val) -> pj_status_t; }

extern "C" { pub fn pj_time_gmt_to_local(tv: *mut pj_time_val) -> pj_status_t; }

extern "C" { pub fn pj_term_set_color(color: pj_color_t) -> pj_status_t; }

extern "C" { pub fn pj_term_get_color() -> pj_color_t; }

extern "C" { pub fn pj_gettickcount(tv: *mut pj_time_val) -> pj_status_t; }

extern "C" { pub fn pj_get_timestamp(ts: *mut pj_timestamp) -> pj_status_t; }

extern "C" { pub fn pj_get_timestamp_freq(freq: *mut pj_timestamp) -> pj_status_t; }

extern "C" { pub fn pj_elapsed_time(start: *const pj_timestamp, stop: *const pj_timestamp) -> pj_time_val; }

extern "C" { pub fn pj_elapsed_msec(start: *const pj_timestamp, stop: *const pj_timestamp) -> pj_uint32_t; }

extern "C" { pub fn pj_elapsed_msec64(start: *const pj_timestamp, stop: *const pj_timestamp) -> pj_uint64_t; }

extern "C" { pub fn pj_elapsed_usec(start: *const pj_timestamp, stop: *const pj_timestamp) -> pj_uint32_t; }

extern "C" { pub fn pj_elapsed_nanosec(start: *const pj_timestamp, stop: *const pj_timestamp) -> pj_uint32_t; }

extern "C" { pub fn pj_elapsed_cycle(start: *const pj_timestamp, stop: *const pj_timestamp) -> pj_uint32_t; }

pub type pj_main_func_ptr = ::std::option::Option<unsafe extern "C" fn(argc: ::std::os::raw::c_int, argv: *mut *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int>;

extern "C" { pub fn pj_run_app(main_func: pj_main_func_ptr, argc: ::std::os::raw::c_int, argv: *mut *mut ::std::os::raw::c_char, flags: ::std::os::raw::c_uint) -> ::std::os::raw::c_int; }

extern "C" { pub fn pj_thread_init() -> pj_status_t; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_port_op { PJMEDIA_PORT_NO_CHANGE = 0, PJMEDIA_PORT_DISABLE = 1, PJMEDIA_PORT_MUTE = 2, PJMEDIA_PORT_ENABLE = 3 }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjmedia_port_info { pub name: pj_str_t, pub signature: pj_uint32_t, pub dir: pjmedia_dir, pub fmt: pjmedia_format }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjmedia_port { pub info: pjmedia_port_info, pub port_data: pjmedia_port_port_data, pub get_clock_src: ::std::option::Option<unsafe extern "C" fn(this_port: *mut pjmedia_port, dir: pjmedia_dir) -> *mut pjmedia_clock_src>, pub put_frame: ::std::option::Option<unsafe extern "C" fn(this_port: *mut pjmedia_port, frame: *mut pjmedia_frame) -> pj_status_t>, pub get_frame: ::std::option::Option<unsafe extern "C" fn(this_port: *mut pjmedia_port, frame: *mut pjmedia_frame) -> pj_status_t>, pub on_destroy: ::std::option::Option<unsafe extern "C" fn(this_port: *mut pjmedia_port) -> pj_status_t> }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_port_port_data { pub pdata: *mut ::std::os::raw::c_void, pub ldata: ::std::os::raw::c_long }

extern "C" { pub fn pjmedia_port_info_init(info: *mut pjmedia_port_info, name: *const pj_str_t, signature: ::std::os::raw::c_uint, clock_rate: ::std::os::raw::c_uint, channel_count: ::std::os::raw::c_uint, bits_per_sample: ::std::os::raw::c_uint, samples_per_frame: ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pjmedia_port_info_init2(info: *mut pjmedia_port_info, name: *const pj_str_t, signature: ::std::os::raw::c_uint, dir: pjmedia_dir, fmt: *const pjmedia_format) -> pj_status_t; }

extern "C" { pub fn pjmedia_port_get_clock_src(port: *mut pjmedia_port, dir: pjmedia_dir) -> *mut pjmedia_clock_src; }

extern "C" { pub fn pjmedia_port_get_frame(port: *mut pjmedia_port, frame: *mut pjmedia_frame) -> pj_status_t; }

extern "C" { pub fn pjmedia_port_put_frame(port: *mut pjmedia_port, frame: *mut pjmedia_frame) -> pj_status_t; }

extern "C" { pub fn pjmedia_port_destroy(port: *mut pjmedia_port) -> pj_status_t; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_avi_file_player_option { PJMEDIA_AVI_FILE_NO_LOOP = 1 }

pub type pjmedia_avi_stream = pjmedia_port;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_avi_streams { _unused: [u8; 0] }

extern "C" { pub fn pjmedia_avi_player_create_streams(pool: *mut pj_pool_t, filename: *const ::std::os::raw::c_char, flags: ::std::os::raw::c_uint, p_streams: *mut *mut pjmedia_avi_streams) -> pj_status_t; }

extern "C" { pub fn pjmedia_avi_streams_get_num_streams(streams: *mut pjmedia_avi_streams) -> ::std::os::raw::c_uint; }

extern "C" { pub fn pjmedia_avi_streams_get_stream(streams: *mut pjmedia_avi_streams, idx: ::std::os::raw::c_uint) -> *mut pjmedia_avi_stream; }

extern "C" { pub fn pjmedia_avi_streams_get_stream_by_media(streams: *mut pjmedia_avi_streams, start_idx: ::std::os::raw::c_uint, media_type: pjmedia_type) -> *mut pjmedia_avi_stream; }

extern "C" { pub fn pjmedia_avi_stream_get_len(stream: *mut pjmedia_avi_stream) -> pj_ssize_t; }

extern "C" { pub fn pjmedia_avi_stream_set_eof_cb(stream: *mut pjmedia_avi_stream, user_data: *mut ::std::os::raw::c_void, cb: ::std::option::Option<unsafe extern "C" fn(stream: *mut pjmedia_avi_stream, usr_data: *mut ::std::os::raw::c_void) -> pj_status_t>) -> pj_status_t; }

extern "C" { pub fn pjmedia_bidirectional_port_create(pool: *mut pj_pool_t, get_port: *mut pjmedia_port, put_port: *mut pjmedia_port, p_port: *mut *mut pjmedia_port) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_circ_buf { pub buf: *mut pj_int16_t, pub capacity: ::std::os::raw::c_uint, pub start: *mut pj_int16_t, pub len: ::std::os::raw::c_uint }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_rtp_pt { PJMEDIA_RTP_PT_PCMU = 0, PJMEDIA_RTP_PT_G721 = 2, PJMEDIA_RTP_PT_GSM = 3, PJMEDIA_RTP_PT_G723 = 4, PJMEDIA_RTP_PT_DVI4_8K = 5, PJMEDIA_RTP_PT_DVI4_16K = 6, PJMEDIA_RTP_PT_LPC = 7, PJMEDIA_RTP_PT_PCMA = 8, PJMEDIA_RTP_PT_G722 = 9, PJMEDIA_RTP_PT_L16_2 = 10, PJMEDIA_RTP_PT_L16_1 = 11, PJMEDIA_RTP_PT_QCELP = 12, PJMEDIA_RTP_PT_CN = 13, PJMEDIA_RTP_PT_MPA = 14, PJMEDIA_RTP_PT_G728 = 15, PJMEDIA_RTP_PT_DVI4_11K = 16, PJMEDIA_RTP_PT_DVI4_22K = 17, PJMEDIA_RTP_PT_G729 = 18, PJMEDIA_RTP_PT_CELB = 25, PJMEDIA_RTP_PT_JPEG = 26, PJMEDIA_RTP_PT_NV = 28, PJMEDIA_RTP_PT_H261 = 31, PJMEDIA_RTP_PT_MPV = 32, PJMEDIA_RTP_PT_MP2T = 33, PJMEDIA_RTP_PT_H263 = 34, PJMEDIA_RTP_PT_DYNAMIC = 96 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_codec_info { pub type_: pjmedia_type, pub pt: ::std::os::raw::c_uint, pub encoding_name: pj_str_t, pub clock_rate: ::std::os::raw::c_uint, pub channel_cnt: ::std::os::raw::c_uint }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_codec_fmtp { pub cnt: pj_uint8_t, pub param: [pjmedia_codec_fmtp_param; 16usize] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_codec_fmtp_param { pub name: pj_str_t, pub val: pj_str_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_codec_param { pub info: pjmedia_codec_param__bindgen_ty_1, pub setting: pjmedia_codec_param__bindgen_ty_2 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_codec_param__bindgen_ty_1 { pub clock_rate: ::std::os::raw::c_uint, pub channel_cnt: ::std::os::raw::c_uint, pub avg_bps: pj_uint32_t, pub max_bps: pj_uint32_t, pub max_rx_frame_size: ::std::os::raw::c_uint, pub frm_ptime: pj_uint16_t, pub enc_ptime: pj_uint16_t, pub pcm_bits_per_sample: pj_uint8_t, pub pt: pj_uint8_t, pub fmt_id: pjmedia_format_id }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_codec_param__bindgen_ty_2 { pub frm_per_pkt: pj_uint8_t, pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>, pub enc_fmtp: pjmedia_codec_fmtp, pub dec_fmtp: pjmedia_codec_fmtp }

impl pjmedia_codec_param__bindgen_ty_2 {
    #[inline]
    pub fn vad(&self) -> ::std::os::raw::c_uint { unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) } }
    #[inline]
    pub fn set_vad(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cng(&self) -> ::std::os::raw::c_uint { unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) } }
    #[inline]
    pub fn set_cng(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn penh(&self) -> ::std::os::raw::c_uint { unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) } }
    #[inline]
    pub fn set_penh(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn plc(&self) -> ::std::os::raw::c_uint { unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) } }
    #[inline]
    pub fn set_plc(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> ::std::os::raw::c_uint { unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) } }
    #[inline]
    pub fn set_reserved(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(vad: ::std::os::raw::c_uint, cng: ::std::os::raw::c_uint, penh: ::std::os::raw::c_uint, plc: ::std::os::raw::c_uint, reserved: ::std::os::raw::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let vad: u32 = unsafe { ::std::mem::transmute(vad) };
            vad as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let cng: u32 = unsafe { ::std::mem::transmute(cng) };
            cng as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let penh: u32 = unsafe { ::std::mem::transmute(penh) };
            penh as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let plc: u32 = unsafe { ::std::mem::transmute(plc) };
            plc as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}

extern "C" { pub fn pjmedia_codec_param_clone(pool: *mut pj_pool_t, src: *const pjmedia_codec_param) -> *mut pjmedia_codec_param; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_codec_op { pub init: ::std::option::Option<unsafe extern "C" fn(codec: *mut pjmedia_codec, pool: *mut pj_pool_t) -> pj_status_t>, pub open: ::std::option::Option<unsafe extern "C" fn(codec: *mut pjmedia_codec, param: *mut pjmedia_codec_param) -> pj_status_t>, pub close: ::std::option::Option<unsafe extern "C" fn(codec: *mut pjmedia_codec) -> pj_status_t>, pub modify: ::std::option::Option<unsafe extern "C" fn(codec: *mut pjmedia_codec, param: *const pjmedia_codec_param) -> pj_status_t>, pub parse: ::std::option::Option<unsafe extern "C" fn(codec: *mut pjmedia_codec, pkt: *mut ::std::os::raw::c_void, pkt_size: pj_size_t, timestamp: *const pj_timestamp, frame_cnt: *mut ::std::os::raw::c_uint, frames: *mut pjmedia_frame) -> pj_status_t>, pub encode: ::std::option::Option<unsafe extern "C" fn(codec: *mut pjmedia_codec, input: *const pjmedia_frame, out_size: ::std::os::raw::c_uint, output: *mut pjmedia_frame) -> pj_status_t>, pub decode: ::std::option::Option<unsafe extern "C" fn(codec: *mut pjmedia_codec, input: *const pjmedia_frame, out_size: ::std::os::raw::c_uint, output: *mut pjmedia_frame) -> pj_status_t>, pub recover: ::std::option::Option<unsafe extern "C" fn(codec: *mut pjmedia_codec, out_size: ::std::os::raw::c_uint, output: *mut pjmedia_frame) -> pj_status_t> }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_codec { pub prev: *mut pjmedia_codec, pub next: *mut pjmedia_codec, pub codec_data: *mut ::std::os::raw::c_void, pub factory: *mut pjmedia_codec_factory, pub op: *mut pjmedia_codec_op }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_codec_factory_op { pub test_alloc: ::std::option::Option<unsafe extern "C" fn(factory: *mut pjmedia_codec_factory, info: *const pjmedia_codec_info) -> pj_status_t>, pub default_attr: ::std::option::Option<unsafe extern "C" fn(factory: *mut pjmedia_codec_factory, info: *const pjmedia_codec_info, attr: *mut pjmedia_codec_param) -> pj_status_t>, pub enum_info: ::std::option::Option<unsafe extern "C" fn(factory: *mut pjmedia_codec_factory, count: *mut ::std::os::raw::c_uint, codecs: *mut pjmedia_codec_info) -> pj_status_t>, pub alloc_codec: ::std::option::Option<unsafe extern "C" fn(factory: *mut pjmedia_codec_factory, info: *const pjmedia_codec_info, p_codec: *mut *mut pjmedia_codec) -> pj_status_t>, pub dealloc_codec: ::std::option::Option<unsafe extern "C" fn(factory: *mut pjmedia_codec_factory, codec: *mut pjmedia_codec) -> pj_status_t>, pub destroy: ::std::option::Option<unsafe extern "C" fn() -> pj_status_t> }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_codec_factory { pub prev: *mut pjmedia_codec_factory, pub next: *mut pjmedia_codec_factory, pub factory_data: *mut ::std::os::raw::c_void, pub op: *mut pjmedia_codec_factory_op }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_codec_priority { PJMEDIA_CODEC_PRIO_HIGHEST = 255, PJMEDIA_CODEC_PRIO_NEXT_HIGHER = 254, PJMEDIA_CODEC_PRIO_NORMAL = 128, PJMEDIA_CODEC_PRIO_LOWEST = 1, PJMEDIA_CODEC_PRIO_DISABLED = 0 }

pub type pjmedia_codec_id = [::std::os::raw::c_char; 32usize];

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_codec_default_param { _unused: [u8; 0] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_codec_desc { pub info: pjmedia_codec_info, pub id: pjmedia_codec_id, pub prio: pjmedia_codec_priority, pub factory: *mut pjmedia_codec_factory, pub param: *mut pjmedia_codec_default_param }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_codec_mgr { pub pf: *mut pj_pool_factory, pub pool: *mut pj_pool_t, pub mutex: *mut pj_mutex_t, pub factory_list: pjmedia_codec_factory, pub codec_cnt: ::std::os::raw::c_uint, pub codec_desc: [pjmedia_codec_desc; 32usize] }

extern "C" { pub fn pjmedia_codec_mgr_init(mgr: *mut pjmedia_codec_mgr, pf: *mut pj_pool_factory) -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_mgr_destroy(mgr: *mut pjmedia_codec_mgr) -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_mgr_register_factory(mgr: *mut pjmedia_codec_mgr, factory: *mut pjmedia_codec_factory) -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_mgr_unregister_factory(mgr: *mut pjmedia_codec_mgr, factory: *mut pjmedia_codec_factory) -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_mgr_enum_codecs(mgr: *mut pjmedia_codec_mgr, count: *mut ::std::os::raw::c_uint, info: *mut pjmedia_codec_info, prio: *mut ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_mgr_get_codec_info(mgr: *mut pjmedia_codec_mgr, pt: ::std::os::raw::c_uint, inf: *mut *const pjmedia_codec_info) -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_info_to_id(info: *const pjmedia_codec_info, id: *mut ::std::os::raw::c_char, max_len: ::std::os::raw::c_uint) -> *mut ::std::os::raw::c_char; }

extern "C" { pub fn pjmedia_codec_mgr_find_codecs_by_id(mgr: *mut pjmedia_codec_mgr, codec_id: *const pj_str_t, count: *mut ::std::os::raw::c_uint, p_info: *mut *const pjmedia_codec_info, prio: *mut ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_mgr_set_codec_priority(mgr: *mut pjmedia_codec_mgr, codec_id: *const pj_str_t, prio: pj_uint8_t) -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_mgr_get_default_param(mgr: *mut pjmedia_codec_mgr, info: *const pjmedia_codec_info, param: *mut pjmedia_codec_param) -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_mgr_set_default_param(mgr: *mut pjmedia_codec_mgr, info: *const pjmedia_codec_info, param: *const pjmedia_codec_param) -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_mgr_alloc_codec(mgr: *mut pjmedia_codec_mgr, info: *const pjmedia_codec_info, p_codec: *mut *mut pjmedia_codec) -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_mgr_dealloc_codec(mgr: *mut pjmedia_codec_mgr, codec: *mut pjmedia_codec) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_conf { _unused: [u8; 0] }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjmedia_conf_port_info { pub slot: ::std::os::raw::c_uint, pub name: pj_str_t, pub format: pjmedia_format, pub tx_setting: pjmedia_port_op, pub rx_setting: pjmedia_port_op, pub listener_cnt: ::std::os::raw::c_uint, pub listener_slots: *mut ::std::os::raw::c_uint, pub transmitter_cnt: ::std::os::raw::c_uint, pub clock_rate: ::std::os::raw::c_uint, pub channel_count: ::std::os::raw::c_uint, pub samples_per_frame: ::std::os::raw::c_uint, pub bits_per_sample: ::std::os::raw::c_uint, pub tx_adj_level: ::std::os::raw::c_int, pub rx_adj_level: ::std::os::raw::c_int }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_conf_option { PJMEDIA_CONF_NO_MIC = 1, PJMEDIA_CONF_NO_DEVICE = 2, PJMEDIA_CONF_SMALL_FILTER = 4, PJMEDIA_CONF_USE_LINEAR = 8 }

extern "C" { pub fn pjmedia_conf_create(pool: *mut pj_pool_t, max_slots: ::std::os::raw::c_uint, sampling_rate: ::std::os::raw::c_uint, channel_count: ::std::os::raw::c_uint, samples_per_frame: ::std::os::raw::c_uint, bits_per_sample: ::std::os::raw::c_uint, options: ::std::os::raw::c_uint, p_conf: *mut *mut pjmedia_conf) -> pj_status_t; }

extern "C" { pub fn pjmedia_conf_destroy(conf: *mut pjmedia_conf) -> pj_status_t; }

extern "C" { pub fn pjmedia_conf_get_master_port(conf: *mut pjmedia_conf) -> *mut pjmedia_port; }

extern "C" { pub fn pjmedia_conf_set_port0_name(conf: *mut pjmedia_conf, name: *const pj_str_t) -> pj_status_t; }

extern "C" { pub fn pjmedia_conf_add_port(conf: *mut pjmedia_conf, pool: *mut pj_pool_t, strm_port: *mut pjmedia_port, name: *const pj_str_t, p_slot: *mut ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pjmedia_conf_add_passive_port(conf: *mut pjmedia_conf, pool: *mut pj_pool_t, name: *const pj_str_t, clock_rate: ::std::os::raw::c_uint, channel_count: ::std::os::raw::c_uint, samples_per_frame: ::std::os::raw::c_uint, bits_per_sample: ::std::os::raw::c_uint, options: ::std::os::raw::c_uint, p_slot: *mut ::std::os::raw::c_uint, p_port: *mut *mut pjmedia_port) -> pj_status_t; }

extern "C" { pub fn pjmedia_conf_configure_port(conf: *mut pjmedia_conf, slot: ::std::os::raw::c_uint, tx: pjmedia_port_op, rx: pjmedia_port_op) -> pj_status_t; }

extern "C" { pub fn pjmedia_conf_connect_port(conf: *mut pjmedia_conf, src_slot: ::std::os::raw::c_uint, sink_slot: ::std::os::raw::c_uint, level: ::std::os::raw::c_int) -> pj_status_t; }

extern "C" { pub fn pjmedia_conf_disconnect_port(conf: *mut pjmedia_conf, src_slot: ::std::os::raw::c_uint, sink_slot: ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pjmedia_conf_get_port_count(conf: *mut pjmedia_conf) -> ::std::os::raw::c_uint; }

extern "C" { pub fn pjmedia_conf_get_connect_count(conf: *mut pjmedia_conf) -> ::std::os::raw::c_uint; }

extern "C" { pub fn pjmedia_conf_remove_port(conf: *mut pjmedia_conf, slot: ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pjmedia_conf_enum_ports(conf: *mut pjmedia_conf, ports: *mut ::std::os::raw::c_uint, count: *mut ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pjmedia_conf_get_port_info(conf: *mut pjmedia_conf, slot: ::std::os::raw::c_uint, info: *mut pjmedia_conf_port_info) -> pj_status_t; }

extern "C" { pub fn pjmedia_conf_get_ports_info(conf: *mut pjmedia_conf, size: *mut ::std::os::raw::c_uint, info: *mut pjmedia_conf_port_info) -> pj_status_t; }

extern "C" { pub fn pjmedia_conf_get_signal_level(conf: *mut pjmedia_conf, slot: ::std::os::raw::c_uint, tx_level: *mut ::std::os::raw::c_uint, rx_level: *mut ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pjmedia_conf_adjust_rx_level(conf: *mut pjmedia_conf, slot: ::std::os::raw::c_uint, adj_level: ::std::os::raw::c_int) -> pj_status_t; }

extern "C" { pub fn pjmedia_conf_adjust_tx_level(conf: *mut pjmedia_conf, slot: ::std::os::raw::c_uint, adj_level: ::std::os::raw::c_int) -> pj_status_t; }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjmedia_conversion_param { pub src: pjmedia_format, pub dst: pjmedia_format }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_converter_priority_guide { PJMEDIA_CONVERTER_PRIORITY_LOWEST = 0, PJMEDIA_CONVERTER_PRIORITY_NORMAL = 15000, PJMEDIA_CONVERTER_PRIORITY_HIGHEST = 32000 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_converter_factory { pub prev: *mut pjmedia_converter_factory, pub next: *mut pjmedia_converter_factory, pub name: *const ::std::os::raw::c_char, pub priority: ::std::os::raw::c_int, pub op: *mut pjmedia_converter_factory_op }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_converter { pub op: *mut pjmedia_converter_op }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_converter_factory_op { pub create_converter: ::std::option::Option<unsafe extern "C" fn(cf: *mut pjmedia_converter_factory, pool: *mut pj_pool_t, prm: *const pjmedia_conversion_param, p_cv: *mut *mut pjmedia_converter) -> pj_status_t>, pub destroy_factory: ::std::option::Option<unsafe extern "C" fn(cf: *mut pjmedia_converter_factory)> }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_converter_op { pub convert: ::std::option::Option<unsafe extern "C" fn(cv: *mut pjmedia_converter, src_frame: *mut pjmedia_frame, dst_frame: *mut pjmedia_frame) -> pj_status_t>, pub destroy: ::std::option::Option<unsafe extern "C" fn(cv: *mut pjmedia_converter)> }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_converter_mgr { _unused: [u8; 0] }

extern "C" { pub fn pjmedia_converter_mgr_create(pool: *mut pj_pool_t, mgr: *mut *mut pjmedia_converter_mgr) -> pj_status_t; }

extern "C" { pub fn pjmedia_converter_mgr_instance() -> *mut pjmedia_converter_mgr; }

extern "C" { pub fn pjmedia_converter_mgr_set_instance(mgr: *mut pjmedia_converter_mgr); }

extern "C" { pub fn pjmedia_converter_mgr_destroy(mgr: *mut pjmedia_converter_mgr); }

extern "C" { pub fn pjmedia_converter_mgr_register_factory(mgr: *mut pjmedia_converter_mgr, f: *mut pjmedia_converter_factory) -> pj_status_t; }

extern "C" { pub fn pjmedia_converter_mgr_unregister_factory(mgr: *mut pjmedia_converter_mgr, f: *mut pjmedia_converter_factory, call_destroy: pj_bool_t) -> pj_status_t; }

extern "C" { pub fn pjmedia_converter_create(mgr: *mut pjmedia_converter_mgr, pool: *mut pj_pool_t, param: *mut pjmedia_conversion_param, p_cv: *mut *mut pjmedia_converter) -> pj_status_t; }

extern "C" { pub fn pjmedia_converter_convert(cv: *mut pjmedia_converter, src_frame: *mut pjmedia_frame, dst_frame: *mut pjmedia_frame) -> pj_status_t; }

extern "C" { pub fn pjmedia_converter_destroy(cv: *mut pjmedia_converter); }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_delay_buf { _unused: [u8; 0] }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_delay_buf_flag { PJMEDIA_DELAY_BUF_SIMPLE_FIFO = 1 }

extern "C" { pub fn pjmedia_delay_buf_create(pool: *mut pj_pool_t, name: *const ::std::os::raw::c_char, clock_rate: ::std::os::raw::c_uint, samples_per_frame: ::std::os::raw::c_uint, channel_count: ::std::os::raw::c_uint, max_delay: ::std::os::raw::c_uint, options: ::std::os::raw::c_uint, p_b: *mut *mut pjmedia_delay_buf) -> pj_status_t; }

extern "C" { pub fn pjmedia_delay_buf_put(b: *mut pjmedia_delay_buf, frame: *mut pj_int16_t) -> pj_status_t; }

extern "C" { pub fn pjmedia_delay_buf_get(b: *mut pjmedia_delay_buf, frame: *mut pj_int16_t) -> pj_status_t; }

extern "C" { pub fn pjmedia_delay_buf_reset(b: *mut pjmedia_delay_buf) -> pj_status_t; }

extern "C" { pub fn pjmedia_delay_buf_destroy(b: *mut pjmedia_delay_buf) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_echo_state { _unused: [u8; 0] }

impl pjmedia_echo_flag { pub const PJMEDIA_ECHO_AGGRESSIVENESS_DEFAULT: pjmedia_echo_flag = pjmedia_echo_flag::PJMEDIA_ECHO_DEFAULT; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_echo_flag { PJMEDIA_ECHO_DEFAULT = 0, PJMEDIA_ECHO_SPEEX = 1, PJMEDIA_ECHO_SIMPLE = 2, PJMEDIA_ECHO_WEBRTC = 3, PJMEDIA_ECHO_ALGO_MASK = 15, PJMEDIA_ECHO_NO_LOCK = 16, PJMEDIA_ECHO_USE_SIMPLE_FIFO = 32, PJMEDIA_ECHO_USE_SW_ECHO = 64, PJMEDIA_ECHO_USE_NOISE_SUPPRESSOR = 128, PJMEDIA_ECHO_AGGRESSIVENESS_CONSERVATIVE = 256, PJMEDIA_ECHO_AGGRESSIVENESS_MODERATE = 512, PJMEDIA_ECHO_AGGRESSIVENESS_AGGRESSIVE = 768, PJMEDIA_ECHO_AGGRESSIVENESS_MASK = 3840 }

extern "C" { pub fn pjmedia_echo_create(pool: *mut pj_pool_t, clock_rate: ::std::os::raw::c_uint, samples_per_frame: ::std::os::raw::c_uint, tail_ms: ::std::os::raw::c_uint, latency_ms: ::std::os::raw::c_uint, options: ::std::os::raw::c_uint, p_echo: *mut *mut pjmedia_echo_state) -> pj_status_t; }

extern "C" { pub fn pjmedia_echo_create2(pool: *mut pj_pool_t, clock_rate: ::std::os::raw::c_uint, channel_count: ::std::os::raw::c_uint, samples_per_frame: ::std::os::raw::c_uint, tail_ms: ::std::os::raw::c_uint, latency_ms: ::std::os::raw::c_uint, options: ::std::os::raw::c_uint, p_echo: *mut *mut pjmedia_echo_state) -> pj_status_t; }

extern "C" { pub fn pjmedia_echo_destroy(echo: *mut pjmedia_echo_state) -> pj_status_t; }

extern "C" { pub fn pjmedia_echo_reset(echo: *mut pjmedia_echo_state) -> pj_status_t; }

extern "C" { pub fn pjmedia_echo_playback(echo: *mut pjmedia_echo_state, play_frm: *mut pj_int16_t) -> pj_status_t; }

extern "C" { pub fn pjmedia_echo_capture(echo: *mut pjmedia_echo_state, rec_frm: *mut pj_int16_t, options: ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pjmedia_echo_cancel(echo: *mut pjmedia_echo_state, rec_frm: *mut pj_int16_t, play_frm: *const pj_int16_t, options: ::std::os::raw::c_uint, reserved: *mut ::std::os::raw::c_void) -> pj_status_t; }

extern "C" { pub fn pjmedia_echo_port_create(pool: *mut pj_pool_t, dn_port: *mut pjmedia_port, tail_ms: ::std::os::raw::c_uint, latency_ms: ::std::os::raw::c_uint, options: ::std::os::raw::c_uint, p_port: *mut *mut pjmedia_port) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_sdp_attr { pub name: pj_str_t, pub value: pj_str_t }

extern "C" { pub fn pjmedia_sdp_attr_create(pool: *mut pj_pool_t, name: *const ::std::os::raw::c_char, value: *const pj_str_t) -> *mut pjmedia_sdp_attr; }

extern "C" { pub fn pjmedia_sdp_attr_clone(pool: *mut pj_pool_t, attr: *const pjmedia_sdp_attr) -> *mut pjmedia_sdp_attr; }

extern "C" { pub fn pjmedia_sdp_attr_find(count: ::std::os::raw::c_uint, attr_array: *const *mut pjmedia_sdp_attr, name: *const pj_str_t, fmt: *const pj_str_t) -> *mut pjmedia_sdp_attr; }

extern "C" { pub fn pjmedia_sdp_attr_find2(count: ::std::os::raw::c_uint, attr_array: *const *mut pjmedia_sdp_attr, name: *const ::std::os::raw::c_char, fmt: *const pj_str_t) -> *mut pjmedia_sdp_attr; }

extern "C" { pub fn pjmedia_sdp_attr_add(count: *mut ::std::os::raw::c_uint, attr_array: *mut *mut pjmedia_sdp_attr, attr: *mut pjmedia_sdp_attr) -> pj_status_t; }

extern "C" { pub fn pjmedia_sdp_attr_remove_all(count: *mut ::std::os::raw::c_uint, attr_array: *mut *mut pjmedia_sdp_attr, name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_uint; }

extern "C" { pub fn pjmedia_sdp_attr_remove(count: *mut ::std::os::raw::c_uint, attr_array: *mut *mut pjmedia_sdp_attr, attr: *mut pjmedia_sdp_attr) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_sdp_rtpmap { pub pt: pj_str_t, pub enc_name: pj_str_t, pub clock_rate: ::std::os::raw::c_uint, pub param: pj_str_t }

extern "C" { pub fn pjmedia_sdp_attr_to_rtpmap(pool: *mut pj_pool_t, attr: *const pjmedia_sdp_attr, p_rtpmap: *mut *mut pjmedia_sdp_rtpmap) -> pj_status_t; }

extern "C" { pub fn pjmedia_sdp_attr_get_rtpmap(attr: *const pjmedia_sdp_attr, rtpmap: *mut pjmedia_sdp_rtpmap) -> pj_status_t; }

extern "C" { pub fn pjmedia_sdp_rtpmap_to_attr(pool: *mut pj_pool_t, rtpmap: *const pjmedia_sdp_rtpmap, p_attr: *mut *mut pjmedia_sdp_attr) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_sdp_fmtp { pub fmt: pj_str_t, pub fmt_param: pj_str_t }

extern "C" { pub fn pjmedia_sdp_attr_get_fmtp(attr: *const pjmedia_sdp_attr, fmtp: *mut pjmedia_sdp_fmtp) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_sdp_rtcp_attr { pub port: ::std::os::raw::c_uint, pub net_type: pj_str_t, pub addr_type: pj_str_t, pub addr: pj_str_t }

extern "C" { pub fn pjmedia_sdp_attr_get_rtcp(attr: *const pjmedia_sdp_attr, rtcp: *mut pjmedia_sdp_rtcp_attr) -> pj_status_t; }

extern "C" { pub fn pjmedia_sdp_attr_create_rtcp(pool: *mut pj_pool_t, a: *const pj_sockaddr) -> *mut pjmedia_sdp_attr; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_sdp_conn { pub net_type: pj_str_t, pub addr_type: pj_str_t, pub addr: pj_str_t }

extern "C" { pub fn pjmedia_sdp_conn_clone(pool: *mut pj_pool_t, rhs: *const pjmedia_sdp_conn) -> *mut pjmedia_sdp_conn; }

extern "C" { pub fn pjmedia_sdp_conn_cmp(conn1: *const pjmedia_sdp_conn, conn2: *const pjmedia_sdp_conn, option: ::std::os::raw::c_uint) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_sdp_bandw { pub modifier: pj_str_t, pub value: pj_uint32_t }

extern "C" { pub fn pjmedia_sdp_bandw_clone(pool: *mut pj_pool_t, rhs: *const pjmedia_sdp_bandw) -> *mut pjmedia_sdp_bandw; }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjmedia_sdp_media { pub desc: pjmedia_sdp_media__bindgen_ty_1, pub conn: *mut pjmedia_sdp_conn, pub bandw_count: ::std::os::raw::c_uint, pub bandw: [*mut pjmedia_sdp_bandw; 4usize], pub attr_count: ::std::os::raw::c_uint, pub attr: [*mut pjmedia_sdp_attr; 68usize] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_sdp_media__bindgen_ty_1 { pub media: pj_str_t, pub port: pj_uint16_t, pub port_count: ::std::os::raw::c_uint, pub transport: pj_str_t, pub fmt_count: ::std::os::raw::c_uint, pub fmt: [pj_str_t; 32usize] }

extern "C" { pub fn pjmedia_sdp_media_clone(pool: *mut pj_pool_t, rhs: *const pjmedia_sdp_media) -> *mut pjmedia_sdp_media; }

extern "C" { pub fn pjmedia_sdp_media_find_attr(m: *const pjmedia_sdp_media, name: *const pj_str_t, fmt: *const pj_str_t) -> *mut pjmedia_sdp_attr; }

extern "C" { pub fn pjmedia_sdp_media_find_attr2(m: *const pjmedia_sdp_media, name: *const ::std::os::raw::c_char, fmt: *const pj_str_t) -> *mut pjmedia_sdp_attr; }

extern "C" { pub fn pjmedia_sdp_media_add_attr(m: *mut pjmedia_sdp_media, attr: *mut pjmedia_sdp_attr) -> pj_status_t; }

extern "C" { pub fn pjmedia_sdp_media_remove_all_attr(m: *mut pjmedia_sdp_media, name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_uint; }

extern "C" { pub fn pjmedia_sdp_media_remove_attr(m: *mut pjmedia_sdp_media, attr: *mut pjmedia_sdp_attr) -> pj_status_t; }

extern "C" { pub fn pjmedia_sdp_media_cmp(sd1: *const pjmedia_sdp_media, sd2: *const pjmedia_sdp_media, option: ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pjmedia_sdp_transport_cmp(t1: *const pj_str_t, t2: *const pj_str_t) -> pj_status_t; }

extern "C" { pub fn pjmedia_sdp_media_deactivate(pool: *mut pj_pool_t, m: *mut pjmedia_sdp_media) -> pj_status_t; }

extern "C" { pub fn pjmedia_sdp_media_clone_deactivate(pool: *mut pj_pool_t, rhs: *const pjmedia_sdp_media) -> *mut pjmedia_sdp_media; }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjmedia_sdp_session { pub origin: pjmedia_sdp_session__bindgen_ty_1, pub name: pj_str_t, pub conn: *mut pjmedia_sdp_conn, pub bandw_count: ::std::os::raw::c_uint, pub bandw: [*mut pjmedia_sdp_bandw; 4usize], pub time: pjmedia_sdp_session__bindgen_ty_2, pub attr_count: ::std::os::raw::c_uint, pub attr: [*mut pjmedia_sdp_attr; 68usize], pub media_count: ::std::os::raw::c_uint, pub media: [*mut pjmedia_sdp_media; 16usize] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_sdp_session__bindgen_ty_1 { pub user: pj_str_t, pub id: pj_uint32_t, pub version: pj_uint32_t, pub net_type: pj_str_t, pub addr_type: pj_str_t, pub addr: pj_str_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_sdp_session__bindgen_ty_2 { pub start: pj_uint32_t, pub stop: pj_uint32_t }

extern "C" { pub fn pjmedia_sdp_parse(pool: *mut pj_pool_t, buf: *mut ::std::os::raw::c_char, len: pj_size_t, p_sdp: *mut *mut pjmedia_sdp_session) -> pj_status_t; }

extern "C" { pub fn pjmedia_sdp_print(sdp: *const pjmedia_sdp_session, buf: *mut ::std::os::raw::c_char, size: pj_size_t) -> ::std::os::raw::c_int; }

extern "C" { pub fn pjmedia_sdp_validate(sdp: *const pjmedia_sdp_session) -> pj_status_t; }

extern "C" { pub fn pjmedia_sdp_validate2(sdp: *const pjmedia_sdp_session, strict: pj_bool_t) -> pj_status_t; }

extern "C" { pub fn pjmedia_sdp_session_clone(pool: *mut pj_pool_t, sdp: *const pjmedia_sdp_session) -> *mut pjmedia_sdp_session; }

extern "C" { pub fn pjmedia_sdp_session_cmp(sd1: *const pjmedia_sdp_session, sd2: *const pjmedia_sdp_session, option: ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pjmedia_sdp_session_add_attr(s: *mut pjmedia_sdp_session, attr: *mut pjmedia_sdp_attr) -> pj_status_t; }

extern "C" { pub fn pjmedia_strerror(status: pj_status_t, buffer: *mut ::std::os::raw::c_char, bufsize: pj_size_t) -> pj_str_t; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_tranport_media_option { PJMEDIA_TPMED_NO_TRANSPORT_CHECKING = 1 }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjmedia_sock_info { pub rtp_sock: pj_sock_t, pub rtp_addr_name: pj_sockaddr, pub rtcp_sock: pj_sock_t, pub rtcp_addr_name: pj_sockaddr }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_transport_op { pub get_info: ::std::option::Option<unsafe extern "C" fn(tp: *mut pjmedia_transport, info: *mut pjmedia_transport_info) -> pj_status_t>, pub attach: ::std::option::Option<unsafe extern "C" fn(tp: *mut pjmedia_transport, user_data: *mut ::std::os::raw::c_void, rem_addr: *const pj_sockaddr_t, rem_rtcp: *const pj_sockaddr_t, addr_len: ::std::os::raw::c_uint, rtp_cb: ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, pkt: *mut ::std::os::raw::c_void, size: pj_ssize_t)>, rtcp_cb: ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, pkt: *mut ::std::os::raw::c_void, size: pj_ssize_t)>) -> pj_status_t>, pub detach: ::std::option::Option<unsafe extern "C" fn(tp: *mut pjmedia_transport, user_data: *mut ::std::os::raw::c_void)>, pub send_rtp: ::std::option::Option<unsafe extern "C" fn(tp: *mut pjmedia_transport, pkt: *const ::std::os::raw::c_void, size: pj_size_t) -> pj_status_t>, pub send_rtcp: ::std::option::Option<unsafe extern "C" fn(tp: *mut pjmedia_transport, pkt: *const ::std::os::raw::c_void, size: pj_size_t) -> pj_status_t>, pub send_rtcp2: ::std::option::Option<unsafe extern "C" fn(tp: *mut pjmedia_transport, addr: *const pj_sockaddr_t, addr_len: ::std::os::raw::c_uint, pkt: *const ::std::os::raw::c_void, size: pj_size_t) -> pj_status_t>, pub media_create: ::std::option::Option<unsafe extern "C" fn(tp: *mut pjmedia_transport, sdp_pool: *mut pj_pool_t, options: ::std::os::raw::c_uint, remote_sdp: *const pjmedia_sdp_session, media_index: ::std::os::raw::c_uint) -> pj_status_t>, pub encode_sdp: ::std::option::Option<unsafe extern "C" fn(tp: *mut pjmedia_transport, sdp_pool: *mut pj_pool_t, sdp_local: *mut pjmedia_sdp_session, rem_sdp: *const pjmedia_sdp_session, media_index: ::std::os::raw::c_uint) -> pj_status_t>, pub media_start: ::std::option::Option<unsafe extern "C" fn(tp: *mut pjmedia_transport, tmp_pool: *mut pj_pool_t, sdp_local: *const pjmedia_sdp_session, sdp_remote: *const pjmedia_sdp_session, media_index: ::std::os::raw::c_uint) -> pj_status_t>, pub media_stop: ::std::option::Option<unsafe extern "C" fn(tp: *mut pjmedia_transport) -> pj_status_t>, pub simulate_lost: ::std::option::Option<unsafe extern "C" fn(tp: *mut pjmedia_transport, dir: pjmedia_dir, pct_lost: ::std::os::raw::c_uint) -> pj_status_t>, pub destroy: ::std::option::Option<unsafe extern "C" fn(tp: *mut pjmedia_transport) -> pj_status_t>, pub attach2: ::std::option::Option<unsafe extern "C" fn(tp: *mut pjmedia_transport, att_param: *mut pjmedia_transport_attach_param) -> pj_status_t> }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_transport_type { PJMEDIA_TRANSPORT_TYPE_UDP = 0, PJMEDIA_TRANSPORT_TYPE_ICE = 1, PJMEDIA_TRANSPORT_TYPE_SRTP = 2, PJMEDIA_TRANSPORT_TYPE_USER = 3 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_transport { pub name: [::std::os::raw::c_char; 32usize], pub type_: pjmedia_transport_type, pub op: *mut pjmedia_transport_op, pub user_data: *mut ::std::os::raw::c_void }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjmedia_transport_specific_info { pub type_: pjmedia_transport_type, pub cbsize: ::std::os::raw::c_int, pub buffer: [::std::os::raw::c_char; 144usize] }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjmedia_transport_info { pub sock_info: pjmedia_sock_info, pub src_rtp_name: pj_sockaddr, pub src_rtcp_name: pj_sockaddr, pub specific_info_cnt: ::std::os::raw::c_uint, pub spc_info: [pjmedia_transport_specific_info; 4usize] }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjmedia_transport_attach_param { pub stream: *mut ::std::os::raw::c_void, pub media_type: pjmedia_type, pub rem_addr: pj_sockaddr, pub rem_rtcp: pj_sockaddr, pub addr_len: ::std::os::raw::c_uint, pub user_data: *mut ::std::os::raw::c_void, pub rtp_cb: ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, pkt: *mut ::std::os::raw::c_void, arg1: pj_ssize_t)>, pub rtcp_cb: ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, pkt: *mut ::std::os::raw::c_void, arg1: pj_ssize_t)> }

extern "C" { pub fn pjmedia_audiodev_strerror(status: pj_status_t, buffer: *mut ::std::os::raw::c_char, bufsize: pj_size_t) -> pj_str_t; }

pub type pjmedia_aud_dev_index = pj_int32_t;

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_aud_dev_id { PJMEDIA_AUD_DEFAULT_CAPTURE_DEV = -1, PJMEDIA_AUD_DEFAULT_PLAYBACK_DEV = -2, PJMEDIA_AUD_INVALID_DEV = -3 }

pub type pjmedia_aud_dev_factory_create_func_ptr = ::std::option::Option<unsafe extern "C" fn(arg1: *mut pj_pool_factory) -> *mut pjmedia_aud_dev_factory>;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_aud_driver { pub create: pjmedia_aud_dev_factory_create_func_ptr, pub f: *mut pjmedia_aud_dev_factory, pub name: [::std::os::raw::c_char; 32usize], pub dev_cnt: ::std::os::raw::c_uint, pub start_idx: ::std::os::raw::c_uint, pub rec_dev_idx: ::std::os::raw::c_int, pub play_dev_idx: ::std::os::raw::c_int, pub dev_idx: ::std::os::raw::c_int }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjmedia_aud_subsys { pub init_count: ::std::os::raw::c_uint, pub pf: *mut pj_pool_factory, pub drv_cnt: ::std::os::raw::c_uint, pub drv: [pjmedia_aud_driver; 16usize], pub dev_cnt: ::std::os::raw::c_uint, pub dev_list: [pj_uint32_t; 64usize] }

impl pjmedia_aud_dev_cap { pub const PJMEDIA_AUD_DEV_CAP_INPUT_SOURCE: pjmedia_aud_dev_cap = pjmedia_aud_dev_cap::PJMEDIA_AUD_DEV_CAP_INPUT_ROUTE; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_aud_dev_cap { PJMEDIA_AUD_DEV_CAP_EXT_FORMAT = 1, PJMEDIA_AUD_DEV_CAP_INPUT_LATENCY = 2, PJMEDIA_AUD_DEV_CAP_OUTPUT_LATENCY = 4, PJMEDIA_AUD_DEV_CAP_INPUT_VOLUME_SETTING = 8, PJMEDIA_AUD_DEV_CAP_OUTPUT_VOLUME_SETTING = 16, PJMEDIA_AUD_DEV_CAP_INPUT_SIGNAL_METER = 32, PJMEDIA_AUD_DEV_CAP_OUTPUT_SIGNAL_METER = 64, PJMEDIA_AUD_DEV_CAP_INPUT_ROUTE = 128, PJMEDIA_AUD_DEV_CAP_OUTPUT_ROUTE = 256, PJMEDIA_AUD_DEV_CAP_EC = 512, PJMEDIA_AUD_DEV_CAP_EC_TAIL = 1024, PJMEDIA_AUD_DEV_CAP_VAD = 2048, PJMEDIA_AUD_DEV_CAP_CNG = 4096, PJMEDIA_AUD_DEV_CAP_PLC = 8192, PJMEDIA_AUD_DEV_CAP_MAX = 16384 }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_aud_dev_route { PJMEDIA_AUD_DEV_ROUTE_DEFAULT = 0, PJMEDIA_AUD_DEV_ROUTE_LOUDSPEAKER = 1, PJMEDIA_AUD_DEV_ROUTE_EARPIECE = 2, PJMEDIA_AUD_DEV_ROUTE_BLUETOOTH = 4, PJMEDIA_AUD_DEV_ROUTE_CUSTOM = 128 }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjmedia_aud_dev_info { pub name: [::std::os::raw::c_char; 64usize], pub input_count: ::std::os::raw::c_uint, pub output_count: ::std::os::raw::c_uint, pub default_samples_per_sec: ::std::os::raw::c_uint, pub driver: [::std::os::raw::c_char; 32usize], pub caps: ::std::os::raw::c_uint, pub routes: ::std::os::raw::c_uint, pub ext_fmt_cnt: ::std::os::raw::c_uint, pub ext_fmt: [pjmedia_format; 8usize] }

pub type pjmedia_aud_play_cb = ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, frame: *mut pjmedia_frame) -> pj_status_t>;
pub type pjmedia_aud_rec_cb = ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, frame: *mut pjmedia_frame) -> pj_status_t>;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjmedia_aud_param { pub dir: pjmedia_dir, pub rec_id: pjmedia_aud_dev_index, pub play_id: pjmedia_aud_dev_index, pub clock_rate: ::std::os::raw::c_uint, pub channel_count: ::std::os::raw::c_uint, pub samples_per_frame: ::std::os::raw::c_uint, pub bits_per_sample: ::std::os::raw::c_uint, pub flags: ::std::os::raw::c_uint, pub ext_fmt: pjmedia_format, pub input_latency_ms: ::std::os::raw::c_uint, pub output_latency_ms: ::std::os::raw::c_uint, pub input_vol: ::std::os::raw::c_uint, pub output_vol: ::std::os::raw::c_uint, pub input_route: pjmedia_aud_dev_route, pub output_route: pjmedia_aud_dev_route, pub ec_enabled: pj_bool_t, pub ec_tail_ms: ::std::os::raw::c_uint, pub plc_enabled: pj_bool_t, pub cng_enabled: pj_bool_t, pub vad_enabled: pj_bool_t }

extern "C" { pub fn pjmedia_get_aud_subsys() -> *mut pjmedia_aud_subsys; }

extern "C" { pub fn pjmedia_aud_driver_init(drv_idx: ::std::os::raw::c_uint, refresh: pj_bool_t) -> pj_status_t; }

extern "C" { pub fn pjmedia_aud_driver_deinit(drv_idx: ::std::os::raw::c_uint); }

extern "C" { pub fn pjmedia_aud_dev_cap_name(cap: pjmedia_aud_dev_cap, p_desc: *mut *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char; }

extern "C" { pub fn pjmedia_aud_param_set_cap(param: *mut pjmedia_aud_param, cap: pjmedia_aud_dev_cap, pval: *const ::std::os::raw::c_void) -> pj_status_t; }

extern "C" { pub fn pjmedia_aud_param_get_cap(param: *const pjmedia_aud_param, cap: pjmedia_aud_dev_cap, pval: *mut ::std::os::raw::c_void) -> pj_status_t; }

extern "C" { pub fn pjmedia_aud_dev_refresh() -> pj_status_t; }

extern "C" { pub fn pjmedia_aud_dev_count() -> ::std::os::raw::c_uint; }

extern "C" { pub fn pjmedia_aud_dev_get_info(id: pjmedia_aud_dev_index, info: *mut pjmedia_aud_dev_info) -> pj_status_t; }

extern "C" { pub fn pjmedia_aud_dev_lookup(drv_name: *const ::std::os::raw::c_char, dev_name: *const ::std::os::raw::c_char, id: *mut pjmedia_aud_dev_index) -> pj_status_t; }

extern "C" { pub fn pjmedia_aud_dev_default_param(id: pjmedia_aud_dev_index, param: *mut pjmedia_aud_param) -> pj_status_t; }

extern "C" { pub fn pjmedia_aud_stream_create(param: *const pjmedia_aud_param, rec_cb: pjmedia_aud_rec_cb, play_cb: pjmedia_aud_play_cb, user_data: *mut ::std::os::raw::c_void, p_strm: *mut *mut pjmedia_aud_stream) -> pj_status_t; }

extern "C" { pub fn pjmedia_aud_stream_get_param(strm: *mut pjmedia_aud_stream, param: *mut pjmedia_aud_param) -> pj_status_t; }

extern "C" { pub fn pjmedia_aud_stream_get_cap(strm: *mut pjmedia_aud_stream, cap: pjmedia_aud_dev_cap, value: *mut ::std::os::raw::c_void) -> pj_status_t; }

extern "C" { pub fn pjmedia_aud_stream_set_cap(strm: *mut pjmedia_aud_stream, cap: pjmedia_aud_dev_cap, value: *const ::std::os::raw::c_void) -> pj_status_t; }

extern "C" { pub fn pjmedia_aud_stream_start(strm: *mut pjmedia_aud_stream) -> pj_status_t; }

extern "C" { pub fn pjmedia_aud_stream_stop(strm: *mut pjmedia_aud_stream) -> pj_status_t; }

extern "C" { pub fn pjmedia_aud_stream_destroy(strm: *mut pjmedia_aud_stream) -> pj_status_t; }

extern "C" { pub fn pjmedia_aud_subsys_init(pf: *mut pj_pool_factory) -> pj_status_t; }

extern "C" { pub fn pjmedia_aud_subsys_get_pool_factory() -> *mut pj_pool_factory; }

extern "C" { pub fn pjmedia_aud_subsys_shutdown() -> pj_status_t; }

extern "C" { pub fn pjmedia_aud_register_factory(adf: pjmedia_aud_dev_factory_create_func_ptr) -> pj_status_t; }

extern "C" { pub fn pjmedia_aud_unregister_factory(adf: pjmedia_aud_dev_factory_create_func_ptr) -> pj_status_t; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_endpt_flag { PJMEDIA_ENDPT_HAS_TELEPHONE_EVENT_FLAG = 0 }

pub type pjmedia_endpt_exit_callback = ::std::option::Option<unsafe extern "C" fn(endpt: *mut pjmedia_endpt)>;

extern "C" { pub fn pjmedia_endpt_create2(pf: *mut pj_pool_factory, ioqueue: *mut pj_ioqueue_t, worker_cnt: ::std::os::raw::c_uint, p_endpt: *mut *mut pjmedia_endpt) -> pj_status_t; }

extern "C" { pub fn pjmedia_endpt_destroy2(endpt: *mut pjmedia_endpt) -> pj_status_t; }

extern "C" { pub fn pjmedia_endpt_set_flag(endpt: *mut pjmedia_endpt, flag: pjmedia_endpt_flag, value: *const ::std::os::raw::c_void) -> pj_status_t; }

extern "C" { pub fn pjmedia_endpt_get_flag(endpt: *mut pjmedia_endpt, flag: pjmedia_endpt_flag, value: *mut ::std::os::raw::c_void) -> pj_status_t; }

extern "C" { pub fn pjmedia_endpt_get_ioqueue(endpt: *mut pjmedia_endpt) -> *mut pj_ioqueue_t; }

extern "C" { pub fn pjmedia_endpt_get_thread_count(endpt: *mut pjmedia_endpt) -> ::std::os::raw::c_uint; }

extern "C" { pub fn pjmedia_endpt_get_thread(endpt: *mut pjmedia_endpt, index: ::std::os::raw::c_uint) -> *mut pj_thread_t; }

extern "C" { pub fn pjmedia_endpt_stop_threads(endpt: *mut pjmedia_endpt) -> pj_status_t; }

extern "C" { pub fn pjmedia_endpt_create_pool(endpt: *mut pjmedia_endpt, name: *const ::std::os::raw::c_char, initial: pj_size_t, increment: pj_size_t) -> *mut pj_pool_t; }

extern "C" { pub fn pjmedia_endpt_get_codec_mgr(endpt: *mut pjmedia_endpt) -> *mut pjmedia_codec_mgr; }

extern "C" { pub fn pjmedia_endpt_create_sdp(endpt: *mut pjmedia_endpt, pool: *mut pj_pool_t, stream_cnt: ::std::os::raw::c_uint, sock_info: *const pjmedia_sock_info, p_sdp: *mut *mut pjmedia_sdp_session) -> pj_status_t; }

extern "C" { pub fn pjmedia_endpt_create_base_sdp(endpt: *mut pjmedia_endpt, pool: *mut pj_pool_t, sess_name: *const pj_str_t, origin: *const pj_sockaddr, p_sdp: *mut *mut pjmedia_sdp_session) -> pj_status_t; }

extern "C" { pub fn pjmedia_endpt_create_audio_sdp(endpt: *mut pjmedia_endpt, pool: *mut pj_pool_t, si: *const pjmedia_sock_info, options: ::std::os::raw::c_uint, p_m: *mut *mut pjmedia_sdp_media) -> pj_status_t; }

extern "C" { pub fn pjmedia_endpt_create_video_sdp(endpt: *mut pjmedia_endpt, pool: *mut pj_pool_t, si: *const pjmedia_sock_info, options: ::std::os::raw::c_uint, p_m: *mut *mut pjmedia_sdp_media) -> pj_status_t; }

extern "C" { pub fn pjmedia_endpt_dump(endpt: *mut pjmedia_endpt) -> pj_status_t; }

extern "C" { pub fn pjmedia_endpt_atexit(endpt: *mut pjmedia_endpt, func: pjmedia_endpt_exit_callback) -> pj_status_t; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_audio_pt { PJMEDIA_RTP_PT_START = 96, PJMEDIA_RTP_PT_SPEEX_NB = 97, PJMEDIA_RTP_PT_SPEEX_WB = 98, PJMEDIA_RTP_PT_SPEEX_UWB = 99, PJMEDIA_RTP_PT_SILK_NB = 100, PJMEDIA_RTP_PT_SILK_MB = 101, PJMEDIA_RTP_PT_SILK_WB = 102, PJMEDIA_RTP_PT_SILK_SWB = 103, PJMEDIA_RTP_PT_ILBC = 104, PJMEDIA_RTP_PT_AMR = 105, PJMEDIA_RTP_PT_AMRWB = 106, PJMEDIA_RTP_PT_AMRWBE = 107, PJMEDIA_RTP_PT_G726_16 = 108, PJMEDIA_RTP_PT_G726_24 = 109, PJMEDIA_RTP_PT_G726_32 = 110, PJMEDIA_RTP_PT_G726_40 = 111, PJMEDIA_RTP_PT_G722_1_16 = 112, PJMEDIA_RTP_PT_G722_1_24 = 113, PJMEDIA_RTP_PT_G722_1_32 = 114, PJMEDIA_RTP_PT_G7221C_24 = 115, PJMEDIA_RTP_PT_G7221C_32 = 116, PJMEDIA_RTP_PT_G7221C_48 = 117, PJMEDIA_RTP_PT_G7221_RSV1 = 118, PJMEDIA_RTP_PT_G7221_RSV2 = 119, PJMEDIA_RTP_PT_OPUS = 120 }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_video_pt { PJMEDIA_RTP_PT_VID_START = 95, PJMEDIA_RTP_PT_H263P = 96, PJMEDIA_RTP_PT_H264 = 97, PJMEDIA_RTP_PT_H264_RSV1 = 98, PJMEDIA_RTP_PT_H264_RSV2 = 99, PJMEDIA_RTP_PT_H264_RSV3 = 100, PJMEDIA_RTP_PT_H264_RSV4 = 101 }

extern "C" { pub fn pjmedia_codec_g711_init(endpt: *mut pjmedia_endpt) -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_g711_deinit() -> pj_status_t; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_jb_frame_type { PJMEDIA_JB_MISSING_FRAME = 0, PJMEDIA_JB_NORMAL_FRAME = 1, PJMEDIA_JB_ZERO_PREFETCH_FRAME = 2, PJMEDIA_JB_ZERO_EMPTY_FRAME = 3 }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_jb_discard_algo { PJMEDIA_JB_DISCARD_NONE = 0, PJMEDIA_JB_DISCARD_STATIC = 1, PJMEDIA_JB_DISCARD_PROGRESSIVE = 2 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_jb_state { pub frame_size: ::std::os::raw::c_uint, pub min_prefetch: ::std::os::raw::c_uint, pub max_prefetch: ::std::os::raw::c_uint, pub burst: ::std::os::raw::c_uint, pub prefetch: ::std::os::raw::c_uint, pub size: ::std::os::raw::c_uint, pub avg_delay: ::std::os::raw::c_uint, pub min_delay: ::std::os::raw::c_uint, pub max_delay: ::std::os::raw::c_uint, pub dev_delay: ::std::os::raw::c_uint, pub avg_burst: ::std::os::raw::c_uint, pub lost: ::std::os::raw::c_uint, pub discard: ::std::os::raw::c_uint, pub empty: ::std::os::raw::c_uint }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_jbuf { _unused: [u8; 0] }

extern "C" { pub fn pjmedia_jbuf_create(pool: *mut pj_pool_t, name: *const pj_str_t, frame_size: ::std::os::raw::c_uint, ptime: ::std::os::raw::c_uint, max_count: ::std::os::raw::c_uint, p_jb: *mut *mut pjmedia_jbuf) -> pj_status_t; }

extern "C" { pub fn pjmedia_jbuf_set_fixed(jb: *mut pjmedia_jbuf, prefetch: ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pjmedia_jbuf_set_adaptive(jb: *mut pjmedia_jbuf, prefetch: ::std::os::raw::c_uint, min_prefetch: ::std::os::raw::c_uint, max_prefetch: ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pjmedia_jbuf_set_discard(jb: *mut pjmedia_jbuf, algo: pjmedia_jb_discard_algo) -> pj_status_t; }

extern "C" { pub fn pjmedia_jbuf_destroy(jb: *mut pjmedia_jbuf) -> pj_status_t; }

extern "C" { pub fn pjmedia_jbuf_reset(jb: *mut pjmedia_jbuf) -> pj_status_t; }

extern "C" { pub fn pjmedia_jbuf_put_frame(jb: *mut pjmedia_jbuf, frame: *const ::std::os::raw::c_void, size: pj_size_t, frame_seq: ::std::os::raw::c_int); }

extern "C" { pub fn pjmedia_jbuf_put_frame2(jb: *mut pjmedia_jbuf, frame: *const ::std::os::raw::c_void, size: pj_size_t, bit_info: pj_uint32_t, frame_seq: ::std::os::raw::c_int, discarded: *mut pj_bool_t); }

extern "C" { pub fn pjmedia_jbuf_put_frame3(jb: *mut pjmedia_jbuf, frame: *const ::std::os::raw::c_void, size: pj_size_t, bit_info: pj_uint32_t, frame_seq: ::std::os::raw::c_int, frame_ts: pj_uint32_t, discarded: *mut pj_bool_t); }

extern "C" { pub fn pjmedia_jbuf_get_frame(jb: *mut pjmedia_jbuf, frame: *mut ::std::os::raw::c_void, p_frm_type: *mut ::std::os::raw::c_char); }

extern "C" { pub fn pjmedia_jbuf_get_frame2(jb: *mut pjmedia_jbuf, frame: *mut ::std::os::raw::c_void, size: *mut pj_size_t, p_frm_type: *mut ::std::os::raw::c_char, bit_info: *mut pj_uint32_t); }

extern "C" { pub fn pjmedia_jbuf_get_frame3(jb: *mut pjmedia_jbuf, frame: *mut ::std::os::raw::c_void, size: *mut pj_size_t, p_frm_type: *mut ::std::os::raw::c_char, bit_info: *mut pj_uint32_t, ts: *mut pj_uint32_t, seq: *mut ::std::os::raw::c_int); }

extern "C" { pub fn pjmedia_jbuf_peek_frame(jb: *mut pjmedia_jbuf, offset: ::std::os::raw::c_uint, frame: *mut *const ::std::os::raw::c_void, size: *mut pj_size_t, p_frm_type: *mut ::std::os::raw::c_char, bit_info: *mut pj_uint32_t, ts: *mut pj_uint32_t, seq: *mut ::std::os::raw::c_int); }

extern "C" { pub fn pjmedia_jbuf_remove_frame(jb: *mut pjmedia_jbuf, frame_cnt: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint; }

extern "C" { pub fn pjmedia_jbuf_is_full(jb: *const pjmedia_jbuf) -> pj_bool_t; }

extern "C" { pub fn pjmedia_jbuf_get_state(jb: *const pjmedia_jbuf, state: *mut pjmedia_jb_state) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_master_port { _unused: [u8; 0] }

extern "C" { pub fn pjmedia_master_port_create(pool: *mut pj_pool_t, u_port: *mut pjmedia_port, d_port: *mut pjmedia_port, options: ::std::os::raw::c_uint, p_m: *mut *mut pjmedia_master_port) -> pj_status_t; }

extern "C" { pub fn pjmedia_master_port_start(m: *mut pjmedia_master_port) -> pj_status_t; }

extern "C" { pub fn pjmedia_master_port_stop(m: *mut pjmedia_master_port) -> pj_status_t; }

extern "C" { pub fn pjmedia_master_port_wait(m: *mut pjmedia_master_port, wait: pj_bool_t, ts: *mut pj_timestamp) -> pj_bool_t; }

extern "C" { pub fn pjmedia_master_port_set_uport(m: *mut pjmedia_master_port, port: *mut pjmedia_port) -> pj_status_t; }

extern "C" { pub fn pjmedia_master_port_get_uport(m: *mut pjmedia_master_port) -> *mut pjmedia_port; }

extern "C" { pub fn pjmedia_master_port_set_dport(m: *mut pjmedia_master_port, port: *mut pjmedia_port) -> pj_status_t; }

extern "C" { pub fn pjmedia_master_port_get_dport(m: *mut pjmedia_master_port) -> *mut pjmedia_port; }

extern "C" { pub fn pjmedia_master_port_destroy(m: *mut pjmedia_master_port, destroy_ports: pj_bool_t) -> pj_status_t; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_mem_player_option { PJMEDIA_MEM_NO_LOOP = 1 }

extern "C" { pub fn pjmedia_mem_player_create(pool: *mut pj_pool_t, buffer: *const ::std::os::raw::c_void, size: pj_size_t, clock_rate: ::std::os::raw::c_uint, channel_count: ::std::os::raw::c_uint, samples_per_frame: ::std::os::raw::c_uint, bits_per_sample: ::std::os::raw::c_uint, options: ::std::os::raw::c_uint, p_port: *mut *mut pjmedia_port) -> pj_status_t; }

extern "C" { pub fn pjmedia_mem_player_set_eof_cb(port: *mut pjmedia_port, user_data: *mut ::std::os::raw::c_void, cb: ::std::option::Option<unsafe extern "C" fn(port: *mut pjmedia_port, usr_data: *mut ::std::os::raw::c_void) -> pj_status_t>) -> pj_status_t; }

extern "C" { pub fn pjmedia_mem_capture_create(pool: *mut pj_pool_t, buffer: *mut ::std::os::raw::c_void, size: pj_size_t, clock_rate: ::std::os::raw::c_uint, channel_count: ::std::os::raw::c_uint, samples_per_frame: ::std::os::raw::c_uint, bits_per_sample: ::std::os::raw::c_uint, options: ::std::os::raw::c_uint, p_port: *mut *mut pjmedia_port) -> pj_status_t; }

extern "C" { pub fn pjmedia_mem_capture_set_eof_cb(port: *mut pjmedia_port, user_data: *mut ::std::os::raw::c_void, cb: ::std::option::Option<unsafe extern "C" fn(port: *mut pjmedia_port, usr_data: *mut ::std::os::raw::c_void) -> pj_status_t>) -> pj_status_t; }

extern "C" { pub fn pjmedia_mem_capture_get_size(port: *mut pjmedia_port) -> pj_size_t; }

extern "C" { pub fn pjmedia_null_port_create(pool: *mut pj_pool_t, sampling_rate: ::std::os::raw::c_uint, channel_count: ::std::os::raw::c_uint, samples_per_frame: ::std::os::raw::c_uint, bits_per_sample: ::std::os::raw::c_uint, p_port: *mut *mut pjmedia_port) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_plc { _unused: [u8; 0] }

extern "C" { pub fn pjmedia_plc_create(pool: *mut pj_pool_t, clock_rate: ::std::os::raw::c_uint, samples_per_frame: ::std::os::raw::c_uint, options: ::std::os::raw::c_uint, p_plc: *mut *mut pjmedia_plc) -> pj_status_t; }

extern "C" { pub fn pjmedia_plc_save(plc: *mut pjmedia_plc, frame: *mut pj_int16_t) -> pj_status_t; }

extern "C" { pub fn pjmedia_plc_generate(plc: *mut pjmedia_plc, frame: *mut pj_int16_t) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_resample { _unused: [u8; 0] }

extern "C" { pub fn pjmedia_resample_create(pool: *mut pj_pool_t, high_quality: pj_bool_t, large_filter: pj_bool_t, channel_count: ::std::os::raw::c_uint, rate_in: ::std::os::raw::c_uint, rate_out: ::std::os::raw::c_uint, samples_per_frame: ::std::os::raw::c_uint, p_resample: *mut *mut pjmedia_resample) -> pj_status_t; }

extern "C" { pub fn pjmedia_resample_run(resample: *mut pjmedia_resample, input: *const pj_int16_t, output: *mut pj_int16_t); }

extern "C" { pub fn pjmedia_resample_get_input_size(resample: *mut pjmedia_resample) -> ::std::os::raw::c_uint; }

extern "C" { pub fn pjmedia_resample_destroy(resample: *mut pjmedia_resample); }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_resample_port_options { PJMEDIA_RESAMPLE_USE_LINEAR = 1, PJMEDIA_RESAMPLE_USE_SMALL_FILTER = 2, PJMEDIA_RESAMPLE_DONT_DESTROY_DN = 4 }

extern "C" { pub fn pjmedia_resample_port_create(pool: *mut pj_pool_t, dn_port: *mut pjmedia_port, clock_rate: ::std::os::raw::c_uint, options: ::std::os::raw::c_uint, p_port: *mut *mut pjmedia_port) -> pj_status_t; }

pub type pj_highprec_t = f64;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_math_stat { pub n: ::std::os::raw::c_int, pub max: ::std::os::raw::c_int, pub min: ::std::os::raw::c_int, pub last: ::std::os::raw::c_int, pub mean: ::std::os::raw::c_int, pub fmean_: f32, pub m2_: pj_highprec_t }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_rtcp_xr_type { PJMEDIA_RTCP_XR_LOSS_RLE = 1, PJMEDIA_RTCP_XR_DUP_RLE = 2, PJMEDIA_RTCP_XR_RCPT_TIMES = 4, PJMEDIA_RTCP_XR_RR_TIME = 8, PJMEDIA_RTCP_XR_DLRR = 16, PJMEDIA_RTCP_XR_STATS = 32, PJMEDIA_RTCP_XR_VOIP_METRICS = 64 }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_rtcp_xr_info { PJMEDIA_RTCP_XR_INFO_SIGNAL_LVL = 1, PJMEDIA_RTCP_XR_INFO_NOISE_LVL = 2, PJMEDIA_RTCP_XR_INFO_RERL = 3, PJMEDIA_RTCP_XR_INFO_R_FACTOR = 4, PJMEDIA_RTCP_XR_INFO_MOS_LQ = 5, PJMEDIA_RTCP_XR_INFO_MOS_CQ = 6, PJMEDIA_RTCP_XR_INFO_CONF_PLC = 7, PJMEDIA_RTCP_XR_INFO_CONF_JBA = 8, PJMEDIA_RTCP_XR_INFO_CONF_JBR = 9, PJMEDIA_RTCP_XR_INFO_JB_NOM = 10, PJMEDIA_RTCP_XR_INFO_JB_MAX = 11, PJMEDIA_RTCP_XR_INFO_JB_ABS_MAX = 12 }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_rtcp_xr_plc_type { PJMEDIA_RTCP_XR_PLC_UNK = 0, PJMEDIA_RTCP_XR_PLC_DIS = 1, PJMEDIA_RTCP_XR_PLC_ENH = 2, PJMEDIA_RTCP_XR_PLC_STD = 3 }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_rtcp_xr_jb_type { PJMEDIA_RTCP_XR_JB_UNKNOWN = 0, PJMEDIA_RTCP_XR_JB_FIXED = 2, PJMEDIA_RTCP_XR_JB_ADAPTIVE = 3 }

#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_rtcp_xr_rb_header { pub bt: pj_uint8_t, pub specific: pj_uint8_t, pub length: pj_uint16_t }

#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_rtcp_xr_rb_rr_time { pub header: pjmedia_rtcp_xr_rb_header, pub ntp_sec: pj_uint32_t, pub ntp_frac: pj_uint32_t }

#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_rtcp_xr_rb_dlrr_item { pub ssrc: pj_uint32_t, pub lrr: pj_uint32_t, pub dlrr: pj_uint32_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_rtcp_xr_rb_dlrr { pub header: pjmedia_rtcp_xr_rb_header, pub item: pjmedia_rtcp_xr_rb_dlrr_item }

#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_rtcp_xr_rb_stats { pub header: pjmedia_rtcp_xr_rb_header, pub ssrc: pj_uint32_t, pub begin_seq: pj_uint16_t, pub end_seq: pj_uint16_t, pub lost: pj_uint32_t, pub dup: pj_uint32_t, pub jitter_min: pj_uint32_t, pub jitter_max: pj_uint32_t, pub jitter_mean: pj_uint32_t, pub jitter_dev: pj_uint32_t, pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8> }

impl pjmedia_rtcp_xr_rb_stats {
    #[inline]
    pub fn toh_min(&self) -> pj_uint32_t { unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) } }
    #[inline]
    pub fn set_toh_min(&mut self, val: pj_uint32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn toh_max(&self) -> pj_uint32_t { unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) } }
    #[inline]
    pub fn set_toh_max(&mut self, val: pj_uint32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn toh_mean(&self) -> pj_uint32_t { unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) } }
    #[inline]
    pub fn set_toh_mean(&mut self, val: pj_uint32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn toh_dev(&self) -> pj_uint32_t { unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) } }
    #[inline]
    pub fn set_toh_dev(&mut self, val: pj_uint32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(toh_min: pj_uint32_t, toh_max: pj_uint32_t, toh_mean: pj_uint32_t, toh_dev: pj_uint32_t) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let toh_min: u32 = unsafe { ::std::mem::transmute(toh_min) };
            toh_min as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let toh_max: u32 = unsafe { ::std::mem::transmute(toh_max) };
            toh_max as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let toh_mean: u32 = unsafe { ::std::mem::transmute(toh_mean) };
            toh_mean as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let toh_dev: u32 = unsafe { ::std::mem::transmute(toh_dev) };
            toh_dev as u64
        });
        __bindgen_bitfield_unit
    }
}

#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_rtcp_xr_rb_voip_mtc { pub header: pjmedia_rtcp_xr_rb_header, pub ssrc: pj_uint32_t, pub loss_rate: pj_uint8_t, pub discard_rate: pj_uint8_t, pub burst_den: pj_uint8_t, pub gap_den: pj_uint8_t, pub burst_dur: pj_uint16_t, pub gap_dur: pj_uint16_t, pub rnd_trip_delay: pj_uint16_t, pub end_sys_delay: pj_uint16_t, pub signal_lvl: pj_uint8_t, pub noise_lvl: pj_uint8_t, pub rerl: pj_uint8_t, pub gmin: pj_uint8_t, pub r_factor: pj_uint8_t, pub ext_r_factor: pj_uint8_t, pub mos_lq: pj_uint8_t, pub mos_cq: pj_uint8_t, pub rx_config: pj_uint8_t, pub reserved2: pj_uint8_t, pub jb_nom: pj_uint16_t, pub jb_max: pj_uint16_t, pub jb_abs_max: pj_uint16_t }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjmedia_rtcp_xr_pkt { pub common: pjmedia_rtcp_xr_pkt__bindgen_ty_1, pub buf: [pj_int8_t; 104usize] }

#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_rtcp_xr_pkt__bindgen_ty_1 { pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>, pub ssrc: pj_uint32_t }

impl pjmedia_rtcp_xr_pkt__bindgen_ty_1 {
    #[inline]
    pub fn count(&self) -> ::std::os::raw::c_uint { unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) } }
    #[inline]
    pub fn set_count(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn p(&self) -> ::std::os::raw::c_uint { unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) } }
    #[inline]
    pub fn set_p(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn version(&self) -> ::std::os::raw::c_uint { unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u32) } }
    #[inline]
    pub fn set_version(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn pt(&self) -> ::std::os::raw::c_uint { unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) } }
    #[inline]
    pub fn set_pt(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn length(&self) -> ::std::os::raw::c_uint { unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) } }
    #[inline]
    pub fn set_length(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(count: ::std::os::raw::c_uint, p: ::std::os::raw::c_uint, version: ::std::os::raw::c_uint, pt: ::std::os::raw::c_uint, length: ::std::os::raw::c_uint) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let count: u32 = unsafe { ::std::mem::transmute(count) };
            count as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let p: u32 = unsafe { ::std::mem::transmute(p) };
            p as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let version: u32 = unsafe { ::std::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let pt: u32 = unsafe { ::std::mem::transmute(pt) };
            pt as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let length: u32 = unsafe { ::std::mem::transmute(length) };
            length as u64
        });
        __bindgen_bitfield_unit
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_rtcp_xr_stream_stat { pub stat_sum: pjmedia_rtcp_xr_stream_stat__bindgen_ty_1, pub voip_mtc: pjmedia_rtcp_xr_stream_stat__bindgen_ty_2 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_rtcp_xr_stream_stat__bindgen_ty_1 { pub update: pj_time_val, pub begin_seq: pj_uint32_t, pub end_seq: pj_uint32_t, pub count: ::std::os::raw::c_uint, pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>, pub lost: ::std::os::raw::c_uint, pub dup: ::std::os::raw::c_uint, pub jitter: pj_math_stat, pub toh: pj_math_stat }

impl pjmedia_rtcp_xr_stream_stat__bindgen_ty_1 {
    #[inline]
    pub fn l(&self) -> ::std::os::raw::c_uint { unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) } }
    #[inline]
    pub fn set_l(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn d(&self) -> ::std::os::raw::c_uint { unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) } }
    #[inline]
    pub fn set_d(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn j(&self) -> ::std::os::raw::c_uint { unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) } }
    #[inline]
    pub fn set_j(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn t(&self) -> ::std::os::raw::c_uint { unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u32) } }
    #[inline]
    pub fn set_t(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(l: ::std::os::raw::c_uint, d: ::std::os::raw::c_uint, j: ::std::os::raw::c_uint, t: ::std::os::raw::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let l: u32 = unsafe { ::std::mem::transmute(l) };
            l as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let d: u32 = unsafe { ::std::mem::transmute(d) };
            d as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let j: u32 = unsafe { ::std::mem::transmute(j) };
            j as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let t: u32 = unsafe { ::std::mem::transmute(t) };
            t as u64
        });
        __bindgen_bitfield_unit
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_rtcp_xr_stream_stat__bindgen_ty_2 { pub update: pj_time_val, pub loss_rate: pj_uint8_t, pub discard_rate: pj_uint8_t, pub burst_den: pj_uint8_t, pub gap_den: pj_uint8_t, pub burst_dur: pj_uint16_t, pub gap_dur: pj_uint16_t, pub rnd_trip_delay: pj_uint16_t, pub end_sys_delay: pj_uint16_t, pub signal_lvl: pj_int8_t, pub noise_lvl: pj_int8_t, pub rerl: pj_uint8_t, pub gmin: pj_uint8_t, pub r_factor: pj_uint8_t, pub ext_r_factor: pj_uint8_t, pub mos_lq: pj_uint8_t, pub mos_cq: pj_uint8_t, pub rx_config: pj_uint8_t, pub jb_nom: pj_uint16_t, pub jb_max: pj_uint16_t, pub jb_abs_max: pj_uint16_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_rtcp_xr_stat { pub rx: pjmedia_rtcp_xr_stream_stat, pub tx: pjmedia_rtcp_xr_stream_stat, pub rtt: pj_math_stat }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjmedia_rtcp_xr_session { pub name: *mut ::std::os::raw::c_char, pub pkt: pjmedia_rtcp_xr_pkt, pub rx_lrr: pj_uint32_t, pub rx_lrr_time: pj_timestamp, pub rx_last_rr: pj_uint32_t, pub stat: pjmedia_rtcp_xr_stat, pub src_ref_seq: pj_uint32_t, pub uninitialized_src_ref_seq: pj_bool_t, pub voip_mtc_stat: pjmedia_rtcp_xr_session__bindgen_ty_1, pub ptime: ::std::os::raw::c_uint, pub frames_per_packet: ::std::os::raw::c_uint, pub rtcp_session: *mut pjmedia_rtcp_session }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_rtcp_xr_session__bindgen_ty_1 { pub pkt: pj_uint32_t, pub lost: pj_uint32_t, pub loss_count: pj_uint32_t, pub discard_count: pj_uint32_t, pub c11: pj_uint32_t, pub c13: pj_uint32_t, pub c14: pj_uint32_t, pub c22: pj_uint32_t, pub c23: pj_uint32_t, pub c33: pj_uint32_t }

extern "C" { pub fn pjmedia_rtcp_build_rtcp_xr(session: *mut pjmedia_rtcp_xr_session, rpt_types: ::std::os::raw::c_uint, rtcp_pkt: *mut *mut ::std::os::raw::c_void, len: *mut ::std::os::raw::c_int); }

extern "C" { pub fn pjmedia_rtcp_xr_update_info(session: *mut pjmedia_rtcp_xr_session, info: ::std::os::raw::c_uint, val: pj_int32_t) -> pj_status_t; }

extern "C" { pub fn pjmedia_rtcp_xr_init(session: *mut pjmedia_rtcp_xr_session, r_session: *mut pjmedia_rtcp_session, gmin: pj_uint8_t, frames_per_packet: ::std::os::raw::c_uint); }

extern "C" { pub fn pjmedia_rtcp_xr_fini(session: *mut pjmedia_rtcp_xr_session); }

extern "C" { pub fn pjmedia_rtcp_xr_rx_rtcp_xr(session: *mut pjmedia_rtcp_xr_session, rtcp_pkt: *const ::std::os::raw::c_void, size: pj_size_t); }

extern "C" { pub fn pjmedia_rtcp_xr_rx_rtp(session: *mut pjmedia_rtcp_xr_session, seq: ::std::os::raw::c_uint, lost: ::std::os::raw::c_int, dup: ::std::os::raw::c_int, discarded: ::std::os::raw::c_int, jitter: ::std::os::raw::c_int, toh: ::std::os::raw::c_int, toh_ipv4: pj_bool_t); }

extern "C" { pub fn pjmedia_rtcp_xr_tx_rtp(session: *mut pjmedia_rtcp_xr_session, ptsize: ::std::os::raw::c_uint); }

#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_rtp_hdr { pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>, pub seq: pj_uint16_t, pub ts: pj_uint32_t, pub ssrc: pj_uint32_t }

impl pjmedia_rtp_hdr {
    #[inline]
    pub fn cc(&self) -> pj_uint16_t { unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) } }
    #[inline]
    pub fn set_cc(&mut self, val: pj_uint16_t) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn x(&self) -> pj_uint16_t { unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) } }
    #[inline]
    pub fn set_x(&mut self, val: pj_uint16_t) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn p(&self) -> pj_uint16_t { unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) } }
    #[inline]
    pub fn set_p(&mut self, val: pj_uint16_t) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn v(&self) -> pj_uint16_t { unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u16) } }
    #[inline]
    pub fn set_v(&mut self, val: pj_uint16_t) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn pt(&self) -> pj_uint16_t { unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 7u8) as u16) } }
    #[inline]
    pub fn set_pt(&mut self, val: pj_uint16_t) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn m(&self) -> pj_uint16_t { unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) } }
    #[inline]
    pub fn set_m(&mut self, val: pj_uint16_t) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(cc: pj_uint16_t, x: pj_uint16_t, p: pj_uint16_t, v: pj_uint16_t, pt: pj_uint16_t, m: pj_uint16_t) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let cc: u16 = unsafe { ::std::mem::transmute(cc) };
            cc as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let x: u16 = unsafe { ::std::mem::transmute(x) };
            x as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let p: u16 = unsafe { ::std::mem::transmute(p) };
            p as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let v: u16 = unsafe { ::std::mem::transmute(v) };
            v as u64
        });
        __bindgen_bitfield_unit.set(8usize, 7u8, {
            let pt: u16 = unsafe { ::std::mem::transmute(pt) };
            pt as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let m: u16 = unsafe { ::std::mem::transmute(m) };
            m as u64
        });
        __bindgen_bitfield_unit
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_rtp_ext_hdr { pub profile_data: pj_uint16_t, pub length: pj_uint16_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_rtp_dec_hdr { pub ext_hdr: *mut pjmedia_rtp_ext_hdr, pub ext: *mut pj_uint32_t, pub ext_len: ::std::os::raw::c_uint }

#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_rtp_dtmf_event { pub event: pj_uint8_t, pub e_vol: pj_uint8_t, pub duration: pj_uint16_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_rtp_seq_session { pub max_seq: pj_uint16_t, pub cycles: pj_uint32_t, pub base_seq: pj_uint32_t, pub bad_seq: pj_uint32_t, pub probation: pj_uint32_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_rtp_session { pub out_hdr: pjmedia_rtp_hdr, pub seq_ctrl: pjmedia_rtp_seq_session, pub out_pt: pj_uint16_t, pub out_extseq: pj_uint32_t, pub peer_ssrc: pj_uint32_t, pub received: pj_uint32_t }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjmedia_rtp_status { pub status: pjmedia_rtp_status__bindgen_ty_1, pub diff: pj_uint16_t }

#[repr(C)]
#[derive(Copy, Clone)]
pub union pjmedia_rtp_status__bindgen_ty_1 { pub flag: pjmedia_rtp_status__bindgen_ty_1_flag, pub value: pj_uint16_t, _bindgen_union_align: u32 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_rtp_status__bindgen_ty_1_flag { pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>, pub __bindgen_padding_0: [u8; 3usize], pub __bindgen_align: [u32; 0usize] }

impl pjmedia_rtp_status__bindgen_ty_1_flag {
    #[inline]
    pub fn bad(&self) -> ::std::os::raw::c_int { unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) } }
    #[inline]
    pub fn set_bad(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn badpt(&self) -> ::std::os::raw::c_int { unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) } }
    #[inline]
    pub fn set_badpt(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn badssrc(&self) -> ::std::os::raw::c_int { unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) } }
    #[inline]
    pub fn set_badssrc(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dup(&self) -> ::std::os::raw::c_int { unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) } }
    #[inline]
    pub fn set_dup(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outorder(&self) -> ::std::os::raw::c_int { unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) } }
    #[inline]
    pub fn set_outorder(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn probation(&self) -> ::std::os::raw::c_int { unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) } }
    #[inline]
    pub fn set_probation(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn restart(&self) -> ::std::os::raw::c_int { unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) } }
    #[inline]
    pub fn set_restart(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(bad: ::std::os::raw::c_int, badpt: ::std::os::raw::c_int, badssrc: ::std::os::raw::c_int, dup: ::std::os::raw::c_int, outorder: ::std::os::raw::c_int, probation: ::std::os::raw::c_int, restart: ::std::os::raw::c_int) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bad: u32 = unsafe { ::std::mem::transmute(bad) };
            bad as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let badpt: u32 = unsafe { ::std::mem::transmute(badpt) };
            badpt as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let badssrc: u32 = unsafe { ::std::mem::transmute(badssrc) };
            badssrc as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let dup: u32 = unsafe { ::std::mem::transmute(dup) };
            dup as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let outorder: u32 = unsafe { ::std::mem::transmute(outorder) };
            outorder as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let probation: u32 = unsafe { ::std::mem::transmute(probation) };
            probation as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let restart: u32 = unsafe { ::std::mem::transmute(restart) };
            restart as u64
        });
        __bindgen_bitfield_unit
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_rtp_session_setting { pub flags: pj_uint8_t, pub default_pt: ::std::os::raw::c_int, pub sender_ssrc: pj_uint32_t, pub seq: pj_uint16_t, pub ts: pj_uint32_t }

extern "C" { pub fn pjmedia_rtp_session_init(ses: *mut pjmedia_rtp_session, default_pt: ::std::os::raw::c_int, sender_ssrc: pj_uint32_t) -> pj_status_t; }

extern "C" { pub fn pjmedia_rtp_session_init2(ses: *mut pjmedia_rtp_session, settings: pjmedia_rtp_session_setting) -> pj_status_t; }

extern "C" { pub fn pjmedia_rtp_encode_rtp(ses: *mut pjmedia_rtp_session, pt: ::std::os::raw::c_int, m: ::std::os::raw::c_int, payload_len: ::std::os::raw::c_int, ts_len: ::std::os::raw::c_int, rtphdr: *mut *const ::std::os::raw::c_void, hdrlen: *mut ::std::os::raw::c_int) -> pj_status_t; }

extern "C" { pub fn pjmedia_rtp_decode_rtp(ses: *mut pjmedia_rtp_session, pkt: *const ::std::os::raw::c_void, pkt_len: ::std::os::raw::c_int, hdr: *mut *const pjmedia_rtp_hdr, payload: *mut *const ::std::os::raw::c_void, payloadlen: *mut ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pjmedia_rtp_decode_rtp2(ses: *mut pjmedia_rtp_session, pkt: *const ::std::os::raw::c_void, pkt_len: ::std::os::raw::c_int, hdr: *mut *const pjmedia_rtp_hdr, dec_hdr: *mut pjmedia_rtp_dec_hdr, payload: *mut *const ::std::os::raw::c_void, payloadlen: *mut ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pjmedia_rtp_session_update(ses: *mut pjmedia_rtp_session, hdr: *const pjmedia_rtp_hdr, seq_st: *mut pjmedia_rtp_status); }

extern "C" { pub fn pjmedia_rtp_session_update2(ses: *mut pjmedia_rtp_session, hdr: *const pjmedia_rtp_hdr, seq_st: *mut pjmedia_rtp_status, check_pt: pj_bool_t); }

extern "C" { pub fn pjmedia_rtp_seq_init(seq_ctrl: *mut pjmedia_rtp_seq_session, seq: pj_uint16_t); }

extern "C" { pub fn pjmedia_rtp_seq_update(seq_ctrl: *mut pjmedia_rtp_seq_session, seq: pj_uint16_t, seq_status: *mut pjmedia_rtp_status); }

#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_rtcp_sr { pub ntp_sec: pj_uint32_t, pub ntp_frac: pj_uint32_t, pub rtp_ts: pj_uint32_t, pub sender_pcount: pj_uint32_t, pub sender_bcount: pj_uint32_t }

#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_rtcp_rr { pub ssrc: pj_uint32_t, pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>, pub last_seq: pj_uint32_t, pub jitter: pj_uint32_t, pub lsr: pj_uint32_t, pub dlsr: pj_uint32_t }

impl pjmedia_rtcp_rr {
    #[inline]
    pub fn fract_lost(&self) -> pj_uint32_t { unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) } }
    #[inline]
    pub fn set_fract_lost(&mut self, val: pj_uint32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn total_lost_2(&self) -> pj_uint32_t { unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) } }
    #[inline]
    pub fn set_total_lost_2(&mut self, val: pj_uint32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn total_lost_1(&self) -> pj_uint32_t { unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) } }
    #[inline]
    pub fn set_total_lost_1(&mut self, val: pj_uint32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn total_lost_0(&self) -> pj_uint32_t { unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) } }
    #[inline]
    pub fn set_total_lost_0(&mut self, val: pj_uint32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(fract_lost: pj_uint32_t, total_lost_2: pj_uint32_t, total_lost_1: pj_uint32_t, total_lost_0: pj_uint32_t) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let fract_lost: u32 = unsafe { ::std::mem::transmute(fract_lost) };
            fract_lost as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let total_lost_2: u32 = unsafe { ::std::mem::transmute(total_lost_2) };
            total_lost_2 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let total_lost_1: u32 = unsafe { ::std::mem::transmute(total_lost_1) };
            total_lost_1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let total_lost_0: u32 = unsafe { ::std::mem::transmute(total_lost_0) };
            total_lost_0 as u64
        });
        __bindgen_bitfield_unit
    }
}

#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_rtcp_common { pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>, pub ssrc: pj_uint32_t }

impl pjmedia_rtcp_common {
    #[inline]
    pub fn count(&self) -> ::std::os::raw::c_uint { unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) } }
    #[inline]
    pub fn set_count(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn p(&self) -> ::std::os::raw::c_uint { unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) } }
    #[inline]
    pub fn set_p(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn version(&self) -> ::std::os::raw::c_uint { unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u32) } }
    #[inline]
    pub fn set_version(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn pt(&self) -> ::std::os::raw::c_uint { unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) } }
    #[inline]
    pub fn set_pt(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn length(&self) -> ::std::os::raw::c_uint { unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) } }
    #[inline]
    pub fn set_length(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(count: ::std::os::raw::c_uint, p: ::std::os::raw::c_uint, version: ::std::os::raw::c_uint, pt: ::std::os::raw::c_uint, length: ::std::os::raw::c_uint) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let count: u32 = unsafe { ::std::mem::transmute(count) };
            count as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let p: u32 = unsafe { ::std::mem::transmute(p) };
            p as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let version: u32 = unsafe { ::std::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let pt: u32 = unsafe { ::std::mem::transmute(pt) };
            pt as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let length: u32 = unsafe { ::std::mem::transmute(length) };
            length as u64
        });
        __bindgen_bitfield_unit
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_rtcp_sr_pkt { pub common: pjmedia_rtcp_common, pub sr: pjmedia_rtcp_sr, pub rr: pjmedia_rtcp_rr }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_rtcp_rr_pkt { pub common: pjmedia_rtcp_common, pub rr: pjmedia_rtcp_rr }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_rtcp_sdes { pub cname: pj_str_t, pub name: pj_str_t, pub email: pj_str_t, pub phone: pj_str_t, pub loc: pj_str_t, pub tool: pj_str_t, pub note: pj_str_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_rtcp_ntp_rec { pub hi: pj_uint32_t, pub lo: pj_uint32_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_rtcp_stream_stat { pub update: pj_time_val, pub update_cnt: ::std::os::raw::c_uint, pub pkt: pj_uint32_t, pub bytes: pj_uint32_t, pub discard: ::std::os::raw::c_uint, pub loss: ::std::os::raw::c_uint, pub reorder: ::std::os::raw::c_uint, pub dup: ::std::os::raw::c_uint, pub loss_period: pj_math_stat, pub loss_type: pjmedia_rtcp_stream_stat__bindgen_ty_1, pub jitter: pj_math_stat }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_rtcp_stream_stat__bindgen_ty_1 { pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>, pub __bindgen_padding_0: [u8; 3usize], pub __bindgen_align: [u32; 0usize] }

impl pjmedia_rtcp_stream_stat__bindgen_ty_1 {
    #[inline]
    pub fn burst(&self) -> ::std::os::raw::c_uint { unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) } }
    #[inline]
    pub fn set_burst(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn random(&self) -> ::std::os::raw::c_uint { unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) } }
    #[inline]
    pub fn set_random(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(burst: ::std::os::raw::c_uint, random: ::std::os::raw::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let burst: u32 = unsafe { ::std::mem::transmute(burst) };
            burst as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let random: u32 = unsafe { ::std::mem::transmute(random) };
            random as u64
        });
        __bindgen_bitfield_unit
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjmedia_rtcp_stat { pub start: pj_time_val, pub tx: pjmedia_rtcp_stream_stat, pub rx: pjmedia_rtcp_stream_stat, pub rtt: pj_math_stat, pub rtp_tx_last_ts: pj_uint32_t, pub rtp_tx_last_seq: pj_uint16_t, pub peer_sdes: pjmedia_rtcp_sdes, pub peer_sdes_buf_: [::std::os::raw::c_char; 64usize] }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjmedia_rtcp_session { pub name: *mut ::std::os::raw::c_char, pub rtcp_sr_pkt: pjmedia_rtcp_sr_pkt, pub rtcp_rr_pkt: pjmedia_rtcp_rr_pkt, pub seq_ctrl: pjmedia_rtp_seq_session, pub rtp_last_ts: ::std::os::raw::c_uint, pub clock_rate: ::std::os::raw::c_uint, pub pkt_size: ::std::os::raw::c_uint, pub received: pj_uint32_t, pub exp_prior: pj_uint32_t, pub rx_prior: pj_uint32_t, pub transit: pj_int32_t, pub jitter: pj_uint32_t, pub tv_base: pj_time_val, pub ts_base: pj_timestamp, pub ts_freq: pj_timestamp, pub rtp_ts_base: pj_uint32_t, pub rx_lsr: pj_uint32_t, pub rx_lsr_time: pj_timestamp, pub peer_ssrc: pj_uint32_t, pub stat: pjmedia_rtcp_stat }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_rtcp_session_setting { pub name: *mut ::std::os::raw::c_char, pub clock_rate: ::std::os::raw::c_uint, pub samples_per_frame: ::std::os::raw::c_uint, pub ssrc: pj_uint32_t, pub rtp_ts_base: pj_uint32_t }

extern "C" { pub fn pjmedia_rtcp_session_setting_default(settings: *mut pjmedia_rtcp_session_setting); }

extern "C" { pub fn pjmedia_rtcp_init_stat(stat: *mut pjmedia_rtcp_stat); }

extern "C" { pub fn pjmedia_rtcp_init(session: *mut pjmedia_rtcp_session, name: *mut ::std::os::raw::c_char, clock_rate: ::std::os::raw::c_uint, samples_per_frame: ::std::os::raw::c_uint, ssrc: pj_uint32_t); }

extern "C" { pub fn pjmedia_rtcp_init2(session: *mut pjmedia_rtcp_session, settings: *const pjmedia_rtcp_session_setting); }

extern "C" { pub fn pjmedia_rtcp_get_ntp_time(sess: *const pjmedia_rtcp_session, ntp: *mut pjmedia_rtcp_ntp_rec) -> pj_status_t; }

extern "C" { pub fn pjmedia_rtcp_fini(session: *mut pjmedia_rtcp_session); }

extern "C" { pub fn pjmedia_rtcp_rx_rtp(session: *mut pjmedia_rtcp_session, seq: ::std::os::raw::c_uint, ts: ::std::os::raw::c_uint, payload: ::std::os::raw::c_uint); }

extern "C" { pub fn pjmedia_rtcp_rx_rtp2(session: *mut pjmedia_rtcp_session, seq: ::std::os::raw::c_uint, ts: ::std::os::raw::c_uint, payload: ::std::os::raw::c_uint, discarded: pj_bool_t); }

extern "C" { pub fn pjmedia_rtcp_tx_rtp(session: *mut pjmedia_rtcp_session, ptsize: ::std::os::raw::c_uint); }

extern "C" { pub fn pjmedia_rtcp_rx_rtcp(session: *mut pjmedia_rtcp_session, rtcp_pkt: *const ::std::os::raw::c_void, size: pj_size_t); }

extern "C" { pub fn pjmedia_rtcp_build_rtcp(session: *mut pjmedia_rtcp_session, rtcp_pkt: *mut *mut ::std::os::raw::c_void, len: *mut ::std::os::raw::c_int); }

extern "C" { pub fn pjmedia_rtcp_build_rtcp_sdes(session: *mut pjmedia_rtcp_session, buf: *mut ::std::os::raw::c_void, length: *mut pj_size_t, sdes: *const pjmedia_rtcp_sdes) -> pj_status_t; }

extern "C" { pub fn pjmedia_rtcp_build_rtcp_bye(session: *mut pjmedia_rtcp_session, buf: *mut ::std::os::raw::c_void, length: *mut pj_size_t, reason: *const pj_str_t) -> pj_status_t; }

extern "C" { pub fn pjmedia_rtcp_enable_xr(session: *mut pjmedia_rtcp_session, enable: pj_bool_t) -> pj_status_t; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_sdp_neg_state { PJMEDIA_SDP_NEG_STATE_NULL = 0, PJMEDIA_SDP_NEG_STATE_LOCAL_OFFER = 1, PJMEDIA_SDP_NEG_STATE_REMOTE_OFFER = 2, PJMEDIA_SDP_NEG_STATE_WAIT_NEGO = 3, PJMEDIA_SDP_NEG_STATE_DONE = 4 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_sdp_neg { _unused: [u8; 0] }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_mod_offer_flag { PJMEDIA_SDP_NEG_ALLOW_MEDIA_CHANGE = 1 }

extern "C" { pub fn pjmedia_sdp_neg_state_str(state: pjmedia_sdp_neg_state) -> *const ::std::os::raw::c_char; }

extern "C" { pub fn pjmedia_sdp_neg_create_w_local_offer(pool: *mut pj_pool_t, local: *const pjmedia_sdp_session, p_neg: *mut *mut pjmedia_sdp_neg) -> pj_status_t; }

extern "C" { pub fn pjmedia_sdp_neg_create_w_remote_offer(pool: *mut pj_pool_t, initial: *const pjmedia_sdp_session, remote: *const pjmedia_sdp_session, p_neg: *mut *mut pjmedia_sdp_neg) -> pj_status_t; }

extern "C" { pub fn pjmedia_sdp_neg_set_prefer_remote_codec_order(neg: *mut pjmedia_sdp_neg, prefer_remote: pj_bool_t) -> pj_status_t; }

extern "C" { pub fn pjmedia_sdp_neg_set_answer_multiple_codecs(neg: *mut pjmedia_sdp_neg, answer_multiple: pj_bool_t) -> pj_status_t; }

extern "C" { pub fn pjmedia_sdp_neg_get_state(neg: *mut pjmedia_sdp_neg) -> pjmedia_sdp_neg_state; }

extern "C" { pub fn pjmedia_sdp_neg_get_active_local(neg: *mut pjmedia_sdp_neg, local: *mut *const pjmedia_sdp_session) -> pj_status_t; }

extern "C" { pub fn pjmedia_sdp_neg_get_active_remote(neg: *mut pjmedia_sdp_neg, remote: *mut *const pjmedia_sdp_session) -> pj_status_t; }

extern "C" { pub fn pjmedia_sdp_neg_was_answer_remote(neg: *mut pjmedia_sdp_neg) -> pj_bool_t; }

extern "C" { pub fn pjmedia_sdp_neg_get_neg_remote(neg: *mut pjmedia_sdp_neg, remote: *mut *const pjmedia_sdp_session) -> pj_status_t; }

extern "C" { pub fn pjmedia_sdp_neg_get_neg_local(neg: *mut pjmedia_sdp_neg, local: *mut *const pjmedia_sdp_session) -> pj_status_t; }

extern "C" { pub fn pjmedia_sdp_neg_modify_local_offer(pool: *mut pj_pool_t, neg: *mut pjmedia_sdp_neg, local: *const pjmedia_sdp_session) -> pj_status_t; }

extern "C" { pub fn pjmedia_sdp_neg_modify_local_offer2(pool: *mut pj_pool_t, neg: *mut pjmedia_sdp_neg, flags: ::std::os::raw::c_uint, local: *const pjmedia_sdp_session) -> pj_status_t; }

extern "C" { pub fn pjmedia_sdp_neg_send_local_offer(pool: *mut pj_pool_t, neg: *mut pjmedia_sdp_neg, offer: *mut *const pjmedia_sdp_session) -> pj_status_t; }

extern "C" { pub fn pjmedia_sdp_neg_set_remote_answer(pool: *mut pj_pool_t, neg: *mut pjmedia_sdp_neg, remote: *const pjmedia_sdp_session) -> pj_status_t; }

extern "C" { pub fn pjmedia_sdp_neg_set_remote_offer(pool: *mut pj_pool_t, neg: *mut pjmedia_sdp_neg, remote: *const pjmedia_sdp_session) -> pj_status_t; }

extern "C" { pub fn pjmedia_sdp_neg_set_local_answer(pool: *mut pj_pool_t, neg: *mut pjmedia_sdp_neg, local: *const pjmedia_sdp_session) -> pj_status_t; }

extern "C" { pub fn pjmedia_sdp_neg_has_local_answer(neg: *mut pjmedia_sdp_neg) -> pj_bool_t; }

extern "C" { pub fn pjmedia_sdp_neg_cancel_offer(neg: *mut pjmedia_sdp_neg) -> pj_status_t; }

extern "C" { pub fn pjmedia_sdp_neg_negotiate(pool: *mut pj_pool_t, neg: *mut pjmedia_sdp_neg, allow_asym: pj_bool_t) -> pj_status_t; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_sdp_neg_fmt_match_flag { PJMEDIA_SDP_NEG_FMT_MATCH_ALLOW_MODIFY_ANSWER = 1 }

pub type pjmedia_sdp_neg_fmt_match_cb = ::std::option::Option<unsafe extern "C" fn(pool: *mut pj_pool_t, offer: *mut pjmedia_sdp_media, o_fmt_idx: ::std::os::raw::c_uint, answer: *mut pjmedia_sdp_media, a_fmt_idx: ::std::os::raw::c_uint, option: ::std::os::raw::c_uint) -> pj_status_t>;

extern "C" { pub fn pjmedia_sdp_neg_register_fmt_match_cb(fmt_name: *const pj_str_t, cb: pjmedia_sdp_neg_fmt_match_cb) -> pj_status_t; }

extern "C" { pub fn pjmedia_sdp_neg_fmt_match(pool: *mut pj_pool_t, offer: *mut pjmedia_sdp_media, o_fmt_idx: ::std::os::raw::c_uint, answer: *mut pjmedia_sdp_media, a_fmt_idx: ::std::os::raw::c_uint, option: ::std::os::raw::c_uint) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_silence_det { _unused: [u8; 0] }

extern "C" { pub fn pjmedia_silence_det_create(pool: *mut pj_pool_t, clock_rate: ::std::os::raw::c_uint, samples_per_frame: ::std::os::raw::c_uint, p_sd: *mut *mut pjmedia_silence_det) -> pj_status_t; }

extern "C" { pub fn pjmedia_silence_det_set_name(sd: *mut pjmedia_silence_det, name: *const ::std::os::raw::c_char) -> pj_status_t; }

extern "C" { pub fn pjmedia_silence_det_set_fixed(sd: *mut pjmedia_silence_det, threshold: ::std::os::raw::c_int) -> pj_status_t; }

extern "C" { pub fn pjmedia_silence_det_set_adaptive(sd: *mut pjmedia_silence_det, threshold: ::std::os::raw::c_int) -> pj_status_t; }

extern "C" { pub fn pjmedia_silence_det_set_params(sd: *mut pjmedia_silence_det, before_silence: ::std::os::raw::c_int, recalc_time1: ::std::os::raw::c_int, recalc_time2: ::std::os::raw::c_int) -> pj_status_t; }

extern "C" { pub fn pjmedia_silence_det_disable(sd: *mut pjmedia_silence_det) -> pj_status_t; }

extern "C" { pub fn pjmedia_silence_det_detect(sd: *mut pjmedia_silence_det, samples: *const pj_int16_t, count: pj_size_t, p_level: *mut pj_int32_t) -> pj_bool_t; }

extern "C" { pub fn pjmedia_calc_avg_signal(samples: *const pj_int16_t, count: pj_size_t) -> pj_int32_t; }

extern "C" { pub fn pjmedia_silence_det_apply(sd: *mut pjmedia_silence_det, level: pj_uint32_t) -> pj_bool_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_snd_stream { _unused: [u8; 0] }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjmedia_snd_dev_info { pub name: [::std::os::raw::c_char; 64usize], pub input_count: ::std::os::raw::c_uint, pub output_count: ::std::os::raw::c_uint, pub default_samples_per_sec: ::std::os::raw::c_uint }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_snd_stream_info { pub dir: pjmedia_dir, pub play_id: ::std::os::raw::c_int, pub rec_id: ::std::os::raw::c_int, pub clock_rate: ::std::os::raw::c_uint, pub channel_count: ::std::os::raw::c_uint, pub samples_per_frame: ::std::os::raw::c_uint, pub bits_per_sample: ::std::os::raw::c_uint, pub rec_latency: ::std::os::raw::c_uint, pub play_latency: ::std::os::raw::c_uint }

pub type pjmedia_snd_play_cb = ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, timestamp: pj_uint32_t, output: *mut ::std::os::raw::c_void, size: ::std::os::raw::c_uint) -> pj_status_t>;
pub type pjmedia_snd_rec_cb = ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, timestamp: pj_uint32_t, input: *mut ::std::os::raw::c_void, size: ::std::os::raw::c_uint) -> pj_status_t>;

extern "C" { pub fn pjmedia_snd_get_dev_info(index: ::std::os::raw::c_uint) -> *const pjmedia_snd_dev_info; }

extern "C" { pub fn pjmedia_snd_set_latency(input_latency: ::std::os::raw::c_uint, output_latency: ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pjmedia_snd_open(rec_id: ::std::os::raw::c_int, play_id: ::std::os::raw::c_int, clock_rate: ::std::os::raw::c_uint, channel_count: ::std::os::raw::c_uint, samples_per_frame: ::std::os::raw::c_uint, bits_per_sample: ::std::os::raw::c_uint, rec_cb: pjmedia_snd_rec_cb, play_cb: pjmedia_snd_play_cb, user_data: *mut ::std::os::raw::c_void, p_snd_strm: *mut *mut pjmedia_snd_stream) -> pj_status_t; }

extern "C" { pub fn pjmedia_snd_open_rec(index: ::std::os::raw::c_int, clock_rate: ::std::os::raw::c_uint, channel_count: ::std::os::raw::c_uint, samples_per_frame: ::std::os::raw::c_uint, bits_per_sample: ::std::os::raw::c_uint, rec_cb: pjmedia_snd_rec_cb, user_data: *mut ::std::os::raw::c_void, p_snd_strm: *mut *mut pjmedia_snd_stream) -> pj_status_t; }

extern "C" { pub fn pjmedia_snd_open_player(index: ::std::os::raw::c_int, clock_rate: ::std::os::raw::c_uint, channel_count: ::std::os::raw::c_uint, samples_per_frame: ::std::os::raw::c_uint, bits_per_sample: ::std::os::raw::c_uint, play_cb: pjmedia_snd_play_cb, user_data: *mut ::std::os::raw::c_void, p_snd_strm: *mut *mut pjmedia_snd_stream) -> pj_status_t; }

extern "C" { pub fn pjmedia_snd_stream_get_info(strm: *mut pjmedia_snd_stream, pi: *mut pjmedia_snd_stream_info) -> pj_status_t; }

extern "C" { pub fn pjmedia_snd_stream_start(stream: *mut pjmedia_snd_stream) -> pj_status_t; }

extern "C" { pub fn pjmedia_snd_stream_stop(stream: *mut pjmedia_snd_stream) -> pj_status_t; }

extern "C" { pub fn pjmedia_snd_stream_close(stream: *mut pjmedia_snd_stream) -> pj_status_t; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_snd_port_option { PJMEDIA_SND_PORT_NO_AUTO_START = 1 }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjmedia_snd_port_param { pub base: pjmedia_aud_param, pub options: ::std::os::raw::c_uint, pub ec_options: ::std::os::raw::c_uint, pub user_data: *mut ::std::os::raw::c_void, pub on_play_frame: pjmedia_aud_play_cb, pub on_rec_frame: pjmedia_aud_rec_cb }

extern "C" { pub fn pjmedia_snd_port_param_default(prm: *mut pjmedia_snd_port_param); }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_snd_port { _unused: [u8; 0] }

extern "C" { pub fn pjmedia_snd_port_create(pool: *mut pj_pool_t, rec_id: ::std::os::raw::c_int, play_id: ::std::os::raw::c_int, clock_rate: ::std::os::raw::c_uint, channel_count: ::std::os::raw::c_uint, samples_per_frame: ::std::os::raw::c_uint, bits_per_sample: ::std::os::raw::c_uint, options: ::std::os::raw::c_uint, p_port: *mut *mut pjmedia_snd_port) -> pj_status_t; }

extern "C" { pub fn pjmedia_snd_port_create_rec(pool: *mut pj_pool_t, index: ::std::os::raw::c_int, clock_rate: ::std::os::raw::c_uint, channel_count: ::std::os::raw::c_uint, samples_per_frame: ::std::os::raw::c_uint, bits_per_sample: ::std::os::raw::c_uint, options: ::std::os::raw::c_uint, p_port: *mut *mut pjmedia_snd_port) -> pj_status_t; }

extern "C" { pub fn pjmedia_snd_port_create_player(pool: *mut pj_pool_t, index: ::std::os::raw::c_int, clock_rate: ::std::os::raw::c_uint, channel_count: ::std::os::raw::c_uint, samples_per_frame: ::std::os::raw::c_uint, bits_per_sample: ::std::os::raw::c_uint, options: ::std::os::raw::c_uint, p_port: *mut *mut pjmedia_snd_port) -> pj_status_t; }

extern "C" { pub fn pjmedia_snd_port_create2(pool: *mut pj_pool_t, prm: *const pjmedia_snd_port_param, p_port: *mut *mut pjmedia_snd_port) -> pj_status_t; }

extern "C" { pub fn pjmedia_snd_port_destroy(snd_port: *mut pjmedia_snd_port) -> pj_status_t; }

extern "C" { pub fn pjmedia_snd_port_get_snd_stream(snd_port: *mut pjmedia_snd_port) -> *mut pjmedia_aud_stream; }

extern "C" { pub fn pjmedia_snd_port_set_ec(snd_port: *mut pjmedia_snd_port, pool: *mut pj_pool_t, tail_ms: ::std::os::raw::c_uint, options: ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pjmedia_snd_port_get_ec_tail(snd_port: *mut pjmedia_snd_port, p_length: *mut ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pjmedia_snd_port_get_clock_src(snd_port: *mut pjmedia_snd_port, dir: pjmedia_dir) -> *mut pjmedia_clock_src; }

extern "C" { pub fn pjmedia_snd_port_connect(snd_port: *mut pjmedia_snd_port, port: *mut pjmedia_port) -> pj_status_t; }

extern "C" { pub fn pjmedia_snd_port_get_port(snd_port: *mut pjmedia_snd_port) -> *mut pjmedia_port; }

extern "C" { pub fn pjmedia_snd_port_disconnect(snd_port: *mut pjmedia_snd_port) -> pj_status_t; }

extern "C" { pub fn pjmedia_splitcomb_create(pool: *mut pj_pool_t, clock_rate: ::std::os::raw::c_uint, channel_count: ::std::os::raw::c_uint, samples_per_frame: ::std::os::raw::c_uint, bits_per_sample: ::std::os::raw::c_uint, options: ::std::os::raw::c_uint, p_splitcomb: *mut *mut pjmedia_port) -> pj_status_t; }

extern "C" { pub fn pjmedia_splitcomb_set_channel(splitcomb: *mut pjmedia_port, ch_num: ::std::os::raw::c_uint, options: ::std::os::raw::c_uint, port: *mut pjmedia_port) -> pj_status_t; }

extern "C" { pub fn pjmedia_splitcomb_create_rev_channel(pool: *mut pj_pool_t, splitcomb: *mut pjmedia_port, ch_num: ::std::os::raw::c_uint, options: ::std::os::raw::c_uint, p_chport: *mut *mut pjmedia_port) -> pj_status_t; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_stereo_port_options { PJMEDIA_STEREO_DONT_DESTROY_DN = 4 }

extern "C" { pub fn pjmedia_stereo_port_create(pool: *mut pj_pool_t, dn_port: *mut pjmedia_port, channel_count: ::std::os::raw::c_uint, options: ::std::os::raw::c_uint, p_port: *mut *mut pjmedia_port) -> pj_status_t; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_vid_packing { PJMEDIA_VID_PACKING_UNKNOWN = 0, PJMEDIA_VID_PACKING_PACKETS = 1, PJMEDIA_VID_PACKING_WHOLE = 2 }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_vid_frm_bit_info { PJMEDIA_VID_FRM_KEYFRAME = 1 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_vid_encode_opt { pub force_keyframe: pj_bool_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_vid_codec_info { pub fmt_id: pjmedia_format_id, pub pt: ::std::os::raw::c_uint, pub encoding_name: pj_str_t, pub encoding_desc: pj_str_t, pub clock_rate: ::std::os::raw::c_uint, pub dir: pjmedia_dir, pub dec_fmt_id_cnt: ::std::os::raw::c_uint, pub dec_fmt_id: [pjmedia_format_id; 8usize], pub packings: ::std::os::raw::c_uint, pub fps_cnt: ::std::os::raw::c_uint, pub fps: [pjmedia_ratio; 16usize] }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjmedia_vid_codec_param { pub dir: pjmedia_dir, pub packing: pjmedia_vid_packing, pub enc_fmt: pjmedia_format, pub enc_fmtp: pjmedia_codec_fmtp, pub enc_mtu: ::std::os::raw::c_uint, pub dec_fmt: pjmedia_format, pub dec_fmtp: pjmedia_codec_fmtp, pub ignore_fmtp: pj_bool_t }

extern "C" { pub fn pjmedia_vid_codec_param_clone(pool: *mut pj_pool_t, src: *const pjmedia_vid_codec_param) -> *mut pjmedia_vid_codec_param; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_vid_codec_op { pub init: ::std::option::Option<unsafe extern "C" fn(codec: *mut pjmedia_vid_codec, pool: *mut pj_pool_t) -> pj_status_t>, pub open: ::std::option::Option<unsafe extern "C" fn(codec: *mut pjmedia_vid_codec, param: *mut pjmedia_vid_codec_param) -> pj_status_t>, pub close: ::std::option::Option<unsafe extern "C" fn(codec: *mut pjmedia_vid_codec) -> pj_status_t>, pub modify: ::std::option::Option<unsafe extern "C" fn(codec: *mut pjmedia_vid_codec, param: *const pjmedia_vid_codec_param) -> pj_status_t>, pub get_param: ::std::option::Option<unsafe extern "C" fn(codec: *mut pjmedia_vid_codec, param: *mut pjmedia_vid_codec_param) -> pj_status_t>, pub encode_begin: ::std::option::Option<unsafe extern "C" fn(codec: *mut pjmedia_vid_codec, opt: *const pjmedia_vid_encode_opt, input: *const pjmedia_frame, out_size: ::std::os::raw::c_uint, output: *mut pjmedia_frame, has_more: *mut pj_bool_t) -> pj_status_t>, pub encode_more: ::std::option::Option<unsafe extern "C" fn(codec: *mut pjmedia_vid_codec, out_size: ::std::os::raw::c_uint, output: *mut pjmedia_frame, has_more: *mut pj_bool_t) -> pj_status_t>, pub decode: ::std::option::Option<unsafe extern "C" fn(codec: *mut pjmedia_vid_codec, count: pj_size_t, packets: *mut pjmedia_frame, out_size: ::std::os::raw::c_uint, output: *mut pjmedia_frame) -> pj_status_t>, pub recover: ::std::option::Option<unsafe extern "C" fn(codec: *mut pjmedia_vid_codec, out_size: ::std::os::raw::c_uint, output: *mut pjmedia_frame) -> pj_status_t> }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_vid_codec { pub prev: *mut pjmedia_vid_codec, pub next: *mut pjmedia_vid_codec, pub codec_data: *mut ::std::os::raw::c_void, pub factory: *mut pjmedia_vid_codec_factory, pub op: *mut pjmedia_vid_codec_op }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_vid_codec_factory_op { pub test_alloc: ::std::option::Option<unsafe extern "C" fn(factory: *mut pjmedia_vid_codec_factory, info: *const pjmedia_vid_codec_info) -> pj_status_t>, pub default_attr: ::std::option::Option<unsafe extern "C" fn(factory: *mut pjmedia_vid_codec_factory, info: *const pjmedia_vid_codec_info, attr: *mut pjmedia_vid_codec_param) -> pj_status_t>, pub enum_info: ::std::option::Option<unsafe extern "C" fn(factory: *mut pjmedia_vid_codec_factory, count: *mut ::std::os::raw::c_uint, codecs: *mut pjmedia_vid_codec_info) -> pj_status_t>, pub alloc_codec: ::std::option::Option<unsafe extern "C" fn(factory: *mut pjmedia_vid_codec_factory, info: *const pjmedia_vid_codec_info, p_codec: *mut *mut pjmedia_vid_codec) -> pj_status_t>, pub dealloc_codec: ::std::option::Option<unsafe extern "C" fn(factory: *mut pjmedia_vid_codec_factory, codec: *mut pjmedia_vid_codec) -> pj_status_t> }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_vid_codec_factory { pub prev: *mut pjmedia_vid_codec_factory, pub next: *mut pjmedia_vid_codec_factory, pub factory_data: *mut ::std::os::raw::c_void, pub op: *mut pjmedia_vid_codec_factory_op }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_vid_codec_mgr { _unused: [u8; 0] }

extern "C" { pub fn pjmedia_vid_codec_mgr_create(pool: *mut pj_pool_t, mgr: *mut *mut pjmedia_vid_codec_mgr) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_codec_mgr_destroy(mgr: *mut pjmedia_vid_codec_mgr) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_codec_mgr_instance() -> *mut pjmedia_vid_codec_mgr; }

extern "C" { pub fn pjmedia_vid_codec_mgr_set_instance(mgr: *mut pjmedia_vid_codec_mgr); }

extern "C" { pub fn pjmedia_vid_codec_mgr_register_factory(mgr: *mut pjmedia_vid_codec_mgr, factory: *mut pjmedia_vid_codec_factory) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_codec_mgr_unregister_factory(mgr: *mut pjmedia_vid_codec_mgr, factory: *mut pjmedia_vid_codec_factory) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_codec_mgr_enum_codecs(mgr: *mut pjmedia_vid_codec_mgr, count: *mut ::std::os::raw::c_uint, info: *mut pjmedia_vid_codec_info, prio: *mut ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_codec_mgr_get_codec_info(mgr: *mut pjmedia_vid_codec_mgr, pt: ::std::os::raw::c_uint, info: *mut *const pjmedia_vid_codec_info) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_codec_mgr_get_codec_info2(mgr: *mut pjmedia_vid_codec_mgr, fmt_id: pjmedia_format_id, info: *mut *const pjmedia_vid_codec_info) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_codec_info_to_id(info: *const pjmedia_vid_codec_info, id: *mut ::std::os::raw::c_char, max_len: ::std::os::raw::c_uint) -> *mut ::std::os::raw::c_char; }

extern "C" { pub fn pjmedia_vid_codec_mgr_find_codecs_by_id(mgr: *mut pjmedia_vid_codec_mgr, codec_id: *const pj_str_t, count: *mut ::std::os::raw::c_uint, p_info: *mut *const pjmedia_vid_codec_info, prio: *mut ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_codec_mgr_set_codec_priority(mgr: *mut pjmedia_vid_codec_mgr, codec_id: *const pj_str_t, prio: pj_uint8_t) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_codec_mgr_get_default_param(mgr: *mut pjmedia_vid_codec_mgr, info: *const pjmedia_vid_codec_info, param: *mut pjmedia_vid_codec_param) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_codec_mgr_set_default_param(mgr: *mut pjmedia_vid_codec_mgr, info: *const pjmedia_vid_codec_info, param: *const pjmedia_vid_codec_param) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_codec_mgr_alloc_codec(mgr: *mut pjmedia_vid_codec_mgr, info: *const pjmedia_vid_codec_info, p_codec: *mut *mut pjmedia_vid_codec) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_codec_mgr_dealloc_codec(mgr: *mut pjmedia_vid_codec_mgr, codec: *mut pjmedia_vid_codec) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_stream_rtp_sess_info { pub rx_rtp: *const pjmedia_rtp_session, pub tx_rtp: *const pjmedia_rtp_session, pub rtcp: *const pjmedia_rtcp_session }

extern "C" { pub fn pjmedia_stream_info_parse_fmtp(pool: *mut pj_pool_t, m: *const pjmedia_sdp_media, pt: ::std::os::raw::c_uint, fmtp: *mut pjmedia_codec_fmtp) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_channel { _unused: [u8; 0] }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjmedia_stream_info { pub type_: pjmedia_type, pub proto: pjmedia_tp_proto, pub dir: pjmedia_dir, pub rem_addr: pj_sockaddr, pub rem_rtcp: pj_sockaddr, pub fmt: pjmedia_codec_info, pub param: *mut pjmedia_codec_param, pub tx_pt: ::std::os::raw::c_uint, pub rx_pt: ::std::os::raw::c_uint, pub tx_maxptime: ::std::os::raw::c_uint, pub tx_event_pt: ::std::os::raw::c_int, pub rx_event_pt: ::std::os::raw::c_int, pub ssrc: pj_uint32_t, pub rtp_ts: pj_uint32_t, pub rtp_seq: pj_uint16_t, pub rtp_seq_ts_set: pj_uint8_t, pub jb_init: ::std::os::raw::c_int, pub jb_min_pre: ::std::os::raw::c_int, pub jb_max_pre: ::std::os::raw::c_int, pub jb_max: ::std::os::raw::c_int, pub rtcp_sdes_bye_disabled: pj_bool_t }

extern "C" { pub fn pjmedia_stream_info_from_sdp(si: *mut pjmedia_stream_info, pool: *mut pj_pool_t, endpt: *mut pjmedia_endpt, local: *const pjmedia_sdp_session, remote: *const pjmedia_sdp_session, stream_idx: ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pjmedia_stream_create(endpt: *mut pjmedia_endpt, pool: *mut pj_pool_t, info: *const pjmedia_stream_info, tp: *mut pjmedia_transport, user_data: *mut ::std::os::raw::c_void, p_stream: *mut *mut pjmedia_stream) -> pj_status_t; }

extern "C" { pub fn pjmedia_stream_destroy(stream: *mut pjmedia_stream) -> pj_status_t; }

extern "C" { pub fn pjmedia_stream_get_last_jb_frame_type(stream: *mut pjmedia_stream) -> ::std::os::raw::c_char; }

extern "C" { pub fn pjmedia_stream_get_port(stream: *mut pjmedia_stream, p_port: *mut *mut pjmedia_port) -> pj_status_t; }

extern "C" { pub fn pjmedia_stream_get_transport(st: *mut pjmedia_stream) -> *mut pjmedia_transport; }

extern "C" { pub fn pjmedia_stream_start(stream: *mut pjmedia_stream) -> pj_status_t; }

extern "C" { pub fn pjmedia_stream_get_info(stream: *const pjmedia_stream, info: *mut pjmedia_stream_info) -> pj_status_t; }

extern "C" { pub fn pjmedia_stream_get_stat(stream: *const pjmedia_stream, stat: *mut pjmedia_rtcp_stat) -> pj_status_t; }

extern "C" { pub fn pjmedia_stream_reset_stat(stream: *mut pjmedia_stream) -> pj_status_t; }

extern "C" { pub fn pjmedia_stream_get_stat_jbuf(stream: *const pjmedia_stream, state: *mut pjmedia_jb_state) -> pj_status_t; }

extern "C" { pub fn pjmedia_stream_pause(stream: *mut pjmedia_stream, dir: pjmedia_dir) -> pj_status_t; }

extern "C" { pub fn pjmedia_stream_resume(stream: *mut pjmedia_stream, dir: pjmedia_dir) -> pj_status_t; }

extern "C" { pub fn pjmedia_stream_dial_dtmf(stream: *mut pjmedia_stream, ascii_digit: *const pj_str_t) -> pj_status_t; }

extern "C" { pub fn pjmedia_stream_check_dtmf(stream: *mut pjmedia_stream) -> pj_bool_t; }

extern "C" { pub fn pjmedia_stream_get_dtmf(stream: *mut pjmedia_stream, ascii_digits: *mut ::std::os::raw::c_char, size: *mut ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pjmedia_stream_set_dtmf_callback(stream: *mut pjmedia_stream, cb: ::std::option::Option<unsafe extern "C" fn(arg1: *mut pjmedia_stream, user_data: *mut ::std::os::raw::c_void, digit: ::std::os::raw::c_int)>, user_data: *mut ::std::os::raw::c_void) -> pj_status_t; }

extern "C" { pub fn pjmedia_stream_send_rtcp_sdes(stream: *mut pjmedia_stream) -> pj_status_t; }

extern "C" { pub fn pjmedia_stream_send_rtcp_bye(stream: *mut pjmedia_stream) -> pj_status_t; }

extern "C" { pub fn pjmedia_stream_get_rtp_session_info(stream: *mut pjmedia_stream, session_info: *mut pjmedia_stream_rtp_sess_info) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_tone_desc { pub freq1: ::std::os::raw::c_short, pub freq2: ::std::os::raw::c_short, pub on_msec: ::std::os::raw::c_short, pub off_msec: ::std::os::raw::c_short, pub volume: ::std::os::raw::c_short, pub flags: ::std::os::raw::c_short }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_tone_digit { pub digit: ::std::os::raw::c_char, pub on_msec: ::std::os::raw::c_short, pub off_msec: ::std::os::raw::c_short, pub volume: ::std::os::raw::c_short }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_tone_digit_map { pub count: ::std::os::raw::c_uint, pub digits: [pjmedia_tone_digit_map__bindgen_ty_1; 16usize] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_tone_digit_map__bindgen_ty_1 { pub digit: ::std::os::raw::c_char, pub freq1: ::std::os::raw::c_short, pub freq2: ::std::os::raw::c_short }

pub const PJMEDIA_TONEGEN_LOOP: _bindgen_ty_8 = _bindgen_ty_8::PJMEDIA_TONEGEN_LOOP;
pub const PJMEDIA_TONEGEN_NO_LOCK: _bindgen_ty_8 = _bindgen_ty_8::PJMEDIA_TONEGEN_NO_LOCK;

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_8 { PJMEDIA_TONEGEN_LOOP = 1, PJMEDIA_TONEGEN_NO_LOCK = 2 }

extern "C" { pub fn pjmedia_tonegen_create(pool: *mut pj_pool_t, clock_rate: ::std::os::raw::c_uint, channel_count: ::std::os::raw::c_uint, samples_per_frame: ::std::os::raw::c_uint, bits_per_sample: ::std::os::raw::c_uint, options: ::std::os::raw::c_uint, p_port: *mut *mut pjmedia_port) -> pj_status_t; }

extern "C" { pub fn pjmedia_tonegen_create2(pool: *mut pj_pool_t, name: *const pj_str_t, clock_rate: ::std::os::raw::c_uint, channel_count: ::std::os::raw::c_uint, samples_per_frame: ::std::os::raw::c_uint, bits_per_sample: ::std::os::raw::c_uint, options: ::std::os::raw::c_uint, p_port: *mut *mut pjmedia_port) -> pj_status_t; }

extern "C" { pub fn pjmedia_tonegen_is_busy(tonegen: *mut pjmedia_port) -> pj_bool_t; }

extern "C" { pub fn pjmedia_tonegen_stop(tonegen: *mut pjmedia_port) -> pj_status_t; }

extern "C" { pub fn pjmedia_tonegen_rewind(tonegen: *mut pjmedia_port) -> pj_status_t; }

extern "C" { pub fn pjmedia_tonegen_play(tonegen: *mut pjmedia_port, count: ::std::os::raw::c_uint, tones: *const pjmedia_tone_desc, options: ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pjmedia_tonegen_play_digits(tonegen: *mut pjmedia_port, count: ::std::os::raw::c_uint, digits: *const pjmedia_tone_digit, options: ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pjmedia_tonegen_get_digit_map(tonegen: *mut pjmedia_port, m: *mut *const pjmedia_tone_digit_map) -> pj_status_t; }

extern "C" { pub fn pjmedia_tonegen_set_digit_map(tonegen: *mut pjmedia_port, m: *mut pjmedia_tone_digit_map) -> pj_status_t; }

extern "C" { pub fn pjmedia_tp_adapter_create(endpt: *mut pjmedia_endpt, name: *const ::std::os::raw::c_char, base_tp: *mut pjmedia_transport, del_base: pj_bool_t, p_tp: *mut *mut pjmedia_transport) -> pj_status_t; }

extern "C" { pub fn pjnath_init() -> pj_status_t; }

extern "C" { pub fn pjnath_perror(sender: *const ::std::os::raw::c_char, title: *const ::std::os::raw::c_char, status: pj_status_t); }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_stun_method_e { PJ_STUN_BINDING_METHOD = 1, PJ_STUN_SHARED_SECRET_METHOD = 2, PJ_STUN_ALLOCATE_METHOD = 3, PJ_STUN_REFRESH_METHOD = 4, PJ_STUN_SEND_METHOD = 6, PJ_STUN_DATA_METHOD = 7, PJ_STUN_CREATE_PERM_METHOD = 8, PJ_STUN_CHANNEL_BIND_METHOD = 9, PJ_STUN_METHOD_MAX = 10 }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_stun_msg_class_e { PJ_STUN_REQUEST_CLASS = 0, PJ_STUN_INDICATION_CLASS = 1, PJ_STUN_SUCCESS_CLASS = 2, PJ_STUN_ERROR_CLASS = 3 }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_stun_msg_type { PJ_STUN_BINDING_REQUEST = 1, PJ_STUN_BINDING_RESPONSE = 257, PJ_STUN_BINDING_ERROR_RESPONSE = 273, PJ_STUN_BINDING_INDICATION = 17, PJ_STUN_SHARED_SECRET_REQUEST = 2, PJ_STUN_SHARED_SECRET_RESPONSE = 258, PJ_STUN_SHARED_SECRET_ERROR_RESPONSE = 274, PJ_STUN_ALLOCATE_REQUEST = 3, PJ_STUN_ALLOCATE_RESPONSE = 259, PJ_STUN_ALLOCATE_ERROR_RESPONSE = 275, PJ_STUN_REFRESH_REQUEST = 4, PJ_STUN_REFRESH_RESPONSE = 260, PJ_STUN_REFRESH_ERROR_RESPONSE = 276, PJ_STUN_SEND_INDICATION = 22, PJ_STUN_DATA_INDICATION = 23, PJ_STUN_CREATE_PERM_REQUEST = 8, PJ_STUN_CREATE_PERM_RESPONSE = 264, PJ_STUN_CREATE_PERM_ERROR_RESPONSE = 280, PJ_STUN_CHANNEL_BIND_REQUEST = 9, PJ_STUN_CHANNEL_BIND_RESPONSE = 265, PJ_STUN_CHANNEL_BIND_ERROR_RESPONSE = 281 }

impl pj_stun_attr_type { pub const PJ_STUN_ATTR_REQ_ADDR_FAMILY: pj_stun_attr_type = pj_stun_attr_type::PJ_STUN_ATTR_REQ_ADDR_TYPE; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_stun_attr_type { PJ_STUN_ATTR_MAPPED_ADDR = 1, PJ_STUN_ATTR_RESPONSE_ADDR = 2, PJ_STUN_ATTR_CHANGE_REQUEST = 3, PJ_STUN_ATTR_SOURCE_ADDR = 4, PJ_STUN_ATTR_CHANGED_ADDR = 5, PJ_STUN_ATTR_USERNAME = 6, PJ_STUN_ATTR_PASSWORD = 7, PJ_STUN_ATTR_MESSAGE_INTEGRITY = 8, PJ_STUN_ATTR_ERROR_CODE = 9, PJ_STUN_ATTR_UNKNOWN_ATTRIBUTES = 10, PJ_STUN_ATTR_REFLECTED_FROM = 11, PJ_STUN_ATTR_CHANNEL_NUMBER = 12, PJ_STUN_ATTR_LIFETIME = 13, PJ_STUN_ATTR_MAGIC_COOKIE = 15, PJ_STUN_ATTR_BANDWIDTH = 16, PJ_STUN_ATTR_XOR_PEER_ADDR = 18, PJ_STUN_ATTR_DATA = 19, PJ_STUN_ATTR_REALM = 20, PJ_STUN_ATTR_NONCE = 21, PJ_STUN_ATTR_XOR_RELAYED_ADDR = 22, PJ_STUN_ATTR_REQ_ADDR_TYPE = 23, PJ_STUN_ATTR_EVEN_PORT = 24, PJ_STUN_ATTR_REQ_TRANSPORT = 25, PJ_STUN_ATTR_DONT_FRAGMENT = 26, PJ_STUN_ATTR_XOR_MAPPED_ADDR = 32, PJ_STUN_ATTR_TIMER_VAL = 33, PJ_STUN_ATTR_RESERVATION_TOKEN = 34, PJ_STUN_ATTR_XOR_REFLECTED_FROM = 35, PJ_STUN_ATTR_PRIORITY = 36, PJ_STUN_ATTR_USE_CANDIDATE = 37, PJ_STUN_ATTR_ICMP = 48, PJ_STUN_ATTR_END_MANDATORY_ATTR = 49, PJ_STUN_ATTR_START_EXTENDED_ATTR = 32801, PJ_STUN_ATTR_SOFTWARE = 32802, PJ_STUN_ATTR_ALTERNATE_SERVER = 32803, PJ_STUN_ATTR_REFRESH_INTERVAL = 32804, PJ_STUN_ATTR_FINGERPRINT = 32808, PJ_STUN_ATTR_ICE_CONTROLLED = 32809, PJ_STUN_ATTR_ICE_CONTROLLING = 32810, PJ_STUN_ATTR_END_EXTENDED_ATTR = 32811 }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_stun_status { PJ_STUN_SC_TRY_ALTERNATE = 300, PJ_STUN_SC_BAD_REQUEST = 400, PJ_STUN_SC_UNAUTHORIZED = 401, PJ_STUN_SC_FORBIDDEN = 403, PJ_STUN_SC_UNKNOWN_ATTRIBUTE = 420, PJ_STUN_SC_ALLOCATION_MISMATCH = 437, PJ_STUN_SC_STALE_NONCE = 438, PJ_STUN_SC_TRANSITIONING = 439, PJ_STUN_SC_WRONG_CREDENTIALS = 441, PJ_STUN_SC_UNSUPP_TRANSPORT_PROTO = 442, PJ_STUN_SC_OPER_TCP_ONLY = 445, PJ_STUN_SC_CONNECTION_FAILURE = 446, PJ_STUN_SC_CONNECTION_TIMEOUT = 447, PJ_STUN_SC_ALLOCATION_QUOTA_REACHED = 486, PJ_STUN_SC_ROLE_CONFLICT = 487, PJ_STUN_SC_SERVER_ERROR = 500, PJ_STUN_SC_INSUFFICIENT_CAPACITY = 508, PJ_STUN_SC_GLOBAL_FAILURE = 600 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_stun_msg_hdr { pub type_: pj_uint16_t, pub length: pj_uint16_t, pub magic: pj_uint32_t, pub tsx_id: [pj_uint8_t; 12usize] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_stun_attr_hdr { pub type_: pj_uint16_t, pub length: pj_uint16_t }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pj_stun_sockaddr_attr { pub hdr: pj_stun_attr_hdr, pub xor_ed: pj_bool_t, pub sockaddr: pj_sockaddr }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_stun_empty_attr { pub hdr: pj_stun_attr_hdr }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_stun_string_attr { pub hdr: pj_stun_attr_hdr, pub value: pj_str_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_stun_uint_attr { pub hdr: pj_stun_attr_hdr, pub value: pj_uint32_t }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pj_stun_uint64_attr { pub hdr: pj_stun_attr_hdr, pub value: pj_timestamp }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_stun_binary_attr { pub hdr: pj_stun_attr_hdr, pub magic: pj_uint32_t, pub length: ::std::os::raw::c_uint, pub data: *mut pj_uint8_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_stun_msgint_attr { pub hdr: pj_stun_attr_hdr, pub hmac: [pj_uint8_t; 20usize] }

pub type pj_stun_fingerprint_attr = pj_stun_uint_attr;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_stun_errcode_attr { pub hdr: pj_stun_attr_hdr, pub err_code: ::std::os::raw::c_int, pub reason: pj_str_t }

pub type pj_stun_realm_attr = pj_stun_string_attr;
pub type pj_stun_nonce_attr = pj_stun_string_attr;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_stun_unknown_attr { pub hdr: pj_stun_attr_hdr, pub attr_count: ::std::os::raw::c_uint, pub attrs: [pj_uint16_t; 16usize] }

pub type pj_stun_mapped_addr_attr = pj_stun_sockaddr_attr;
pub type pj_stun_xor_mapped_addr_attr = pj_stun_sockaddr_attr;
pub type pj_stun_software_attr = pj_stun_string_attr;
pub type pj_stun_alt_server_attr = pj_stun_sockaddr_attr;
pub type pj_stun_refresh_interval_attr = pj_stun_uint_attr;
pub type pj_stun_response_addr_attr = pj_stun_sockaddr_attr;
pub type pj_stun_changed_addr_attr = pj_stun_sockaddr_attr;
pub type pj_stun_change_request_attr = pj_stun_uint_attr;
pub type pj_stun_src_addr_attr = pj_stun_sockaddr_attr;
pub type pj_stun_reflected_from_attr = pj_stun_sockaddr_attr;
pub type pj_stun_username_attr = pj_stun_string_attr;
pub type pj_stun_password_attr = pj_stun_string_attr;
pub type pj_stun_channel_number_attr = pj_stun_uint_attr;
pub type pj_stun_lifetime_attr = pj_stun_uint_attr;
pub type pj_stun_bandwidth_attr = pj_stun_uint_attr;
pub type pj_stun_xor_peer_addr_attr = pj_stun_sockaddr_attr;
pub type pj_stun_data_attr = pj_stun_binary_attr;
pub type pj_stun_xor_relayed_addr_attr = pj_stun_sockaddr_attr;
pub type pj_stun_req_addr_type_attr = pj_stun_uint_attr;
pub type pj_stun_even_port_attr = pj_stun_uint_attr;
pub type pj_stun_req_transport_attr = pj_stun_uint_attr;
pub type pj_stun_dont_fragment_attr = pj_stun_empty_attr;
pub type pj_stun_res_token_attr = pj_stun_uint64_attr;
pub type pj_stun_xor_reflected_from_attr = pj_stun_sockaddr_attr;
pub type pj_stun_priority_attr = pj_stun_uint_attr;
pub type pj_stun_use_candidate_attr = pj_stun_empty_attr;
pub type pj_stun_timer_val_attr = pj_stun_uint_attr;
pub type pj_stun_ice_controlling_attr = pj_stun_uint64_attr;
pub type pj_stun_ice_controlled_attr = pj_stun_uint64_attr;
pub type pj_stun_icmp_attr = pj_stun_uint_attr;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_stun_msg { pub hdr: pj_stun_msg_hdr, pub attr_count: ::std::os::raw::c_uint, pub attr: [*mut pj_stun_attr_hdr; 16usize] }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_stun_decode_options { PJ_STUN_IS_DATAGRAM = 1, PJ_STUN_CHECK_PACKET = 2, PJ_STUN_NO_AUTHENTICATE = 4, PJ_STUN_NO_FINGERPRINT_CHECK = 8 }

extern "C" { pub fn pj_stun_get_method_name(msg_type: ::std::os::raw::c_uint) -> *const ::std::os::raw::c_char; }

extern "C" { pub fn pj_stun_get_class_name(msg_type: ::std::os::raw::c_uint) -> *const ::std::os::raw::c_char; }

extern "C" { pub fn pj_stun_get_attr_name(attr_type: ::std::os::raw::c_uint) -> *const ::std::os::raw::c_char; }

extern "C" { pub fn pj_stun_get_err_reason(err_code: ::std::os::raw::c_int) -> pj_str_t; }

extern "C" { pub fn pj_stun_set_padding_char(chr: ::std::os::raw::c_int) -> ::std::os::raw::c_int; }

extern "C" { pub fn pj_stun_msg_init(msg: *mut pj_stun_msg, msg_type: ::std::os::raw::c_uint, magic: pj_uint32_t, tsx_id: *const pj_uint8_t) -> pj_status_t; }

extern "C" { pub fn pj_stun_msg_create(pool: *mut pj_pool_t, msg_type: ::std::os::raw::c_uint, magic: pj_uint32_t, tsx_id: *const pj_uint8_t, p_msg: *mut *mut pj_stun_msg) -> pj_status_t; }

extern "C" { pub fn pj_stun_msg_clone(pool: *mut pj_pool_t, msg: *const pj_stun_msg) -> *mut pj_stun_msg; }

extern "C" { pub fn pj_stun_msg_create_response(pool: *mut pj_pool_t, req_msg: *const pj_stun_msg, err_code: ::std::os::raw::c_uint, err_msg: *const pj_str_t, p_response: *mut *mut pj_stun_msg) -> pj_status_t; }

extern "C" { pub fn pj_stun_msg_add_attr(msg: *mut pj_stun_msg, attr: *mut pj_stun_attr_hdr) -> pj_status_t; }

extern "C" { pub fn pj_stun_msg_encode(msg: *mut pj_stun_msg, pkt_buf: *mut pj_uint8_t, buf_size: pj_size_t, options: ::std::os::raw::c_uint, key: *const pj_str_t, p_msg_len: *mut pj_size_t) -> pj_status_t; }

extern "C" { pub fn pj_stun_msg_check(pdu: *const pj_uint8_t, pdu_len: pj_size_t, options: ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pj_stun_msg_decode(pool: *mut pj_pool_t, pdu: *const pj_uint8_t, pdu_len: pj_size_t, options: ::std::os::raw::c_uint, p_msg: *mut *mut pj_stun_msg, p_parsed_len: *mut pj_size_t, p_response: *mut *mut pj_stun_msg) -> pj_status_t; }

extern "C" { pub fn pj_stun_msg_dump(msg: *const pj_stun_msg, buffer: *mut ::std::os::raw::c_char, length: ::std::os::raw::c_uint, printed_len: *mut ::std::os::raw::c_uint) -> *mut ::std::os::raw::c_char; }

extern "C" { pub fn pj_stun_msg_find_attr(msg: *const pj_stun_msg, attr_type: ::std::os::raw::c_int, start_index: ::std::os::raw::c_uint) -> *mut pj_stun_attr_hdr; }

extern "C" { pub fn pj_stun_attr_clone(pool: *mut pj_pool_t, attr: *const pj_stun_attr_hdr) -> *mut pj_stun_attr_hdr; }

extern "C" { pub fn pj_stun_sockaddr_attr_init(attr: *mut pj_stun_sockaddr_attr, attr_type: ::std::os::raw::c_int, xor_ed: pj_bool_t, addr: *const pj_sockaddr_t, addr_len: ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pj_stun_sockaddr_attr_create(pool: *mut pj_pool_t, attr_type: ::std::os::raw::c_int, xor_ed: pj_bool_t, addr: *const pj_sockaddr_t, addr_len: ::std::os::raw::c_uint, p_attr: *mut *mut pj_stun_sockaddr_attr) -> pj_status_t; }

extern "C" { pub fn pj_stun_msg_add_sockaddr_attr(pool: *mut pj_pool_t, msg: *mut pj_stun_msg, attr_type: ::std::os::raw::c_int, xor_ed: pj_bool_t, addr: *const pj_sockaddr_t, addr_len: ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pj_stun_string_attr_init(attr: *mut pj_stun_string_attr, pool: *mut pj_pool_t, attr_type: ::std::os::raw::c_int, value: *const pj_str_t) -> pj_status_t; }

extern "C" { pub fn pj_stun_string_attr_create(pool: *mut pj_pool_t, attr_type: ::std::os::raw::c_int, value: *const pj_str_t, p_attr: *mut *mut pj_stun_string_attr) -> pj_status_t; }

extern "C" { pub fn pj_stun_msg_add_string_attr(pool: *mut pj_pool_t, msg: *mut pj_stun_msg, attr_type: ::std::os::raw::c_int, value: *const pj_str_t) -> pj_status_t; }

extern "C" { pub fn pj_stun_uint_attr_create(pool: *mut pj_pool_t, attr_type: ::std::os::raw::c_int, value: pj_uint32_t, p_attr: *mut *mut pj_stun_uint_attr) -> pj_status_t; }

extern "C" { pub fn pj_stun_msg_add_uint_attr(pool: *mut pj_pool_t, msg: *mut pj_stun_msg, attr_type: ::std::os::raw::c_int, value: pj_uint32_t) -> pj_status_t; }

extern "C" { pub fn pj_stun_uint64_attr_create(pool: *mut pj_pool_t, attr_type: ::std::os::raw::c_int, value: *const pj_timestamp, p_attr: *mut *mut pj_stun_uint64_attr) -> pj_status_t; }

extern "C" { pub fn pj_stun_msg_add_uint64_attr(pool: *mut pj_pool_t, msg: *mut pj_stun_msg, attr_type: ::std::os::raw::c_int, value: *const pj_timestamp) -> pj_status_t; }

extern "C" { pub fn pj_stun_msgint_attr_create(pool: *mut pj_pool_t, p_attr: *mut *mut pj_stun_msgint_attr) -> pj_status_t; }

extern "C" { pub fn pj_stun_msg_add_msgint_attr(pool: *mut pj_pool_t, msg: *mut pj_stun_msg) -> pj_status_t; }

extern "C" { pub fn pj_stun_errcode_attr_create(pool: *mut pj_pool_t, err_code: ::std::os::raw::c_int, err_reason: *const pj_str_t, p_attr: *mut *mut pj_stun_errcode_attr) -> pj_status_t; }

extern "C" { pub fn pj_stun_msg_add_errcode_attr(pool: *mut pj_pool_t, msg: *mut pj_stun_msg, err_code: ::std::os::raw::c_int, err_reason: *const pj_str_t) -> pj_status_t; }

extern "C" { pub fn pj_stun_unknown_attr_create(pool: *mut pj_pool_t, attr_cnt: ::std::os::raw::c_uint, attr: *const pj_uint16_t, p_attr: *mut *mut pj_stun_unknown_attr) -> pj_status_t; }

extern "C" { pub fn pj_stun_msg_add_unknown_attr(pool: *mut pj_pool_t, msg: *mut pj_stun_msg, attr_cnt: ::std::os::raw::c_uint, attr: *const pj_uint16_t) -> pj_status_t; }

extern "C" { pub fn pj_stun_binary_attr_init(attr: *mut pj_stun_binary_attr, pool: *mut pj_pool_t, attr_type: ::std::os::raw::c_int, data: *const pj_uint8_t, length: ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pj_stun_binary_attr_create(pool: *mut pj_pool_t, attr_type: ::std::os::raw::c_int, data: *const pj_uint8_t, length: ::std::os::raw::c_uint, p_attr: *mut *mut pj_stun_binary_attr) -> pj_status_t; }

extern "C" { pub fn pj_stun_msg_add_binary_attr(pool: *mut pj_pool_t, msg: *mut pj_stun_msg, attr_type: ::std::os::raw::c_int, data: *const pj_uint8_t, length: ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pj_stun_empty_attr_create(pool: *mut pj_pool_t, attr_type: ::std::os::raw::c_int, p_attr: *mut *mut pj_stun_empty_attr) -> pj_status_t; }

extern "C" { pub fn pj_stun_msg_add_empty_attr(pool: *mut pj_pool_t, msg: *mut pj_stun_msg, attr_type: ::std::os::raw::c_int) -> pj_status_t; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_stun_auth_type { PJ_STUN_AUTH_NONE = 0, PJ_STUN_AUTH_SHORT_TERM = 1, PJ_STUN_AUTH_LONG_TERM = 2 }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_stun_auth_cred_type { PJ_STUN_AUTH_CRED_STATIC = 0, PJ_STUN_AUTH_CRED_DYNAMIC = 1 }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_stun_passwd_type { PJ_STUN_PASSWD_PLAIN = 0, PJ_STUN_PASSWD_HASHED = 1 }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pj_stun_auth_cred { pub type_: pj_stun_auth_cred_type, pub data: pj_stun_auth_cred__bindgen_ty_1 }

#[repr(C)]
#[derive(Copy, Clone)]
pub union pj_stun_auth_cred__bindgen_ty_1 { pub static_cred: pj_stun_auth_cred__bindgen_ty_1__bindgen_ty_1, pub dyn_cred: pj_stun_auth_cred__bindgen_ty_1__bindgen_ty_2, _bindgen_union_align: [u32; 9usize] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_stun_auth_cred__bindgen_ty_1__bindgen_ty_1 { pub realm: pj_str_t, pub username: pj_str_t, pub data_type: pj_stun_passwd_type, pub data: pj_str_t, pub nonce: pj_str_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_stun_auth_cred__bindgen_ty_1__bindgen_ty_2 { pub user_data: *mut ::std::os::raw::c_void, pub get_auth: ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, pool: *mut pj_pool_t, realm: *mut pj_str_t, nonce: *mut pj_str_t) -> pj_status_t>, pub get_cred: ::std::option::Option<unsafe extern "C" fn(msg: *const pj_stun_msg, user_data: *mut ::std::os::raw::c_void, pool: *mut pj_pool_t, realm: *mut pj_str_t, username: *mut pj_str_t, nonce: *mut pj_str_t, data_type: *mut pj_stun_passwd_type, data: *mut pj_str_t) -> pj_status_t>, pub get_password: ::std::option::Option<unsafe extern "C" fn(msg: *const pj_stun_msg, user_data: *mut ::std::os::raw::c_void, realm: *const pj_str_t, username: *const pj_str_t, pool: *mut pj_pool_t, data_type: *mut pj_stun_passwd_type, data: *mut pj_str_t) -> pj_status_t>, pub verify_nonce: ::std::option::Option<unsafe extern "C" fn(msg: *const pj_stun_msg, user_data: *mut ::std::os::raw::c_void, realm: *const pj_str_t, username: *const pj_str_t, nonce: *const pj_str_t) -> pj_bool_t> }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_stun_req_cred_info { pub realm: pj_str_t, pub username: pj_str_t, pub nonce: pj_str_t, pub auth_key: pj_str_t }

extern "C" { pub fn pj_stun_auth_cred_dup(pool: *mut pj_pool_t, dst: *mut pj_stun_auth_cred, src: *const pj_stun_auth_cred); }

extern "C" { pub fn pj_stun_req_cred_info_dup(pool: *mut pj_pool_t, dst: *mut pj_stun_req_cred_info, src: *const pj_stun_req_cred_info); }

extern "C" { pub fn pj_stun_create_key(pool: *mut pj_pool_t, key: *mut pj_str_t, realm: *const pj_str_t, username: *const pj_str_t, data_type: pj_stun_passwd_type, data: *const pj_str_t); }

extern "C" { pub fn pj_stun_authenticate_request(pkt: *const pj_uint8_t, pkt_len: ::std::os::raw::c_uint, msg: *const pj_stun_msg, cred: *mut pj_stun_auth_cred, pool: *mut pj_pool_t, info: *mut pj_stun_req_cred_info, p_response: *mut *mut pj_stun_msg) -> pj_status_t; }

extern "C" { pub fn pj_stun_auth_valid_for_msg(msg: *const pj_stun_msg) -> pj_bool_t; }

extern "C" { pub fn pj_stun_authenticate_response(pkt: *const pj_uint8_t, pkt_len: ::std::os::raw::c_uint, msg: *const pj_stun_msg, key: *const pj_str_t) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_stun_config { pub pf: *mut pj_pool_factory, pub ioqueue: *mut pj_ioqueue_t, pub timer_heap: *mut pj_timer_heap_t, pub options: ::std::os::raw::c_uint, pub rto_msec: ::std::os::raw::c_uint, pub res_cache_msec: ::std::os::raw::c_uint, pub software_name: pj_str_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_stun_client_tsx { _unused: [u8; 0] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_stun_tsx_cb { pub on_complete: ::std::option::Option<unsafe extern "C" fn(tsx: *mut pj_stun_client_tsx, status: pj_status_t, response: *const pj_stun_msg, src_addr: *const pj_sockaddr_t, src_addr_len: ::std::os::raw::c_uint)>, pub on_send_msg: ::std::option::Option<unsafe extern "C" fn(tsx: *mut pj_stun_client_tsx, stun_pkt: *const ::std::os::raw::c_void, pkt_size: pj_size_t) -> pj_status_t>, pub on_destroy: ::std::option::Option<unsafe extern "C" fn(tsx: *mut pj_stun_client_tsx)> }

extern "C" { pub fn pj_stun_client_tsx_create(cfg: *mut pj_stun_config, pool: *mut pj_pool_t, grp_lock: *mut pj_grp_lock_t, cb: *const pj_stun_tsx_cb, p_tsx: *mut *mut pj_stun_client_tsx) -> pj_status_t; }

extern "C" { pub fn pj_stun_client_tsx_schedule_destroy(tsx: *mut pj_stun_client_tsx, delay: *const pj_time_val) -> pj_status_t; }

extern "C" { pub fn pj_stun_client_tsx_destroy(tsx: *mut pj_stun_client_tsx) -> pj_status_t; }

extern "C" { pub fn pj_stun_client_tsx_stop(tsx: *mut pj_stun_client_tsx) -> pj_status_t; }

extern "C" { pub fn pj_stun_client_tsx_is_complete(tsx: *mut pj_stun_client_tsx) -> pj_bool_t; }

extern "C" { pub fn pj_stun_client_tsx_set_data(tsx: *mut pj_stun_client_tsx, data: *mut ::std::os::raw::c_void) -> pj_status_t; }

extern "C" { pub fn pj_stun_client_tsx_get_data(tsx: *mut pj_stun_client_tsx) -> *mut ::std::os::raw::c_void; }

extern "C" { pub fn pj_stun_client_tsx_send_msg(tsx: *mut pj_stun_client_tsx, retransmit: pj_bool_t, pkt: *mut ::std::os::raw::c_void, pkt_len: ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pj_stun_client_tsx_retransmit(tsx: *mut pj_stun_client_tsx, mod_count: pj_bool_t) -> pj_status_t; }

extern "C" { pub fn pj_stun_client_tsx_on_rx_msg(tsx: *mut pj_stun_client_tsx, msg: *const pj_stun_msg, src_addr: *const pj_sockaddr_t, src_addr_len: ::std::os::raw::c_uint) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_stun_session { _unused: [u8; 0] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_stun_session_cb { pub on_send_msg: ::std::option::Option<unsafe extern "C" fn(sess: *mut pj_stun_session, token: *mut ::std::os::raw::c_void, pkt: *const ::std::os::raw::c_void, pkt_size: pj_size_t, dst_addr: *const pj_sockaddr_t, addr_len: ::std::os::raw::c_uint) -> pj_status_t>, pub on_rx_request: ::std::option::Option<unsafe extern "C" fn(sess: *mut pj_stun_session, pkt: *const pj_uint8_t, pkt_len: ::std::os::raw::c_uint, rdata: *const pj_stun_rx_data, token: *mut ::std::os::raw::c_void, src_addr: *const pj_sockaddr_t, src_addr_len: ::std::os::raw::c_uint) -> pj_status_t>, pub on_request_complete: ::std::option::Option<unsafe extern "C" fn(sess: *mut pj_stun_session, status: pj_status_t, token: *mut ::std::os::raw::c_void, tdata: *mut pj_stun_tx_data, response: *const pj_stun_msg, src_addr: *const pj_sockaddr_t, src_addr_len: ::std::os::raw::c_uint)>, pub on_rx_indication: ::std::option::Option<unsafe extern "C" fn(sess: *mut pj_stun_session, pkt: *const pj_uint8_t, pkt_len: ::std::os::raw::c_uint, msg: *const pj_stun_msg, token: *mut ::std::os::raw::c_void, src_addr: *const pj_sockaddr_t, src_addr_len: ::std::os::raw::c_uint) -> pj_status_t> }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_stun_rx_data { pub msg: *mut pj_stun_msg, pub info: pj_stun_req_cred_info }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_stun_tx_data { pub prev: *mut pj_stun_tx_data, pub next: *mut pj_stun_tx_data, pub pool: *mut pj_pool_t, pub sess: *mut pj_stun_session, pub msg: *mut pj_stun_msg, pub token: *mut ::std::os::raw::c_void, pub client_tsx: *mut pj_stun_client_tsx, pub retransmit: pj_bool_t, pub msg_magic: pj_uint32_t, pub msg_key: [pj_uint8_t; 12usize], pub auth_info: pj_stun_req_cred_info, pub pkt: *mut ::std::os::raw::c_void, pub max_len: ::std::os::raw::c_uint, pub pkt_size: pj_size_t, pub addr_len: ::std::os::raw::c_uint, pub dst_addr: *const pj_sockaddr_t, pub res_timer: pj_timer_entry }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_stun_sess_msg_log_flag { PJ_STUN_SESS_LOG_TX_REQ = 1, PJ_STUN_SESS_LOG_TX_RES = 2, PJ_STUN_SESS_LOG_TX_IND = 4, PJ_STUN_SESS_LOG_RX_REQ = 8, PJ_STUN_SESS_LOG_RX_RES = 16, PJ_STUN_SESS_LOG_RX_IND = 32 }

extern "C" { pub fn pj_stun_session_create(cfg: *mut pj_stun_config, name: *const ::std::os::raw::c_char, cb: *const pj_stun_session_cb, fingerprint: pj_bool_t, grp_lock: *mut pj_grp_lock_t, p_sess: *mut *mut pj_stun_session) -> pj_status_t; }

extern "C" { pub fn pj_stun_session_destroy(sess: *mut pj_stun_session) -> pj_status_t; }

extern "C" { pub fn pj_stun_session_set_user_data(sess: *mut pj_stun_session, user_data: *mut ::std::os::raw::c_void) -> pj_status_t; }

extern "C" { pub fn pj_stun_session_get_user_data(sess: *mut pj_stun_session) -> *mut ::std::os::raw::c_void; }

extern "C" { pub fn pj_stun_session_get_grp_lock(sess: *mut pj_stun_session) -> *mut pj_grp_lock_t; }

extern "C" { pub fn pj_stun_session_set_software_name(sess: *mut pj_stun_session, sw: *const pj_str_t) -> pj_status_t; }

extern "C" { pub fn pj_stun_session_set_credential(sess: *mut pj_stun_session, auth_type: pj_stun_auth_type, cred: *const pj_stun_auth_cred) -> pj_status_t; }

extern "C" { pub fn pj_stun_session_set_log(sess: *mut pj_stun_session, flags: ::std::os::raw::c_uint); }

extern "C" { pub fn pj_stun_session_use_fingerprint(sess: *mut pj_stun_session, use_: pj_bool_t) -> pj_bool_t; }

extern "C" { pub fn pj_stun_session_create_req(sess: *mut pj_stun_session, msg_type: ::std::os::raw::c_int, magic: pj_uint32_t, tsx_id: *const pj_uint8_t, p_tdata: *mut *mut pj_stun_tx_data) -> pj_status_t; }

extern "C" { pub fn pj_stun_session_create_ind(sess: *mut pj_stun_session, msg_type: ::std::os::raw::c_int, p_tdata: *mut *mut pj_stun_tx_data) -> pj_status_t; }

extern "C" { pub fn pj_stun_session_create_res(sess: *mut pj_stun_session, rdata: *const pj_stun_rx_data, err_code: ::std::os::raw::c_uint, err_msg: *const pj_str_t, p_tdata: *mut *mut pj_stun_tx_data) -> pj_status_t; }

extern "C" { pub fn pj_stun_session_send_msg(sess: *mut pj_stun_session, token: *mut ::std::os::raw::c_void, cache_res: pj_bool_t, retransmit: pj_bool_t, dst_addr: *const pj_sockaddr_t, addr_len: ::std::os::raw::c_uint, tdata: *mut pj_stun_tx_data) -> pj_status_t; }

extern "C" { pub fn pj_stun_session_respond(sess: *mut pj_stun_session, rdata: *const pj_stun_rx_data, code: ::std::os::raw::c_uint, err_msg: *const ::std::os::raw::c_char, token: *mut ::std::os::raw::c_void, cache: pj_bool_t, dst_addr: *const pj_sockaddr_t, addr_len: ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pj_stun_session_cancel_req(sess: *mut pj_stun_session, tdata: *mut pj_stun_tx_data, notify: pj_bool_t, status: pj_status_t) -> pj_status_t; }

extern "C" { pub fn pj_stun_session_retransmit_req(sess: *mut pj_stun_session, tdata: *mut pj_stun_tx_data, mod_count: pj_bool_t) -> pj_status_t; }

extern "C" { pub fn pj_stun_session_on_rx_pkt(sess: *mut pj_stun_session, packet: *const ::std::os::raw::c_void, pkt_size: pj_size_t, options: ::std::os::raw::c_uint, token: *mut ::std::os::raw::c_void, parsed_len: *mut pj_size_t, src_addr: *const pj_sockaddr_t, src_addr_len: ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pj_stun_msg_destroy_tdata(sess: *mut pj_stun_session, tdata: *mut pj_stun_tx_data); }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_ice_cand_type { PJ_ICE_CAND_TYPE_HOST = 0, PJ_ICE_CAND_TYPE_SRFLX = 1, PJ_ICE_CAND_TYPE_PRFLX = 2, PJ_ICE_CAND_TYPE_RELAYED = 3, PJ_ICE_CAND_TYPE_MAX = 4 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_ice_sess_comp { pub valid_check: *mut pj_ice_sess_check, pub nominated_check: *mut pj_ice_sess_check, pub stun_sess: *mut pj_stun_session }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pj_ice_msg_data { pub transport_id: ::std::os::raw::c_uint, pub has_req_data: pj_bool_t, pub data: pj_ice_msg_data_data }

#[repr(C)]
#[derive(Copy, Clone)]
pub union pj_ice_msg_data_data { pub req: pj_ice_msg_data_data_request_data, _bindgen_union_align: [u32; 3usize] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_ice_msg_data_data_request_data { pub ice: *mut pj_ice_sess, pub clist: *mut pj_ice_sess_checklist, pub ckid: ::std::os::raw::c_uint }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pj_ice_sess_cand { pub type_: pj_ice_cand_type, pub status: pj_status_t, pub comp_id: pj_uint8_t, pub transport_id: pj_uint8_t, pub local_pref: pj_uint16_t, pub foundation: pj_str_t, pub prio: pj_uint32_t, pub addr: pj_sockaddr, pub base_addr: pj_sockaddr, pub rel_addr: pj_sockaddr }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_ice_sess_check_state { PJ_ICE_SESS_CHECK_STATE_FROZEN = 0, PJ_ICE_SESS_CHECK_STATE_WAITING = 1, PJ_ICE_SESS_CHECK_STATE_IN_PROGRESS = 2, PJ_ICE_SESS_CHECK_STATE_SUCCEEDED = 3, PJ_ICE_SESS_CHECK_STATE_FAILED = 4 }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pj_ice_sess_check { pub lcand: *mut pj_ice_sess_cand, pub rcand: *mut pj_ice_sess_cand, pub prio: pj_timestamp, pub state: pj_ice_sess_check_state, pub tdata: *mut pj_stun_tx_data, pub nominated: pj_bool_t, pub err_code: pj_status_t }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_ice_sess_checklist_state { PJ_ICE_SESS_CHECKLIST_ST_IDLE = 0, PJ_ICE_SESS_CHECKLIST_ST_RUNNING = 1, PJ_ICE_SESS_CHECKLIST_ST_COMPLETED = 2 }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pj_ice_sess_checklist { pub state: pj_ice_sess_checklist_state, pub count: ::std::os::raw::c_uint, pub checks: [pj_ice_sess_check; 32usize], pub timer: pj_timer_entry }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_ice_sess_cb { pub on_ice_complete: ::std::option::Option<unsafe extern "C" fn(ice: *mut pj_ice_sess, status: pj_status_t)>, pub on_tx_pkt: ::std::option::Option<unsafe extern "C" fn(ice: *mut pj_ice_sess, comp_id: ::std::os::raw::c_uint, transport_id: ::std::os::raw::c_uint, pkt: *const ::std::os::raw::c_void, size: pj_size_t, dst_addr: *const pj_sockaddr_t, dst_addr_len: ::std::os::raw::c_uint) -> pj_status_t>, pub on_rx_data: ::std::option::Option<unsafe extern "C" fn(ice: *mut pj_ice_sess, comp_id: ::std::os::raw::c_uint, transport_id: ::std::os::raw::c_uint, pkt: *mut ::std::os::raw::c_void, size: pj_size_t, src_addr: *const pj_sockaddr_t, src_addr_len: ::std::os::raw::c_uint)> }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_ice_sess_role { PJ_ICE_SESS_ROLE_UNKNOWN = 0, PJ_ICE_SESS_ROLE_CONTROLLED = 1, PJ_ICE_SESS_ROLE_CONTROLLING = 2 }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pj_ice_rx_check { pub prev: *mut pj_ice_rx_check, pub next: *mut pj_ice_rx_check, pub comp_id: ::std::os::raw::c_uint, pub transport_id: ::std::os::raw::c_uint, pub src_addr: pj_sockaddr, pub src_addr_len: ::std::os::raw::c_uint, pub use_candidate: pj_bool_t, pub priority: pj_uint32_t, pub role_attr: *mut pj_stun_uint64_attr }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_ice_sess_options { pub aggressive: pj_bool_t, pub nominated_check_delay: ::std::os::raw::c_uint, pub controlled_agent_want_nom_timeout: ::std::os::raw::c_int }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pj_ice_sess { pub obj_name: [::std::os::raw::c_char; 32usize], pub pool: *mut pj_pool_t, pub user_data: *mut ::std::os::raw::c_void, pub grp_lock: *mut pj_grp_lock_t, pub role: pj_ice_sess_role, pub opt: pj_ice_sess_options, pub tie_breaker: pj_timestamp, pub prefs: *mut pj_uint8_t, pub is_nominating: pj_bool_t, pub is_complete: pj_bool_t, pub is_destroying: pj_bool_t, pub ice_status: pj_status_t, pub timer: pj_timer_entry, pub cb: pj_ice_sess_cb, pub stun_cfg: pj_stun_config, pub tx_ufrag: pj_str_t, pub tx_uname: pj_str_t, pub tx_pass: pj_str_t, pub rx_ufrag: pj_str_t, pub rx_uname: pj_str_t, pub rx_pass: pj_str_t, pub comp_cnt: ::std::os::raw::c_uint, pub comp: [pj_ice_sess_comp; 4usize], pub comp_ka: ::std::os::raw::c_uint, pub lcand_cnt: ::std::os::raw::c_uint, pub lcand: [pj_ice_sess_cand; 16usize], pub rcand_cnt: ::std::os::raw::c_uint, pub rcand: [pj_ice_sess_cand; 16usize], pub tp_data: [pj_ice_msg_data; 5usize], pub early_check: pj_ice_rx_check, pub clist: pj_ice_sess_checklist, pub valid_list: pj_ice_sess_checklist, pub tmp: pj_ice_sess__bindgen_ty_1 }

#[repr(C)]
#[derive(Copy, Clone)]
pub union pj_ice_sess__bindgen_ty_1 { pub txt: [::std::os::raw::c_char; 128usize], pub errmsg: [::std::os::raw::c_char; 80usize], _bindgen_union_align: [u8; 128usize] }

extern "C" { pub fn pj_ice_get_cand_type_name(type_: pj_ice_cand_type) -> *const ::std::os::raw::c_char; }

extern "C" { pub fn pj_ice_sess_role_name(role: pj_ice_sess_role) -> *const ::std::os::raw::c_char; }

extern "C" { pub fn pj_ice_calc_foundation(pool: *mut pj_pool_t, foundation: *mut pj_str_t, type_: pj_ice_cand_type, base_addr: *const pj_sockaddr); }

extern "C" { pub fn pj_ice_sess_options_default(opt: *mut pj_ice_sess_options); }

extern "C" { pub fn pj_ice_sess_create(stun_cfg: *mut pj_stun_config, name: *const ::std::os::raw::c_char, role: pj_ice_sess_role, comp_cnt: ::std::os::raw::c_uint, cb: *const pj_ice_sess_cb, local_ufrag: *const pj_str_t, local_passwd: *const pj_str_t, grp_lock: *mut pj_grp_lock_t, p_ice: *mut *mut pj_ice_sess) -> pj_status_t; }

extern "C" { pub fn pj_ice_sess_get_options(ice: *mut pj_ice_sess, opt: *mut pj_ice_sess_options) -> pj_status_t; }

extern "C" { pub fn pj_ice_sess_set_options(ice: *mut pj_ice_sess, opt: *const pj_ice_sess_options) -> pj_status_t; }

extern "C" { pub fn pj_ice_sess_destroy(ice: *mut pj_ice_sess) -> pj_status_t; }

extern "C" { pub fn pj_ice_sess_change_role(ice: *mut pj_ice_sess, new_role: pj_ice_sess_role) -> pj_status_t; }

extern "C" { pub fn pj_ice_sess_set_prefs(ice: *mut pj_ice_sess, prefs: *const pj_uint8_t) -> pj_status_t; }

extern "C" { pub fn pj_ice_sess_add_cand(ice: *mut pj_ice_sess, comp_id: ::std::os::raw::c_uint, transport_id: ::std::os::raw::c_uint, type_: pj_ice_cand_type, local_pref: pj_uint16_t, foundation: *const pj_str_t, addr: *const pj_sockaddr_t, base_addr: *const pj_sockaddr_t, rel_addr: *const pj_sockaddr_t, addr_len: ::std::os::raw::c_int, p_cand_id: *mut ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pj_ice_sess_find_default_cand(ice: *mut pj_ice_sess, comp_id: ::std::os::raw::c_uint, p_cand_id: *mut ::std::os::raw::c_int) -> pj_status_t; }

extern "C" { pub fn pj_ice_sess_create_check_list(ice: *mut pj_ice_sess, rem_ufrag: *const pj_str_t, rem_passwd: *const pj_str_t, rem_cand_cnt: ::std::os::raw::c_uint, rem_cand: *const pj_ice_sess_cand) -> pj_status_t; }

extern "C" { pub fn pj_ice_sess_start_check(ice: *mut pj_ice_sess) -> pj_status_t; }

extern "C" { pub fn pj_ice_sess_send_data(ice: *mut pj_ice_sess, comp_id: ::std::os::raw::c_uint, data: *const ::std::os::raw::c_void, data_len: pj_size_t) -> pj_status_t; }

extern "C" { pub fn pj_ice_sess_on_rx_pkt(ice: *mut pj_ice_sess, comp_id: ::std::os::raw::c_uint, transport_id: ::std::os::raw::c_uint, pkt: *mut ::std::os::raw::c_void, pkt_size: pj_size_t, src_addr: *const pj_sockaddr_t, src_addr_len: ::std::os::raw::c_int) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_stun_sock { _unused: [u8; 0] }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_stun_sock_op { PJ_STUN_SOCK_DNS_OP = 1, PJ_STUN_SOCK_BINDING_OP = 2, PJ_STUN_SOCK_KEEP_ALIVE_OP = 3, PJ_STUN_SOCK_MAPPED_ADDR_CHANGE = 4 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_stun_sock_cb { pub on_rx_data: ::std::option::Option<unsafe extern "C" fn(stun_sock: *mut pj_stun_sock, pkt: *mut ::std::os::raw::c_void, pkt_len: ::std::os::raw::c_uint, src_addr: *const pj_sockaddr_t, addr_len: ::std::os::raw::c_uint) -> pj_bool_t>, pub on_data_sent: ::std::option::Option<unsafe extern "C" fn(stun_sock: *mut pj_stun_sock, send_key: *mut pj_ioqueue_op_key_t, sent: pj_ssize_t) -> pj_bool_t>, pub on_status: ::std::option::Option<unsafe extern "C" fn(stun_sock: *mut pj_stun_sock, op: pj_stun_sock_op, status: pj_status_t) -> pj_bool_t> }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pj_stun_sock_info { pub bound_addr: pj_sockaddr, pub srv_addr: pj_sockaddr, pub mapped_addr: pj_sockaddr, pub alias_cnt: ::std::os::raw::c_uint, pub aliases: [pj_sockaddr; 8usize] }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pj_stun_sock_cfg { pub grp_lock: *mut pj_grp_lock_t, pub max_pkt_size: ::std::os::raw::c_uint, pub async_cnt: ::std::os::raw::c_uint, pub bound_addr: pj_sockaddr, pub port_range: pj_uint16_t, pub ka_interval: ::std::os::raw::c_int, pub qos_type: pj_qos_type, pub qos_params: pj_qos_params, pub qos_ignore_error: pj_bool_t, pub so_rcvbuf_size: ::std::os::raw::c_uint, pub so_sndbuf_size: ::std::os::raw::c_uint }

extern "C" { pub fn pj_stun_sock_op_name(op: pj_stun_sock_op) -> *const ::std::os::raw::c_char; }

extern "C" { pub fn pj_stun_sock_cfg_default(cfg: *mut pj_stun_sock_cfg); }

extern "C" { pub fn pj_stun_sock_create(stun_cfg: *mut pj_stun_config, name: *const ::std::os::raw::c_char, af: ::std::os::raw::c_int, cb: *const pj_stun_sock_cb, cfg: *const pj_stun_sock_cfg, user_data: *mut ::std::os::raw::c_void, p_sock: *mut *mut pj_stun_sock) -> pj_status_t; }

extern "C" { pub fn pj_stun_sock_start(stun_sock: *mut pj_stun_sock, domain: *const pj_str_t, default_port: pj_uint16_t, resolver: *mut pj_dns_resolver) -> pj_status_t; }

extern "C" { pub fn pj_stun_sock_destroy(sock: *mut pj_stun_sock) -> pj_status_t; }

extern "C" { pub fn pj_stun_sock_set_user_data(stun_sock: *mut pj_stun_sock, user_data: *mut ::std::os::raw::c_void) -> pj_status_t; }

extern "C" { pub fn pj_stun_sock_get_user_data(stun_sock: *mut pj_stun_sock) -> *mut ::std::os::raw::c_void; }

extern "C" { pub fn pj_stun_sock_get_grp_lock(stun_sock: *mut pj_stun_sock) -> *mut pj_grp_lock_t; }

extern "C" { pub fn pj_stun_sock_get_info(stun_sock: *mut pj_stun_sock, info: *mut pj_stun_sock_info) -> pj_status_t; }

extern "C" { pub fn pj_stun_sock_sendto(stun_sock: *mut pj_stun_sock, send_key: *mut pj_ioqueue_op_key_t, pkt: *const ::std::os::raw::c_void, pkt_len: ::std::os::raw::c_uint, flag: ::std::os::raw::c_uint, dst_addr: *const pj_sockaddr_t, addr_len: ::std::os::raw::c_uint) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_turn_session { _unused: [u8; 0] }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_turn_tp_type { PJ_TURN_TP_UDP = 17, PJ_TURN_TP_TCP = 6, PJ_TURN_TP_TLS = 255 }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_turn_state_t { PJ_TURN_STATE_NULL = 0, PJ_TURN_STATE_RESOLVING = 1, PJ_TURN_STATE_RESOLVED = 2, PJ_TURN_STATE_ALLOCATING = 3, PJ_TURN_STATE_READY = 4, PJ_TURN_STATE_DEALLOCATING = 5, PJ_TURN_STATE_DEALLOCATED = 6, PJ_TURN_STATE_DESTROYING = 7 }

#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pj_turn_channel_data { pub ch_number: pj_uint16_t, pub length: pj_uint16_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_turn_session_cb { pub on_send_pkt: ::std::option::Option<unsafe extern "C" fn(sess: *mut pj_turn_session, pkt: *const pj_uint8_t, pkt_len: ::std::os::raw::c_uint, dst_addr: *const pj_sockaddr_t, addr_len: ::std::os::raw::c_uint) -> pj_status_t>, pub on_channel_bound: ::std::option::Option<unsafe extern "C" fn(sess: *mut pj_turn_session, peer_addr: *const pj_sockaddr_t, addr_len: ::std::os::raw::c_uint, ch_num: ::std::os::raw::c_uint)>, pub on_rx_data: ::std::option::Option<unsafe extern "C" fn(sess: *mut pj_turn_session, pkt: *mut ::std::os::raw::c_void, pkt_len: ::std::os::raw::c_uint, peer_addr: *const pj_sockaddr_t, addr_len: ::std::os::raw::c_uint)>, pub on_state: ::std::option::Option<unsafe extern "C" fn(sess: *mut pj_turn_session, old_state: pj_turn_state_t, new_state: pj_turn_state_t)> }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_turn_alloc_param { pub bandwidth: ::std::os::raw::c_int, pub lifetime: ::std::os::raw::c_int, pub ka_interval: ::std::os::raw::c_int, pub af: ::std::os::raw::c_int }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pj_turn_session_info { pub state: pj_turn_state_t, pub last_status: pj_status_t, pub conn_type: pj_turn_tp_type, pub server: pj_sockaddr, pub mapped_addr: pj_sockaddr, pub relay_addr: pj_sockaddr, pub lifetime: ::std::os::raw::c_int }

extern "C" { pub fn pj_turn_alloc_param_default(prm: *mut pj_turn_alloc_param); }

extern "C" { pub fn pj_turn_alloc_param_copy(pool: *mut pj_pool_t, dst: *mut pj_turn_alloc_param, src: *const pj_turn_alloc_param); }

extern "C" { pub fn pj_turn_state_name(state: pj_turn_state_t) -> *const ::std::os::raw::c_char; }

extern "C" { pub fn pj_turn_session_create(cfg: *const pj_stun_config, name: *const ::std::os::raw::c_char, af: ::std::os::raw::c_int, conn_type: pj_turn_tp_type, grp_lock: *mut pj_grp_lock_t, cb: *const pj_turn_session_cb, options: ::std::os::raw::c_uint, user_data: *mut ::std::os::raw::c_void, p_sess: *mut *mut pj_turn_session) -> pj_status_t; }

extern "C" { pub fn pj_turn_session_shutdown(sess: *mut pj_turn_session) -> pj_status_t; }

extern "C" { pub fn pj_turn_session_destroy(sess: *mut pj_turn_session, last_err: pj_status_t) -> pj_status_t; }

extern "C" { pub fn pj_turn_session_get_info(sess: *mut pj_turn_session, info: *mut pj_turn_session_info) -> pj_status_t; }

extern "C" { pub fn pj_turn_session_set_user_data(sess: *mut pj_turn_session, user_data: *mut ::std::os::raw::c_void) -> pj_status_t; }

extern "C" { pub fn pj_turn_session_get_user_data(sess: *mut pj_turn_session) -> *mut ::std::os::raw::c_void; }

extern "C" { pub fn pj_turn_session_get_grp_lock(sess: *mut pj_turn_session) -> *mut pj_grp_lock_t; }

extern "C" { pub fn pj_turn_session_set_log(sess: *mut pj_turn_session, flags: ::std::os::raw::c_uint); }

extern "C" { pub fn pj_turn_session_set_software_name(sess: *mut pj_turn_session, sw: *const pj_str_t) -> pj_status_t; }

extern "C" { pub fn pj_turn_session_set_server(sess: *mut pj_turn_session, domain: *const pj_str_t, default_port: ::std::os::raw::c_int, resolver: *mut pj_dns_resolver) -> pj_status_t; }

extern "C" { pub fn pj_turn_session_set_credential(sess: *mut pj_turn_session, cred: *const pj_stun_auth_cred) -> pj_status_t; }

extern "C" { pub fn pj_turn_session_alloc(sess: *mut pj_turn_session, param: *const pj_turn_alloc_param) -> pj_status_t; }

extern "C" { pub fn pj_turn_session_set_perm(sess: *mut pj_turn_session, addr_cnt: ::std::os::raw::c_uint, addr: *const pj_sockaddr, options: ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pj_turn_session_sendto(sess: *mut pj_turn_session, pkt: *const pj_uint8_t, pkt_len: ::std::os::raw::c_uint, peer_addr: *const pj_sockaddr_t, addr_len: ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pj_turn_session_bind_channel(sess: *mut pj_turn_session, peer: *const pj_sockaddr_t, addr_len: ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pj_turn_session_on_rx_pkt(sess: *mut pj_turn_session, pkt: *mut ::std::os::raw::c_void, pkt_len: pj_size_t, parsed_len: *mut pj_size_t) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_turn_sock { _unused: [u8; 0] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_turn_sock_cb { pub on_rx_data: ::std::option::Option<unsafe extern "C" fn(turn_sock: *mut pj_turn_sock, pkt: *mut ::std::os::raw::c_void, pkt_len: ::std::os::raw::c_uint, peer_addr: *const pj_sockaddr_t, addr_len: ::std::os::raw::c_uint)>, pub on_state: ::std::option::Option<unsafe extern "C" fn(turn_sock: *mut pj_turn_sock, old_state: pj_turn_state_t, new_state: pj_turn_state_t)> }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pj_turn_sock_cfg { pub grp_lock: *mut pj_grp_lock_t, pub max_pkt_size: ::std::os::raw::c_uint, pub qos_type: pj_qos_type, pub qos_params: pj_qos_params, pub qos_ignore_error: pj_bool_t, pub bound_addr: pj_sockaddr, pub port_range: pj_uint16_t, pub so_rcvbuf_size: ::std::os::raw::c_uint, pub so_sndbuf_size: ::std::os::raw::c_uint }

extern "C" { pub fn pj_turn_sock_cfg_default(cfg: *mut pj_turn_sock_cfg); }

extern "C" { pub fn pj_turn_sock_create(cfg: *mut pj_stun_config, af: ::std::os::raw::c_int, conn_type: pj_turn_tp_type, cb: *const pj_turn_sock_cb, setting: *const pj_turn_sock_cfg, user_data: *mut ::std::os::raw::c_void, p_turn_sock: *mut *mut pj_turn_sock) -> pj_status_t; }

extern "C" { pub fn pj_turn_sock_destroy(turn_sock: *mut pj_turn_sock); }

extern "C" { pub fn pj_turn_sock_set_user_data(turn_sock: *mut pj_turn_sock, user_data: *mut ::std::os::raw::c_void) -> pj_status_t; }

extern "C" { pub fn pj_turn_sock_get_user_data(turn_sock: *mut pj_turn_sock) -> *mut ::std::os::raw::c_void; }

extern "C" { pub fn pj_turn_sock_get_grp_lock(turn_sock: *mut pj_turn_sock) -> *mut pj_grp_lock_t; }

extern "C" { pub fn pj_turn_sock_get_info(turn_sock: *mut pj_turn_sock, info: *mut pj_turn_session_info) -> pj_status_t; }

extern "C" { pub fn pj_turn_sock_lock(turn_sock: *mut pj_turn_sock) -> pj_status_t; }

extern "C" { pub fn pj_turn_sock_unlock(turn_sock: *mut pj_turn_sock) -> pj_status_t; }

extern "C" { pub fn pj_turn_sock_set_log(turn_sock: *mut pj_turn_sock, flags: ::std::os::raw::c_uint); }

extern "C" { pub fn pj_turn_sock_set_software_name(turn_sock: *mut pj_turn_sock, sw: *const pj_str_t) -> pj_status_t; }

extern "C" { pub fn pj_turn_sock_alloc(turn_sock: *mut pj_turn_sock, domain: *const pj_str_t, default_port: ::std::os::raw::c_int, resolver: *mut pj_dns_resolver, cred: *const pj_stun_auth_cred, param: *const pj_turn_alloc_param) -> pj_status_t; }

extern "C" { pub fn pj_turn_sock_set_perm(turn_sock: *mut pj_turn_sock, addr_cnt: ::std::os::raw::c_uint, addr: *const pj_sockaddr, options: ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pj_turn_sock_sendto(turn_sock: *mut pj_turn_sock, pkt: *const pj_uint8_t, pkt_len: ::std::os::raw::c_uint, peer_addr: *const pj_sockaddr_t, addr_len: ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pj_turn_sock_bind_channel(turn_sock: *mut pj_turn_sock, peer: *const pj_sockaddr_t, addr_len: ::std::os::raw::c_uint) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_ice_strans { _unused: [u8; 0] }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_ice_strans_op { PJ_ICE_STRANS_OP_INIT = 0, PJ_ICE_STRANS_OP_NEGOTIATION = 1, PJ_ICE_STRANS_OP_KEEP_ALIVE = 2, PJ_ICE_STRANS_OP_ADDR_CHANGE = 3 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_ice_strans_cb { pub on_rx_data: ::std::option::Option<unsafe extern "C" fn(ice_st: *mut pj_ice_strans, comp_id: ::std::os::raw::c_uint, pkt: *mut ::std::os::raw::c_void, size: pj_size_t, src_addr: *const pj_sockaddr_t, src_addr_len: ::std::os::raw::c_uint)>, pub on_ice_complete: ::std::option::Option<unsafe extern "C" fn(ice_st: *mut pj_ice_strans, op: pj_ice_strans_op, status: pj_status_t)> }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pj_ice_strans_stun_cfg { pub af: ::std::os::raw::c_int, pub cfg: pj_stun_sock_cfg, pub max_host_cands: ::std::os::raw::c_uint, pub loop_addr: pj_bool_t, pub server: pj_str_t, pub port: pj_uint16_t, pub ignore_stun_error: pj_bool_t }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pj_ice_strans_turn_cfg { pub af: ::std::os::raw::c_int, pub cfg: pj_turn_sock_cfg, pub server: pj_str_t, pub port: pj_uint16_t, pub conn_type: pj_turn_tp_type, pub auth_cred: pj_stun_auth_cred, pub alloc_param: pj_turn_alloc_param }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pj_ice_strans_cfg { pub af: ::std::os::raw::c_int, pub stun_cfg: pj_stun_config, pub resolver: *mut pj_dns_resolver, pub opt: pj_ice_sess_options, pub stun: pj_ice_strans_stun_cfg, pub stun_tp_cnt: ::std::os::raw::c_uint, pub stun_tp: [pj_ice_strans_stun_cfg; 2usize], pub turn: pj_ice_strans_turn_cfg, pub turn_tp_cnt: ::std::os::raw::c_uint, pub turn_tp: [pj_ice_strans_turn_cfg; 3usize], pub comp: [pj_ice_strans_cfg__bindgen_ty_1; 4usize] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_ice_strans_cfg__bindgen_ty_1 { pub qos_type: pj_qos_type, pub qos_params: pj_qos_params, pub so_rcvbuf_size: ::std::os::raw::c_uint, pub so_sndbuf_size: ::std::os::raw::c_uint }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_ice_strans_state { PJ_ICE_STRANS_STATE_NULL = 0, PJ_ICE_STRANS_STATE_INIT = 1, PJ_ICE_STRANS_STATE_READY = 2, PJ_ICE_STRANS_STATE_SESS_READY = 3, PJ_ICE_STRANS_STATE_NEGO = 4, PJ_ICE_STRANS_STATE_RUNNING = 5, PJ_ICE_STRANS_STATE_FAILED = 6 }

extern "C" { pub fn pj_ice_strans_cfg_default(cfg: *mut pj_ice_strans_cfg); }

extern "C" { pub fn pj_ice_strans_stun_cfg_default(cfg: *mut pj_ice_strans_stun_cfg); }

extern "C" { pub fn pj_ice_strans_turn_cfg_default(cfg: *mut pj_ice_strans_turn_cfg); }

extern "C" { pub fn pj_ice_strans_cfg_copy(pool: *mut pj_pool_t, dst: *mut pj_ice_strans_cfg, src: *const pj_ice_strans_cfg); }

extern "C" { pub fn pj_ice_strans_create(name: *const ::std::os::raw::c_char, cfg: *const pj_ice_strans_cfg, comp_cnt: ::std::os::raw::c_uint, user_data: *mut ::std::os::raw::c_void, cb: *const pj_ice_strans_cb, p_ice_st: *mut *mut pj_ice_strans) -> pj_status_t; }

extern "C" { pub fn pj_ice_strans_get_state(ice_st: *mut pj_ice_strans) -> pj_ice_strans_state; }

extern "C" { pub fn pj_ice_strans_state_name(state: pj_ice_strans_state) -> *const ::std::os::raw::c_char; }

extern "C" { pub fn pj_ice_strans_destroy(ice_st: *mut pj_ice_strans) -> pj_status_t; }

extern "C" { pub fn pj_ice_strans_get_user_data(ice_st: *mut pj_ice_strans) -> *mut ::std::os::raw::c_void; }

extern "C" { pub fn pj_ice_strans_get_options(ice_st: *mut pj_ice_strans, opt: *mut pj_ice_sess_options) -> pj_status_t; }

extern "C" { pub fn pj_ice_strans_set_options(ice_st: *mut pj_ice_strans, opt: *const pj_ice_sess_options) -> pj_status_t; }

extern "C" { pub fn pj_ice_strans_get_grp_lock(ice_st: *mut pj_ice_strans) -> *mut pj_grp_lock_t; }

extern "C" { pub fn pj_ice_strans_init_ice(ice_st: *mut pj_ice_strans, role: pj_ice_sess_role, local_ufrag: *const pj_str_t, local_passwd: *const pj_str_t) -> pj_status_t; }

extern "C" { pub fn pj_ice_strans_has_sess(ice_st: *mut pj_ice_strans) -> pj_bool_t; }

extern "C" { pub fn pj_ice_strans_sess_is_running(ice_st: *mut pj_ice_strans) -> pj_bool_t; }

extern "C" { pub fn pj_ice_strans_sess_is_complete(ice_st: *mut pj_ice_strans) -> pj_bool_t; }

extern "C" { pub fn pj_ice_strans_get_running_comp_cnt(ice_st: *mut pj_ice_strans) -> ::std::os::raw::c_uint; }

extern "C" { pub fn pj_ice_strans_get_ufrag_pwd(ice_st: *mut pj_ice_strans, loc_ufrag: *mut pj_str_t, loc_pwd: *mut pj_str_t, rem_ufrag: *mut pj_str_t, rem_pwd: *mut pj_str_t) -> pj_status_t; }

extern "C" { pub fn pj_ice_strans_get_cands_count(ice_st: *mut pj_ice_strans, comp_id: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint; }

extern "C" { pub fn pj_ice_strans_enum_cands(ice_st: *mut pj_ice_strans, comp_id: ::std::os::raw::c_uint, count: *mut ::std::os::raw::c_uint, cand: *mut pj_ice_sess_cand) -> pj_status_t; }

extern "C" { pub fn pj_ice_strans_get_def_cand(ice_st: *mut pj_ice_strans, comp_id: ::std::os::raw::c_uint, cand: *mut pj_ice_sess_cand) -> pj_status_t; }

extern "C" { pub fn pj_ice_strans_get_role(ice_st: *mut pj_ice_strans) -> pj_ice_sess_role; }

extern "C" { pub fn pj_ice_strans_change_role(ice_st: *mut pj_ice_strans, new_role: pj_ice_sess_role) -> pj_status_t; }

extern "C" { pub fn pj_ice_strans_start_ice(ice_st: *mut pj_ice_strans, rem_ufrag: *const pj_str_t, rem_passwd: *const pj_str_t, rcand_cnt: ::std::os::raw::c_uint, rcand: *const pj_ice_sess_cand) -> pj_status_t; }

extern "C" { pub fn pj_ice_strans_get_valid_pair(ice_st: *const pj_ice_strans, comp_id: ::std::os::raw::c_uint) -> *const pj_ice_sess_check; }

extern "C" { pub fn pj_ice_strans_stop_ice(ice_st: *mut pj_ice_strans) -> pj_status_t; }

extern "C" { pub fn pj_ice_strans_sendto(ice_st: *mut pj_ice_strans, comp_id: ::std::os::raw::c_uint, data: *const ::std::os::raw::c_void, data_len: pj_size_t, dst_addr: *const pj_sockaddr_t, dst_addr_len: ::std::os::raw::c_int) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_ice_cb { pub on_ice_complete: ::std::option::Option<unsafe extern "C" fn(tp: *mut pjmedia_transport, op: pj_ice_strans_op, status: pj_status_t)>, pub on_ice_complete2: ::std::option::Option<unsafe extern "C" fn(tp: *mut pjmedia_transport, op: pj_ice_strans_op, status: pj_status_t, user_data: *mut ::std::os::raw::c_void)> }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjmedia_ice_transport_info { pub active: pj_bool_t, pub sess_state: pj_ice_strans_state, pub role: pj_ice_sess_role, pub comp_cnt: ::std::os::raw::c_uint, pub comp: [pjmedia_ice_transport_info__bindgen_ty_1; 2usize] }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjmedia_ice_transport_info__bindgen_ty_1 { pub lcand_type: pj_ice_cand_type, pub lcand_addr: pj_sockaddr, pub rcand_type: pj_ice_cand_type, pub rcand_addr: pj_sockaddr }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_transport_ice_options { PJMEDIA_ICE_NO_SRC_ADDR_CHECKING = 1 }

extern "C" { pub fn pjmedia_ice_create(endpt: *mut pjmedia_endpt, name: *const ::std::os::raw::c_char, comp_cnt: ::std::os::raw::c_uint, cfg: *const pj_ice_strans_cfg, cb: *const pjmedia_ice_cb, p_tp: *mut *mut pjmedia_transport) -> pj_status_t; }

extern "C" { pub fn pjmedia_ice_create2(endpt: *mut pjmedia_endpt, name: *const ::std::os::raw::c_char, comp_cnt: ::std::os::raw::c_uint, cfg: *const pj_ice_strans_cfg, cb: *const pjmedia_ice_cb, options: ::std::os::raw::c_uint, p_tp: *mut *mut pjmedia_transport) -> pj_status_t; }

extern "C" { pub fn pjmedia_ice_create3(endpt: *mut pjmedia_endpt, name: *const ::std::os::raw::c_char, comp_cnt: ::std::os::raw::c_uint, cfg: *const pj_ice_strans_cfg, cb: *const pjmedia_ice_cb, options: ::std::os::raw::c_uint, user_data: *mut ::std::os::raw::c_void, p_tp: *mut *mut pjmedia_transport) -> pj_status_t; }

extern "C" { pub fn pjmedia_ice_get_grp_lock(tp: *mut pjmedia_transport) -> *mut pj_grp_lock_t; }

extern "C" { pub fn pjmedia_ice_add_ice_cb(tp: *mut pjmedia_transport, cb: *const pjmedia_ice_cb, user_data: *mut ::std::os::raw::c_void) -> pj_status_t; }

extern "C" { pub fn pjmedia_ice_remove_ice_cb(tp: *mut pjmedia_transport, cb: *const pjmedia_ice_cb, user_data: *mut ::std::os::raw::c_void) -> pj_status_t; }

extern "C" { pub fn pjmedia_transport_loop_create(endpt: *mut pjmedia_endpt, p_tp: *mut *mut pjmedia_transport) -> pj_status_t; }

extern "C" { pub fn pjmedia_transport_loop_disable_rx(tp: *mut pjmedia_transport, user: *mut ::std::os::raw::c_void, disabled: pj_bool_t) -> pj_status_t; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_srtp_crypto_option { PJMEDIA_SRTP_NO_ENCRYPTION = 1, PJMEDIA_SRTP_NO_AUTHENTICATION = 2 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_srtp_crypto { pub key: pj_str_t, pub name: pj_str_t, pub flags: ::std::os::raw::c_uint }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_srtp_use { PJMEDIA_SRTP_DISABLED = 0, PJMEDIA_SRTP_OPTIONAL = 1, PJMEDIA_SRTP_MANDATORY = 2 }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_srtp_keying_method { PJMEDIA_SRTP_KEYING_SDES = 0, PJMEDIA_SRTP_KEYING_DTLS_SRTP = 1, PJMEDIA_SRTP_KEYINGS_COUNT = 2 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_srtp_cb { pub on_srtp_nego_complete: ::std::option::Option<unsafe extern "C" fn(tp: *mut pjmedia_transport, status: pj_status_t)> }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_srtp_setting { pub use_: pjmedia_srtp_use, pub close_member_tp: pj_bool_t, pub crypto_count: ::std::os::raw::c_uint, pub crypto: [pjmedia_srtp_crypto; 16usize], pub keying_count: ::std::os::raw::c_uint, pub keying: [pjmedia_srtp_keying_method; 2usize], pub cb: pjmedia_srtp_cb, pub user_data: *mut ::std::os::raw::c_void }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_srtp_info { pub active: pj_bool_t, pub rx_policy: pjmedia_srtp_crypto, pub tx_policy: pjmedia_srtp_crypto, pub use_: pjmedia_srtp_use, pub peer_use: pjmedia_srtp_use }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjmedia_srtp_dtls_nego_param { pub rem_fingerprint: pj_str_t, pub rem_addr: pj_sockaddr, pub rem_rtcp: pj_sockaddr, pub is_role_active: pj_bool_t }

extern "C" { pub fn pjmedia_srtp_init_lib(endpt: *mut pjmedia_endpt) -> pj_status_t; }

extern "C" { pub fn pjmedia_srtp_setting_default(opt: *mut pjmedia_srtp_setting); }

extern "C" { pub fn pjmedia_transport_srtp_create(endpt: *mut pjmedia_endpt, tp: *mut pjmedia_transport, opt: *const pjmedia_srtp_setting, p_tp: *mut *mut pjmedia_transport) -> pj_status_t; }

extern "C" { pub fn pjmedia_transport_srtp_dtls_get_fingerprint(srtp: *mut pjmedia_transport, hash: *const ::std::os::raw::c_char, buf: *mut ::std::os::raw::c_char, len: *mut pj_size_t) -> pj_status_t; }

extern "C" { pub fn pjmedia_transport_srtp_dtls_start_nego(srtp: *mut pjmedia_transport, param: *const pjmedia_srtp_dtls_nego_param) -> pj_status_t; }

extern "C" { pub fn pjmedia_transport_srtp_start(srtp: *mut pjmedia_transport, tx: *const pjmedia_srtp_crypto, rx: *const pjmedia_srtp_crypto) -> pj_status_t; }

extern "C" { pub fn pjmedia_transport_srtp_stop(srtp: *mut pjmedia_transport) -> pj_status_t; }

extern "C" { pub fn pjmedia_transport_srtp_decrypt_pkt(tp: *mut pjmedia_transport, is_rtp: pj_bool_t, pkt: *mut ::std::os::raw::c_void, pkt_len: *mut ::std::os::raw::c_int) -> pj_status_t; }

extern "C" { pub fn pjmedia_transport_srtp_get_member(srtp: *mut pjmedia_transport) -> *mut pjmedia_transport; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_transport_udp_options { PJMEDIA_UDP_NO_SRC_ADDR_CHECKING = 1 }

extern "C" { pub fn pjmedia_transport_udp_create(endpt: *mut pjmedia_endpt, name: *const ::std::os::raw::c_char, port: ::std::os::raw::c_int, options: ::std::os::raw::c_uint, p_tp: *mut *mut pjmedia_transport) -> pj_status_t; }

extern "C" { pub fn pjmedia_transport_udp_create2(endpt: *mut pjmedia_endpt, name: *const ::std::os::raw::c_char, addr: *const pj_str_t, port: ::std::os::raw::c_int, options: ::std::os::raw::c_uint, p_tp: *mut *mut pjmedia_transport) -> pj_status_t; }

extern "C" { pub fn pjmedia_transport_udp_create3(endpt: *mut pjmedia_endpt, af: ::std::os::raw::c_int, name: *const ::std::os::raw::c_char, addr: *const pj_str_t, port: ::std::os::raw::c_int, options: ::std::os::raw::c_uint, p_tp: *mut *mut pjmedia_transport) -> pj_status_t; }

extern "C" { pub fn pjmedia_transport_udp_attach(endpt: *mut pjmedia_endpt, name: *const ::std::os::raw::c_char, si: *const pjmedia_sock_info, options: ::std::os::raw::c_uint, p_tp: *mut *mut pjmedia_transport) -> pj_status_t; }

extern "C" { pub fn pjmedia_videodev_strerror(status: pj_status_t, buffer: *mut ::std::os::raw::c_char, bufsize: pj_size_t) -> pj_str_t; }

pub type pjmedia_vid_dev_index = pj_int32_t;

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_vid_dev_hwnd_type { PJMEDIA_VID_DEV_HWND_TYPE_NONE = 0, PJMEDIA_VID_DEV_HWND_TYPE_WINDOWS = 1, PJMEDIA_VID_DEV_HWND_TYPE_IOS = 2, PJMEDIA_VID_DEV_HWND_TYPE_ANDROID = 3 }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjmedia_vid_dev_hwnd { pub type_: pjmedia_vid_dev_hwnd_type, pub info: pjmedia_vid_dev_hwnd__bindgen_ty_1 }

#[repr(C)]
#[derive(Copy, Clone)]
pub union pjmedia_vid_dev_hwnd__bindgen_ty_1 { pub win: pjmedia_vid_dev_hwnd__bindgen_ty_1__bindgen_ty_1, pub x11: pjmedia_vid_dev_hwnd__bindgen_ty_1__bindgen_ty_2, pub cocoa: pjmedia_vid_dev_hwnd__bindgen_ty_1__bindgen_ty_3, pub ios: pjmedia_vid_dev_hwnd__bindgen_ty_1__bindgen_ty_4, pub android: pjmedia_vid_dev_hwnd__bindgen_ty_1__bindgen_ty_5, pub window: *mut ::std::os::raw::c_void, _bindgen_union_align: [u32; 2usize] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_vid_dev_hwnd__bindgen_ty_1__bindgen_ty_1 { pub hwnd: *mut ::std::os::raw::c_void }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_vid_dev_hwnd__bindgen_ty_1__bindgen_ty_2 { pub window: *mut ::std::os::raw::c_void, pub display: *mut ::std::os::raw::c_void }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_vid_dev_hwnd__bindgen_ty_1__bindgen_ty_3 { pub window: *mut ::std::os::raw::c_void }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_vid_dev_hwnd__bindgen_ty_1__bindgen_ty_4 { pub window: *mut ::std::os::raw::c_void }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_vid_dev_hwnd__bindgen_ty_1__bindgen_ty_5 { pub window: *mut ::std::os::raw::c_void }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_vid_dev_switch_param { pub target_id: pjmedia_vid_dev_index }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_vid_dev_wnd_flag { PJMEDIA_VID_DEV_WND_BORDER = 1, PJMEDIA_VID_DEV_WND_RESIZABLE = 2 }

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_vid_dev_std_index { PJMEDIA_VID_DEFAULT_CAPTURE_DEV = -1, PJMEDIA_VID_DEFAULT_RENDER_DEV = -2, PJMEDIA_VID_INVALID_DEV = -3 }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_vid_dev_cap { PJMEDIA_VID_DEV_CAP_FORMAT = 1, PJMEDIA_VID_DEV_CAP_INPUT_SCALE = 2, PJMEDIA_VID_DEV_CAP_OUTPUT_WINDOW = 4, PJMEDIA_VID_DEV_CAP_OUTPUT_RESIZE = 8, PJMEDIA_VID_DEV_CAP_OUTPUT_POSITION = 16, PJMEDIA_VID_DEV_CAP_OUTPUT_HIDE = 32, PJMEDIA_VID_DEV_CAP_INPUT_PREVIEW = 64, PJMEDIA_VID_DEV_CAP_ORIENTATION = 128, PJMEDIA_VID_DEV_CAP_SWITCH = 256, PJMEDIA_VID_DEV_CAP_OUTPUT_WINDOW_FLAGS = 512, PJMEDIA_VID_DEV_CAP_MAX = 16384 }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjmedia_vid_dev_info { pub id: pjmedia_vid_dev_index, pub name: [::std::os::raw::c_char; 64usize], pub driver: [::std::os::raw::c_char; 32usize], pub dir: pjmedia_dir, pub has_callback: pj_bool_t, pub caps: ::std::os::raw::c_uint, pub fmt_cnt: ::std::os::raw::c_uint, pub fmt: [pjmedia_format; 64usize] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_vid_dev_cb { pub capture_cb: ::std::option::Option<unsafe extern "C" fn(stream: *mut pjmedia_vid_dev_stream, user_data: *mut ::std::os::raw::c_void, frame: *mut pjmedia_frame) -> pj_status_t>, pub render_cb: ::std::option::Option<unsafe extern "C" fn(stream: *mut pjmedia_vid_dev_stream, user_data: *mut ::std::os::raw::c_void, frame: *mut pjmedia_frame) -> pj_status_t> }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjmedia_vid_dev_param { pub dir: pjmedia_dir, pub cap_id: pjmedia_vid_dev_index, pub rend_id: pjmedia_vid_dev_index, pub clock_rate: ::std::os::raw::c_uint, pub flags: ::std::os::raw::c_uint, pub fmt: pjmedia_format, pub window: pjmedia_vid_dev_hwnd, pub disp_size: pjmedia_rect_size, pub window_pos: pjmedia_coord, pub window_hide: pj_bool_t, pub native_preview: pj_bool_t, pub orient: pjmedia_orient, pub window_flags: ::std::os::raw::c_uint }

pub type pjmedia_vid_dev_factory_create_func_ptr = ::std::option::Option<unsafe extern "C" fn(arg1: *mut pj_pool_factory) -> *mut pjmedia_vid_dev_factory>;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_vid_driver { pub create: pjmedia_vid_dev_factory_create_func_ptr, pub f: *mut pjmedia_vid_dev_factory, pub name: [::std::os::raw::c_char; 32usize], pub dev_cnt: ::std::os::raw::c_uint, pub start_idx: ::std::os::raw::c_uint, pub cap_dev_idx: ::std::os::raw::c_int, pub rend_dev_idx: ::std::os::raw::c_int }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_vid_subsys { pub init_count: ::std::os::raw::c_uint, pub pf: *mut pj_pool_factory, pub drv_cnt: ::std::os::raw::c_uint, pub drv: [pjmedia_vid_driver; 8usize], pub dev_cnt: ::std::os::raw::c_uint, pub dev_list: [pj_uint32_t; 16usize] }

extern "C" { pub fn pjmedia_get_vid_subsys() -> *mut pjmedia_vid_subsys; }

extern "C" { pub fn pjmedia_vid_driver_init(drv_idx: ::std::os::raw::c_uint, refresh: pj_bool_t) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_driver_deinit(drv_idx: ::std::os::raw::c_uint); }

extern "C" { pub fn pjmedia_vid_dev_cap_name(cap: pjmedia_vid_dev_cap, p_desc: *mut *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char; }

extern "C" { pub fn pjmedia_vid_dev_param_set_cap(param: *mut pjmedia_vid_dev_param, cap: pjmedia_vid_dev_cap, pval: *const ::std::os::raw::c_void) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_dev_param_get_cap(param: *const pjmedia_vid_dev_param, cap: pjmedia_vid_dev_cap, pval: *mut ::std::os::raw::c_void) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_dev_refresh() -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_dev_count() -> ::std::os::raw::c_uint; }

extern "C" { pub fn pjmedia_vid_dev_get_info(id: pjmedia_vid_dev_index, info: *mut pjmedia_vid_dev_info) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_dev_lookup(drv_name: *const ::std::os::raw::c_char, dev_name: *const ::std::os::raw::c_char, id: *mut pjmedia_vid_dev_index) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_dev_default_param(pool: *mut pj_pool_t, id: pjmedia_vid_dev_index, param: *mut pjmedia_vid_dev_param) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_dev_stream_create(param: *mut pjmedia_vid_dev_param, cb: *const pjmedia_vid_dev_cb, user_data: *mut ::std::os::raw::c_void, p_strm: *mut *mut pjmedia_vid_dev_stream) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_dev_stream_get_param(strm: *mut pjmedia_vid_dev_stream, param: *mut pjmedia_vid_dev_param) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_dev_stream_get_cap(strm: *mut pjmedia_vid_dev_stream, cap: pjmedia_vid_dev_cap, value: *mut ::std::os::raw::c_void) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_dev_stream_set_cap(strm: *mut pjmedia_vid_dev_stream, cap: pjmedia_vid_dev_cap, value: *const ::std::os::raw::c_void) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_dev_stream_start(strm: *mut pjmedia_vid_dev_stream) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_dev_stream_is_running(strm: *mut pjmedia_vid_dev_stream) -> pj_bool_t; }

extern "C" { pub fn pjmedia_vid_dev_stream_get_frame(strm: *mut pjmedia_vid_dev_stream, frame: *mut pjmedia_frame) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_dev_stream_put_frame(strm: *mut pjmedia_vid_dev_stream, frame: *const pjmedia_frame) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_dev_stream_stop(strm: *mut pjmedia_vid_dev_stream) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_dev_stream_destroy(strm: *mut pjmedia_vid_dev_stream) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_dev_subsys_init(pf: *mut pj_pool_factory) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_dev_subsys_get_pool_factory() -> *mut pj_pool_factory; }

extern "C" { pub fn pjmedia_vid_dev_subsys_shutdown() -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_register_factory(vdf: pjmedia_vid_dev_factory_create_func_ptr, factory: *mut pjmedia_vid_dev_factory) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_unregister_factory(vdf: pjmedia_vid_dev_factory_create_func_ptr, factory: *mut pjmedia_vid_dev_factory) -> pj_status_t; }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjmedia_vid_port_param { pub vidparam: pjmedia_vid_dev_param, pub active: pj_bool_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_vid_port { _unused: [u8; 0] }

extern "C" { pub fn pjmedia_vid_port_param_default(prm: *mut pjmedia_vid_port_param); }

extern "C" { pub fn pjmedia_vid_port_create(pool: *mut pj_pool_t, prm: *const pjmedia_vid_port_param, p_vp: *mut *mut pjmedia_vid_port) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_port_set_cb(vid_port: *mut pjmedia_vid_port, cb: *const pjmedia_vid_dev_cb, user_data: *mut ::std::os::raw::c_void); }

extern "C" { pub fn pjmedia_vid_port_get_stream(vid_port: *mut pjmedia_vid_port) -> *mut pjmedia_vid_dev_stream; }

extern "C" { pub fn pjmedia_vid_port_get_passive_port(vid_port: *mut pjmedia_vid_port) -> *mut pjmedia_port; }

extern "C" { pub fn pjmedia_vid_port_get_clock_src(vid_port: *mut pjmedia_vid_port) -> *mut pjmedia_clock_src; }

extern "C" { pub fn pjmedia_vid_port_set_clock_src(vid_port: *mut pjmedia_vid_port, clocksrc: *mut pjmedia_clock_src) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_port_connect(vid_port: *mut pjmedia_vid_port, port: *mut pjmedia_port, destroy: pj_bool_t) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_port_disconnect(vid_port: *mut pjmedia_vid_port) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_port_get_connected_port(vid_port: *mut pjmedia_vid_port) -> *mut pjmedia_port; }

extern "C" { pub fn pjmedia_vid_port_start(vid_port: *mut pjmedia_vid_port) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_port_is_running(vid_port: *mut pjmedia_vid_port) -> pj_bool_t; }

extern "C" { pub fn pjmedia_vid_port_stop(vid_port: *mut pjmedia_vid_port) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_port_destroy(vid_port: *mut pjmedia_vid_port); }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_vid_stream_rc_method { PJMEDIA_VID_STREAM_RC_NONE = 0, PJMEDIA_VID_STREAM_RC_SIMPLE_BLOCKING = 1 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_vid_stream_rc_config { pub method: pjmedia_vid_stream_rc_method, pub bandwidth: ::std::os::raw::c_uint }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_vid_stream_sk_config { pub count: ::std::os::raw::c_uint, pub interval: ::std::os::raw::c_uint }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjmedia_vid_stream_info { pub type_: pjmedia_type, pub proto: pjmedia_tp_proto, pub dir: pjmedia_dir, pub rem_addr: pj_sockaddr, pub rem_rtcp: pj_sockaddr, pub tx_pt: ::std::os::raw::c_uint, pub rx_pt: ::std::os::raw::c_uint, pub ssrc: pj_uint32_t, pub rtp_ts: pj_uint32_t, pub rtp_seq: pj_uint16_t, pub rtp_seq_ts_set: pj_uint8_t, pub jb_init: ::std::os::raw::c_int, pub jb_min_pre: ::std::os::raw::c_int, pub jb_max_pre: ::std::os::raw::c_int, pub jb_max: ::std::os::raw::c_int, pub codec_info: pjmedia_vid_codec_info, pub codec_param: *mut pjmedia_vid_codec_param, pub rtcp_sdes_bye_disabled: pj_bool_t, pub rc_cfg: pjmedia_vid_stream_rc_config, pub sk_cfg: pjmedia_vid_stream_sk_config }

extern "C" { pub fn pjmedia_vid_stream_info_from_sdp(si: *mut pjmedia_vid_stream_info, pool: *mut pj_pool_t, endpt: *mut pjmedia_endpt, local: *const pjmedia_sdp_session, remote: *const pjmedia_sdp_session, stream_idx: ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_stream_rc_config_default(cfg: *mut pjmedia_vid_stream_rc_config); }

extern "C" { pub fn pjmedia_vid_stream_sk_config_default(cfg: *mut pjmedia_vid_stream_sk_config); }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_vid_stream { _unused: [u8; 0] }

extern "C" { pub fn pjmedia_vid_stream_create(endpt: *mut pjmedia_endpt, pool: *mut pj_pool_t, info: *mut pjmedia_vid_stream_info, tp: *mut pjmedia_transport, user_data: *mut ::std::os::raw::c_void, p_stream: *mut *mut pjmedia_vid_stream) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_stream_destroy(stream: *mut pjmedia_vid_stream) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_stream_get_port(stream: *mut pjmedia_vid_stream, dir: pjmedia_dir, p_port: *mut *mut pjmedia_port) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_stream_get_transport(st: *mut pjmedia_vid_stream) -> *mut pjmedia_transport; }

extern "C" { pub fn pjmedia_vid_stream_get_stat(stream: *const pjmedia_vid_stream, stat: *mut pjmedia_rtcp_stat) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_stream_reset_stat(stream: *mut pjmedia_vid_stream) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_stream_get_stat_jbuf(stream: *const pjmedia_vid_stream, state: *mut pjmedia_jb_state) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_stream_get_info(stream: *const pjmedia_vid_stream, info: *mut pjmedia_vid_stream_info) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_stream_start(stream: *mut pjmedia_vid_stream) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_stream_is_running(stream: *mut pjmedia_vid_stream, dir: pjmedia_dir) -> pj_bool_t; }

extern "C" { pub fn pjmedia_vid_stream_pause(stream: *mut pjmedia_vid_stream, dir: pjmedia_dir) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_stream_resume(stream: *mut pjmedia_vid_stream, dir: pjmedia_dir) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_stream_send_keyframe(stream: *mut pjmedia_vid_stream) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_stream_send_rtcp_sdes(stream: *mut pjmedia_vid_stream) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_stream_send_rtcp_bye(stream: *mut pjmedia_vid_stream) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_stream_get_rtp_session_info(stream: *mut pjmedia_vid_stream, session_info: *mut pjmedia_stream_rtp_sess_info) -> pj_status_t; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_vid_tee_flag { PJMEDIA_VID_TEE_DST_DO_IN_PLACE_PROC = 4 }

extern "C" { pub fn pjmedia_vid_tee_create(pool: *mut pj_pool_t, fmt: *const pjmedia_format, max_dst_cnt: ::std::os::raw::c_uint, p_vid_tee: *mut *mut pjmedia_port) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_tee_add_dst_port(vid_tee: *mut pjmedia_port, option: ::std::os::raw::c_uint, port: *mut pjmedia_port) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_tee_add_dst_port2(vid_tee: *mut pjmedia_port, option: ::std::os::raw::c_uint, port: *mut pjmedia_port) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_tee_remove_dst_port(vid_tee: *mut pjmedia_port, port: *mut pjmedia_port) -> pj_status_t; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_file_player_option { PJMEDIA_FILE_NO_LOOP = 1 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_wav_player_info { pub fmt_id: pjmedia_format_id, pub payload_bits_per_sample: ::std::os::raw::c_uint, pub size_bytes: pj_uint32_t, pub size_samples: pj_uint32_t }

extern "C" { pub fn pjmedia_wav_player_port_create(pool: *mut pj_pool_t, filename: *const ::std::os::raw::c_char, ptime: ::std::os::raw::c_uint, flags: ::std::os::raw::c_uint, buff_size: pj_ssize_t, p_port: *mut *mut pjmedia_port) -> pj_status_t; }

extern "C" { pub fn pjmedia_wav_player_get_info(port: *mut pjmedia_port, i: *mut pjmedia_wav_player_info) -> pj_status_t; }

extern "C" { pub fn pjmedia_wav_player_get_len(port: *mut pjmedia_port) -> pj_ssize_t; }

extern "C" { pub fn pjmedia_wav_player_port_set_pos(port: *mut pjmedia_port, offset: pj_uint32_t) -> pj_status_t; }

extern "C" { pub fn pjmedia_wav_player_port_get_pos(port: *mut pjmedia_port) -> pj_ssize_t; }

extern "C" { pub fn pjmedia_wav_player_set_eof_cb(port: *mut pjmedia_port, user_data: *mut ::std::os::raw::c_void, cb: ::std::option::Option<unsafe extern "C" fn(port: *mut pjmedia_port, usr_data: *mut ::std::os::raw::c_void) -> pj_status_t>) -> pj_status_t; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_file_writer_option { PJMEDIA_FILE_WRITE_PCM = 0, PJMEDIA_FILE_WRITE_ALAW = 1, PJMEDIA_FILE_WRITE_ULAW = 2 }

extern "C" { pub fn pjmedia_wav_writer_port_create(pool: *mut pj_pool_t, filename: *const ::std::os::raw::c_char, clock_rate: ::std::os::raw::c_uint, channel_count: ::std::os::raw::c_uint, samples_per_frame: ::std::os::raw::c_uint, bits_per_sample: ::std::os::raw::c_uint, flags: ::std::os::raw::c_uint, buff_size: pj_ssize_t, p_port: *mut *mut pjmedia_port) -> pj_status_t; }

extern "C" { pub fn pjmedia_wav_writer_port_get_pos(port: *mut pjmedia_port) -> pj_ssize_t; }

extern "C" { pub fn pjmedia_wav_writer_port_set_cb(port: *mut pjmedia_port, pos: pj_size_t, user_data: *mut ::std::os::raw::c_void, cb: ::std::option::Option<unsafe extern "C" fn(port: *mut pjmedia_port, usr_data: *mut ::std::os::raw::c_void) -> pj_status_t>) -> pj_status_t; }

extern "C" { pub fn pjmedia_wav_playlist_create(pool: *mut pj_pool_t, port_label: *const pj_str_t, file_list: *const pj_str_t, file_count: ::std::os::raw::c_int, ptime: ::std::os::raw::c_uint, options: ::std::os::raw::c_uint, buff_size: pj_ssize_t, p_port: *mut *mut pjmedia_port) -> pj_status_t; }

extern "C" { pub fn pjmedia_wav_playlist_set_eof_cb(port: *mut pjmedia_port, user_data: *mut ::std::os::raw::c_void, cb: ::std::option::Option<unsafe extern "C" fn(port: *mut pjmedia_port, usr_data: *mut ::std::os::raw::c_void) -> pj_status_t>) -> pj_status_t; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_wave_fmt_tag { PJMEDIA_WAVE_FMT_TAG_PCM = 1, PJMEDIA_WAVE_FMT_TAG_ALAW = 6, PJMEDIA_WAVE_FMT_TAG_ULAW = 7 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_wave_hdr { pub riff_hdr: pjmedia_wave_hdr__bindgen_ty_1, pub fmt_hdr: pjmedia_wave_hdr__bindgen_ty_2, pub data_hdr: pjmedia_wave_hdr__bindgen_ty_3 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_wave_hdr__bindgen_ty_1 { pub _bindgen_opaque_blob: [u16; 6usize] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_wave_hdr__bindgen_ty_2 { pub _bindgen_opaque_blob: [u16; 12usize] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_wave_hdr__bindgen_ty_3 { pub _bindgen_opaque_blob: [u16; 4usize] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_wave_subchunk { pub id: pj_uint32_t, pub len: pj_uint32_t }

extern "C" { pub fn pjmedia_wave_hdr_file_to_host(hdr: *mut pjmedia_wave_hdr); }

extern "C" { pub fn pjmedia_wave_hdr_host_to_file(hdr: *mut pjmedia_wave_hdr); }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_wsola { _unused: [u8; 0] }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_wsola_option { PJMEDIA_WSOLA_NO_HANNING = 1, PJMEDIA_WSOLA_NO_PLC = 2, PJMEDIA_WSOLA_NO_DISCARD = 4, PJMEDIA_WSOLA_NO_FADING = 8 }

extern "C" { pub fn pjmedia_wsola_create(pool: *mut pj_pool_t, clock_rate: ::std::os::raw::c_uint, samples_per_frame: ::std::os::raw::c_uint, channel_count: ::std::os::raw::c_uint, options: ::std::os::raw::c_uint, p_wsola: *mut *mut pjmedia_wsola) -> pj_status_t; }

extern "C" { pub fn pjmedia_wsola_set_max_expand(wsola: *mut pjmedia_wsola, msec: ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pjmedia_wsola_destroy(wsola: *mut pjmedia_wsola) -> pj_status_t; }

extern "C" { pub fn pjmedia_wsola_reset(wsola: *mut pjmedia_wsola, options: ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pjmedia_wsola_save(wsola: *mut pjmedia_wsola, frm: *mut pj_int16_t, prev_lost: pj_bool_t) -> pj_status_t; }

extern "C" { pub fn pjmedia_wsola_generate(wsola: *mut pjmedia_wsola, frm: *mut pj_int16_t) -> pj_status_t; }

extern "C" { pub fn pjmedia_wsola_discard(wsola: *mut pjmedia_wsola, buf1: *mut pj_int16_t, buf1_cnt: ::std::os::raw::c_uint, buf2: *mut pj_int16_t, buf2_cnt: ::std::os::raw::c_uint, erase_cnt: *mut ::std::os::raw::c_uint) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_codec_passthrough_setting { pub fmt_cnt: ::std::os::raw::c_uint, pub fmts: *mut pjmedia_format, pub ilbc_mode: ::std::os::raw::c_uint }

extern "C" { pub fn pjmedia_codec_passthrough_init(endpt: *mut pjmedia_endpt) -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_passthrough_init2(endpt: *mut pjmedia_endpt, setting: *const pjmedia_codec_passthrough_setting) -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_passthrough_deinit() -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_audio_codec_config { pub speex: pjmedia_audio_codec_config__bindgen_ty_1, pub ilbc: pjmedia_audio_codec_config__bindgen_ty_2, pub passthrough: pjmedia_audio_codec_config__bindgen_ty_3 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_audio_codec_config__bindgen_ty_1 { pub option: ::std::os::raw::c_uint, pub quality: ::std::os::raw::c_int, pub complexity: ::std::os::raw::c_int }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_audio_codec_config__bindgen_ty_2 { pub mode: ::std::os::raw::c_uint }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_audio_codec_config__bindgen_ty_3 { pub setting: pjmedia_codec_passthrough_setting }

extern "C" { pub fn pjmedia_audio_codec_config_default(cfg: *mut pjmedia_audio_codec_config); }

extern "C" { pub fn pjmedia_codec_register_audio_codecs(endpt: *mut pjmedia_endpt, c: *const pjmedia_audio_codec_config) -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_l16_init(endpt: *mut pjmedia_endpt, options: ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_l16_deinit() -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_ffmpeg_vid_init(mgr: *mut pjmedia_vid_codec_mgr, pf: *mut pj_pool_factory) -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_ffmpeg_vid_deinit() -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_gsm_init(endpt: *mut pjmedia_endpt) -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_gsm_deinit() -> pj_status_t; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_speex_options { PJMEDIA_SPEEX_NO_NB = 1, PJMEDIA_SPEEX_NO_WB = 2, PJMEDIA_SPEEX_NO_UWB = 4 }

extern "C" { pub fn pjmedia_codec_speex_init(endpt: *mut pjmedia_endpt, options: ::std::os::raw::c_uint, quality: ::std::os::raw::c_int, complexity: ::std::os::raw::c_int) -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_speex_init_default(endpt: *mut pjmedia_endpt) -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_speex_set_param(clock_rate: ::std::os::raw::c_uint, quality: ::std::os::raw::c_int, complexity: ::std::os::raw::c_int) -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_speex_deinit() -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_ilbc_init(endpt: *mut pjmedia_endpt, mode: ::std::os::raw::c_int) -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_ilbc_deinit() -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_g722_init(endpt: *mut pjmedia_endpt) -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_g722_deinit() -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_g722_set_pcm_shift(val: ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_g7221_init(endpt: *mut pjmedia_endpt) -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_g7221_set_mode(sample_rate: ::std::os::raw::c_uint, bitrate: ::std::os::raw::c_uint, enabled: pj_bool_t) -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_g7221_set_pcm_shift(val: ::std::os::raw::c_int) -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_g7221_deinit() -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_ipp_init(endpt: *mut pjmedia_endpt) -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_ipp_deinit() -> pj_status_t; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjmedia_amr_options { PJMEDIA_AMR_NO_NB = 1, PJMEDIA_AMR_NO_WB = 2 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_codec_amr_config { pub octet_align: pj_bool_t, pub bitrate: ::std::os::raw::c_uint }

pub type pjmedia_codec_amrnb_config = pjmedia_codec_amr_config;
pub type pjmedia_codec_amrwb_config = pjmedia_codec_amr_config;

extern "C" { pub fn pjmedia_codec_opencore_amr_init(endpt: *mut pjmedia_endpt, options: ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_opencore_amr_init_default(endpt: *mut pjmedia_endpt) -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_opencore_amr_deinit() -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_opencore_amrnb_init(endpt: *mut pjmedia_endpt) -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_opencore_amrnb_deinit() -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_opencore_amrnb_set_config(cfg: *const pjmedia_codec_amrnb_config) -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_opencore_amrwb_set_config(cfg: *const pjmedia_codec_amrwb_config) -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_vid_toolbox_init(mgr: *mut pjmedia_vid_codec_mgr, pf: *mut pj_pool_factory) -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_vid_toolbox_deinit() -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_openh264_vid_init(mgr: *mut pjmedia_vid_codec_mgr, pf: *mut pj_pool_factory) -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_openh264_vid_deinit() -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_codec_silk_setting { pub enabled: pj_bool_t, pub quality: ::std::os::raw::c_int, pub complexity: ::std::os::raw::c_int }

extern "C" { pub fn pjmedia_codec_silk_init(endpt: *mut pjmedia_endpt) -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_silk_set_config(clock_rate: ::std::os::raw::c_uint, opt: *const pjmedia_codec_silk_setting) -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_silk_deinit() -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_codec_opus_config { pub sample_rate: ::std::os::raw::c_uint, pub channel_cnt: ::std::os::raw::c_uint, pub bit_rate: ::std::os::raw::c_uint, pub packet_loss: ::std::os::raw::c_uint, pub complexity: ::std::os::raw::c_uint, pub cbr: pj_bool_t }

extern "C" { pub fn pjmedia_codec_opus_init(endpt: *mut pjmedia_endpt) -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_opus_deinit() -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_opus_get_config(cfg: *mut pjmedia_codec_opus_config) -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_opus_set_default_param(cfg: *const pjmedia_codec_opus_config, param: *mut pjmedia_codec_param) -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_bcg729_init(endpt: *mut pjmedia_endpt) -> pj_status_t; }

extern "C" { pub fn pjmedia_codec_bcg729_deinit() -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_vid_dev_factory_op { pub init: ::std::option::Option<unsafe extern "C" fn(f: *mut pjmedia_vid_dev_factory) -> pj_status_t>, pub destroy: ::std::option::Option<unsafe extern "C" fn(f: *mut pjmedia_vid_dev_factory) -> pj_status_t>, pub get_dev_count: ::std::option::Option<unsafe extern "C" fn(f: *mut pjmedia_vid_dev_factory) -> ::std::os::raw::c_uint>, pub get_dev_info: ::std::option::Option<unsafe extern "C" fn(f: *mut pjmedia_vid_dev_factory, index: ::std::os::raw::c_uint, info: *mut pjmedia_vid_dev_info) -> pj_status_t>, pub default_param: ::std::option::Option<unsafe extern "C" fn(pool: *mut pj_pool_t, f: *mut pjmedia_vid_dev_factory, index: ::std::os::raw::c_uint, param: *mut pjmedia_vid_dev_param) -> pj_status_t>, pub create_stream: ::std::option::Option<unsafe extern "C" fn(f: *mut pjmedia_vid_dev_factory, param: *mut pjmedia_vid_dev_param, cb: *const pjmedia_vid_dev_cb, user_data: *mut ::std::os::raw::c_void, p_vid_strm: *mut *mut pjmedia_vid_dev_stream) -> pj_status_t>, pub refresh: ::std::option::Option<unsafe extern "C" fn(f: *mut pjmedia_vid_dev_factory) -> pj_status_t> }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_vid_dev_factory { pub sys: pjmedia_vid_dev_factory__bindgen_ty_1, pub op: *mut pjmedia_vid_dev_factory_op }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_vid_dev_factory__bindgen_ty_1 { pub drv_idx: ::std::os::raw::c_uint }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_vid_dev_stream_op { pub get_param: ::std::option::Option<unsafe extern "C" fn(strm: *mut pjmedia_vid_dev_stream, param: *mut pjmedia_vid_dev_param) -> pj_status_t>, pub get_cap: ::std::option::Option<unsafe extern "C" fn(strm: *mut pjmedia_vid_dev_stream, cap: pjmedia_vid_dev_cap, value: *mut ::std::os::raw::c_void) -> pj_status_t>, pub set_cap: ::std::option::Option<unsafe extern "C" fn(strm: *mut pjmedia_vid_dev_stream, cap: pjmedia_vid_dev_cap, value: *const ::std::os::raw::c_void) -> pj_status_t>, pub start: ::std::option::Option<unsafe extern "C" fn(strm: *mut pjmedia_vid_dev_stream) -> pj_status_t>, pub get_frame: ::std::option::Option<unsafe extern "C" fn(strm: *mut pjmedia_vid_dev_stream, frame: *mut pjmedia_frame) -> pj_status_t>, pub put_frame: ::std::option::Option<unsafe extern "C" fn(strm: *mut pjmedia_vid_dev_stream, frame: *const pjmedia_frame) -> pj_status_t>, pub stop: ::std::option::Option<unsafe extern "C" fn(strm: *mut pjmedia_vid_dev_stream) -> pj_status_t>, pub destroy: ::std::option::Option<unsafe extern "C" fn(strm: *mut pjmedia_vid_dev_stream) -> pj_status_t> }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_vid_dev_stream { pub sys: pjmedia_vid_dev_stream__bindgen_ty_1, pub op: *mut pjmedia_vid_dev_stream_op }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_vid_dev_stream__bindgen_ty_1 { pub drv_idx: ::std::os::raw::c_uint, pub is_running: pj_bool_t }

extern "C" { pub fn pjmedia_vid_dev_get_local_index(id: pjmedia_vid_dev_index, p_f: *mut *mut pjmedia_vid_dev_factory, p_local_index: *mut ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pjmedia_vid_dev_get_global_index(f: *const pjmedia_vid_dev_factory, local_idx: ::std::os::raw::c_uint, pid: *mut pjmedia_vid_dev_index) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_avi_dev_param { pub path: pj_str_t, pub title: pj_str_t, pub avi_streams: *mut pjmedia_avi_streams }

extern "C" { pub fn pjmedia_avi_dev_param_default(p: *mut pjmedia_avi_dev_param); }

extern "C" { pub fn pjmedia_avi_dev_create_factory(pf: *mut pj_pool_factory, max_dev: ::std::os::raw::c_uint, p_ret: *mut *mut pjmedia_vid_dev_factory) -> pj_status_t; }

extern "C" { pub fn pjmedia_avi_dev_alloc(f: *mut pjmedia_vid_dev_factory, param: *mut pjmedia_avi_dev_param, p_id: *mut pjmedia_vid_dev_index) -> pj_status_t; }

extern "C" { pub fn pjmedia_avi_dev_get_param(id: pjmedia_vid_dev_index, param: *mut pjmedia_avi_dev_param) -> pj_status_t; }

extern "C" { pub fn pjmedia_avi_dev_free(id: pjmedia_vid_dev_index) -> pj_status_t; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsip_inv_state { PJSIP_INV_STATE_NULL = 0, PJSIP_INV_STATE_CALLING = 1, PJSIP_INV_STATE_INCOMING = 2, PJSIP_INV_STATE_EARLY = 3, PJSIP_INV_STATE_CONNECTING = 4, PJSIP_INV_STATE_CONFIRMED = 5, PJSIP_INV_STATE_DISCONNECTED = 6 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_inv_on_rx_offer_cb_param { pub offer: *const pjmedia_sdp_session, pub rdata: *const pjsip_rx_data }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_inv_callback { pub on_state_changed: ::std::option::Option<unsafe extern "C" fn(inv: *mut pjsip_inv_session, e: *mut pjsip_event)>, pub on_new_session: ::std::option::Option<unsafe extern "C" fn(inv: *mut pjsip_inv_session, e: *mut pjsip_event)>, pub on_tsx_state_changed: ::std::option::Option<unsafe extern "C" fn(inv: *mut pjsip_inv_session, tsx: *mut pjsip_transaction, e: *mut pjsip_event)>, pub on_rx_offer: ::std::option::Option<unsafe extern "C" fn(inv: *mut pjsip_inv_session, offer: *const pjmedia_sdp_session)>, pub on_rx_offer2: ::std::option::Option<unsafe extern "C" fn(inv: *mut pjsip_inv_session, param: *mut pjsip_inv_on_rx_offer_cb_param)>, pub on_rx_reinvite: ::std::option::Option<unsafe extern "C" fn(inv: *mut pjsip_inv_session, offer: *const pjmedia_sdp_session, rdata: *mut pjsip_rx_data) -> pj_status_t>, pub on_create_offer: ::std::option::Option<unsafe extern "C" fn(inv: *mut pjsip_inv_session, p_offer: *mut *mut pjmedia_sdp_session)>, pub on_media_update: ::std::option::Option<unsafe extern "C" fn(inv_ses: *mut pjsip_inv_session, status: pj_status_t)>, pub on_send_ack: ::std::option::Option<unsafe extern "C" fn(inv: *mut pjsip_inv_session, rdata: *mut pjsip_rx_data)>, pub on_redirected: ::std::option::Option<unsafe extern "C" fn(inv: *mut pjsip_inv_session, target: *const pjsip_uri, e: *const pjsip_event) -> pjsip_redirect_op> }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsip_inv_option { PJSIP_INV_SUPPORT_100REL = 1, PJSIP_INV_SUPPORT_TIMER = 2, PJSIP_INV_SUPPORT_UPDATE = 4, PJSIP_INV_SUPPORT_ICE = 8, PJSIP_INV_REQUIRE_ICE = 16, PJSIP_INV_REQUIRE_100REL = 32, PJSIP_INV_REQUIRE_TIMER = 64, PJSIP_INV_ALWAYS_USE_TIMER = 128 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_timer { _unused: [u8; 0] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_inv_session { pub obj_name: [::std::os::raw::c_char; 32usize], pub pool: *mut pj_pool_t, pub pool_prov: *mut pj_pool_t, pub pool_active: *mut pj_pool_t, pub state: pjsip_inv_state, pub cancelling: pj_bool_t, pub pending_cancel: pj_bool_t, pub pending_bye: *mut pjsip_tx_data, pub cause: pjsip_status_code, pub cause_text: pj_str_t, pub notify: pj_bool_t, pub cb_called: ::std::os::raw::c_uint, pub dlg: *mut pjsip_dialog, pub role: pjsip_role_e, pub options: ::std::os::raw::c_uint, pub neg: *mut pjmedia_sdp_neg, pub sdp_neg_flags: ::std::os::raw::c_uint, pub invite_tsx: *mut pjsip_transaction, pub invite_req: *mut pjsip_tx_data, pub last_answer: *mut pjsip_tx_data, pub last_ack: *mut pjsip_tx_data, pub last_ack_cseq: pj_int32_t, pub mod_data: [*mut ::std::os::raw::c_void; 32usize], pub timer: *mut pjsip_timer, pub following_fork: pj_bool_t, pub ref_cnt: *mut pj_atomic_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_rdata_sdp_info { pub body: pj_str_t, pub sdp_err: pj_status_t, pub sdp: *mut pjmedia_sdp_session }

extern "C" { pub fn pjsip_inv_usage_init(endpt: *mut pjsip_endpoint, cb: *const pjsip_inv_callback) -> pj_status_t; }

extern "C" { pub fn pjsip_inv_usage_instance() -> *mut pjsip_module; }

extern "C" { pub fn pjsip_inv_usage_dump(); }

extern "C" { pub fn pjsip_inv_create_uac(dlg: *mut pjsip_dialog, local_sdp: *const pjmedia_sdp_session, options: ::std::os::raw::c_uint, p_inv: *mut *mut pjsip_inv_session) -> pj_status_t; }

extern "C" { pub fn pjsip_inv_verify_request(rdata: *mut pjsip_rx_data, options: *mut ::std::os::raw::c_uint, sdp: *const pjmedia_sdp_session, dlg: *mut pjsip_dialog, endpt: *mut pjsip_endpoint, tdata: *mut *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_inv_verify_request2(rdata: *mut pjsip_rx_data, options: *mut ::std::os::raw::c_uint, offer: *const pjmedia_sdp_session, answer: *const pjmedia_sdp_session, dlg: *mut pjsip_dialog, endpt: *mut pjsip_endpoint, tdata: *mut *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_inv_verify_request3(rdata: *mut pjsip_rx_data, tmp_pool: *mut pj_pool_t, options: *mut ::std::os::raw::c_uint, offer: *const pjmedia_sdp_session, answer: *const pjmedia_sdp_session, dlg: *mut pjsip_dialog, endpt: *mut pjsip_endpoint, tdata: *mut *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_inv_create_uas(dlg: *mut pjsip_dialog, rdata: *mut pjsip_rx_data, local_sdp: *const pjmedia_sdp_session, options: ::std::os::raw::c_uint, p_inv: *mut *mut pjsip_inv_session) -> pj_status_t; }

extern "C" { pub fn pjsip_inv_add_ref(inv: *mut pjsip_inv_session) -> pj_status_t; }

extern "C" { pub fn pjsip_inv_dec_ref(inv: *mut pjsip_inv_session) -> pj_status_t; }

extern "C" { pub fn pjsip_inv_terminate(inv: *mut pjsip_inv_session, st_code: ::std::os::raw::c_int, notify: pj_bool_t) -> pj_status_t; }

extern "C" { pub fn pjsip_inv_uac_restart(inv: *mut pjsip_inv_session, new_offer: pj_bool_t) -> pj_status_t; }

extern "C" { pub fn pjsip_inv_process_redirect(inv: *mut pjsip_inv_session, cmd: pjsip_redirect_op, e: *mut pjsip_event) -> pj_status_t; }

extern "C" { pub fn pjsip_inv_invite(inv: *mut pjsip_inv_session, p_tdata: *mut *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_inv_initial_answer(inv: *mut pjsip_inv_session, rdata: *mut pjsip_rx_data, st_code: ::std::os::raw::c_int, st_text: *const pj_str_t, sdp: *const pjmedia_sdp_session, p_tdata: *mut *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_inv_answer(inv: *mut pjsip_inv_session, st_code: ::std::os::raw::c_int, st_text: *const pj_str_t, local_sdp: *const pjmedia_sdp_session, p_tdata: *mut *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_inv_set_local_sdp(inv: *mut pjsip_inv_session, sdp: *const pjmedia_sdp_session) -> pj_status_t; }

extern "C" { pub fn pjsip_inv_set_sdp_answer(inv: *mut pjsip_inv_session, sdp: *const pjmedia_sdp_session) -> pj_status_t; }

extern "C" { pub fn pjsip_inv_end_session(inv: *mut pjsip_inv_session, st_code: ::std::os::raw::c_int, st_text: *const pj_str_t, p_tdata: *mut *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_inv_cancel_reinvite(inv: *mut pjsip_inv_session, p_tdata: *mut *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_inv_reinvite(inv: *mut pjsip_inv_session, new_contact: *const pj_str_t, new_offer: *const pjmedia_sdp_session, p_tdata: *mut *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_inv_update(inv: *mut pjsip_inv_session, new_contact: *const pj_str_t, offer: *const pjmedia_sdp_session, p_tdata: *mut *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_inv_create_ack(inv: *mut pjsip_inv_session, cseq: ::std::os::raw::c_int, p_tdata: *mut *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_inv_send_msg(inv: *mut pjsip_inv_session, tdata: *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_dlg_get_inv_session(dlg: *mut pjsip_dialog) -> *mut pjsip_inv_session; }

extern "C" { pub fn pjsip_tsx_get_inv_session(tsx: *mut pjsip_transaction) -> *mut pjsip_inv_session; }

extern "C" { pub fn pjsip_inv_state_name(state: pjsip_inv_state) -> *const ::std::os::raw::c_char; }

extern "C" { pub fn pjsip_create_sdp_body(pool: *mut pj_pool_t, sdp: *mut pjmedia_sdp_session, p_body: *mut *mut pjsip_msg_body) -> pj_status_t; }

extern "C" { pub fn pjsip_rdata_get_sdp_info(rdata: *mut pjsip_rx_data) -> *mut pjsip_rdata_sdp_info; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_regc { _unused: [u8; 0] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_regc_cbparam { pub regc: *mut pjsip_regc, pub token: *mut ::std::os::raw::c_void, pub status: pj_status_t, pub code: ::std::os::raw::c_int, pub reason: pj_str_t, pub rdata: *mut pjsip_rx_data, pub expiration: ::std::os::raw::c_int, pub contact_cnt: ::std::os::raw::c_int, pub contact: [*mut pjsip_contact_hdr; 10usize], pub is_unreg: pj_bool_t }

pub type pjsip_regc_cb = ::std::option::Option<unsafe extern "C" fn(param: *mut pjsip_regc_cbparam)>;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_regc_tsx_cb_param { pub cbparam: pjsip_regc_cbparam, pub contact_cnt: ::std::os::raw::c_int, pub contact: [pj_str_t; 10usize] }

pub type pjsip_regc_tsx_cb = ::std::option::Option<unsafe extern "C" fn(param: *mut pjsip_regc_tsx_cb_param)>;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_regc_info { pub server_uri: pj_str_t, pub client_uri: pj_str_t, pub is_busy: pj_bool_t, pub auto_reg: pj_bool_t, pub interval: ::std::os::raw::c_int, pub next_reg: ::std::os::raw::c_int, pub transport: *mut pjsip_transport }

extern "C" { pub fn pjsip_regc_get_module() -> *mut pjsip_module; }

extern "C" { pub fn pjsip_regc_create(endpt: *mut pjsip_endpoint, token: *mut ::std::os::raw::c_void, cb: pjsip_regc_cb, p_regc: *mut *mut pjsip_regc) -> pj_status_t; }

extern "C" { pub fn pjsip_regc_destroy(regc: *mut pjsip_regc) -> pj_status_t; }

extern "C" { pub fn pjsip_regc_get_info(regc: *mut pjsip_regc, info: *mut pjsip_regc_info) -> pj_status_t; }

extern "C" { pub fn pjsip_regc_get_pool(regc: *mut pjsip_regc) -> *mut pj_pool_t; }

extern "C" { pub fn pjsip_regc_init(regc: *mut pjsip_regc, srv_url: *const pj_str_t, from_url: *const pj_str_t, to_url: *const pj_str_t, ccnt: ::std::os::raw::c_int, contact: *const pj_str_t, expires: pj_uint32_t) -> pj_status_t; }

extern "C" { pub fn pjsip_regc_set_reg_tsx_cb(regc: *mut pjsip_regc, tsx_cb: pjsip_regc_tsx_cb) -> pj_status_t; }

extern "C" { pub fn pjsip_regc_set_via_sent_by(regc: *mut pjsip_regc, via_addr: *mut pjsip_host_port, via_tp: *mut pjsip_transport) -> pj_status_t; }

extern "C" { pub fn pjsip_regc_set_delay_before_refresh(regc: *mut pjsip_regc, delay: pj_uint32_t) -> pj_status_t; }

extern "C" { pub fn pjsip_regc_set_credentials(regc: *mut pjsip_regc, count: ::std::os::raw::c_int, cred: *const pjsip_cred_info) -> pj_status_t; }

extern "C" { pub fn pjsip_regc_set_prefs(regc: *mut pjsip_regc, pref: *const pjsip_auth_clt_pref) -> pj_status_t; }

extern "C" { pub fn pjsip_regc_set_route_set(regc: *mut pjsip_regc, route_set: *const pjsip_route_hdr) -> pj_status_t; }

extern "C" { pub fn pjsip_regc_set_transport(regc: *mut pjsip_regc, sel: *const pjsip_tpselector) -> pj_status_t; }

extern "C" { pub fn pjsip_regc_release_transport(regc: *mut pjsip_regc) -> pj_status_t; }

extern "C" { pub fn pjsip_regc_add_headers(regc: *mut pjsip_regc, hdr_list: *const pjsip_hdr) -> pj_status_t; }

extern "C" { pub fn pjsip_regc_register(regc: *mut pjsip_regc, autoreg: pj_bool_t, p_tdata: *mut *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_regc_unregister(regc: *mut pjsip_regc, p_tdata: *mut *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_regc_unregister_all(regc: *mut pjsip_regc, p_tdata: *mut *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_regc_update_contact(regc: *mut pjsip_regc, ccnt: ::std::os::raw::c_int, contact: *const pj_str_t) -> pj_status_t; }

extern "C" { pub fn pjsip_regc_update_expires(regc: *mut pjsip_regc, expires: pj_uint32_t) -> pj_status_t; }

extern "C" { pub fn pjsip_regc_send(regc: *mut pjsip_regc, tdata: *mut pjsip_tx_data) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_replaces_hdr { pub prev: *mut pjsip_replaces_hdr, pub next: *mut pjsip_replaces_hdr, pub type_: pjsip_hdr_e, pub name: pj_str_t, pub sname: pj_str_t, pub vptr: *mut pjsip_hdr_vptr, pub call_id: pj_str_t, pub to_tag: pj_str_t, pub from_tag: pj_str_t, pub early_only: pj_bool_t, pub other_param: pjsip_param }

extern "C" { pub fn pjsip_replaces_init_module(endpt: *mut pjsip_endpoint) -> pj_status_t; }

extern "C" { pub fn pjsip_replaces_hdr_create(pool: *mut pj_pool_t) -> *mut pjsip_replaces_hdr; }

extern "C" { pub fn pjsip_replaces_verify_request(rdata: *mut pjsip_rx_data, p_dlg: *mut *mut pjsip_dialog, lock_dlg: pj_bool_t, p_tdata: *mut *mut pjsip_tx_data) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_evsub { _unused: [u8; 0] }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsip_evsub_state { PJSIP_EVSUB_STATE_NULL = 0, PJSIP_EVSUB_STATE_SENT = 1, PJSIP_EVSUB_STATE_ACCEPTED = 2, PJSIP_EVSUB_STATE_PENDING = 3, PJSIP_EVSUB_STATE_ACTIVE = 4, PJSIP_EVSUB_STATE_TERMINATED = 5, PJSIP_EVSUB_STATE_UNKNOWN = 6 }

pub const PJSIP_EVSUB_NO_EVENT_ID: _bindgen_ty_9 = _bindgen_ty_9::PJSIP_EVSUB_NO_EVENT_ID;

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_9 { PJSIP_EVSUB_NO_EVENT_ID = 1 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_evsub_user { pub on_evsub_state: ::std::option::Option<unsafe extern "C" fn(sub: *mut pjsip_evsub, event: *mut pjsip_event)>, pub on_tsx_state: ::std::option::Option<unsafe extern "C" fn(sub: *mut pjsip_evsub, tsx: *mut pjsip_transaction, event: *mut pjsip_event)>, pub on_rx_refresh: ::std::option::Option<unsafe extern "C" fn(sub: *mut pjsip_evsub, rdata: *mut pjsip_rx_data, p_st_code: *mut ::std::os::raw::c_int, p_st_text: *mut *mut pj_str_t, res_hdr: *mut pjsip_hdr, p_body: *mut *mut pjsip_msg_body)>, pub on_rx_notify: ::std::option::Option<unsafe extern "C" fn(sub: *mut pjsip_evsub, rdata: *mut pjsip_rx_data, p_st_code: *mut ::std::os::raw::c_int, p_st_text: *mut *mut pj_str_t, res_hdr: *mut pjsip_hdr, p_body: *mut *mut pjsip_msg_body)>, pub on_client_refresh: ::std::option::Option<unsafe extern "C" fn(sub: *mut pjsip_evsub)>, pub on_server_timeout: ::std::option::Option<unsafe extern "C" fn(sub: *mut pjsip_evsub)> }

extern "C" {
    #[link_name = "\u{1}pjsip_subscribe_method"]
    pub static mut pjsip_subscribe_method: pjsip_method;
}

extern "C" {
    #[link_name = "\u{1}pjsip_notify_method"]
    pub static mut pjsip_notify_method: pjsip_method;
}

extern "C" { pub fn pjsip_get_subscribe_method() -> *const pjsip_method; }

extern "C" { pub fn pjsip_get_notify_method() -> *const pjsip_method; }

extern "C" { pub fn pjsip_evsub_init_module(endpt: *mut pjsip_endpoint) -> pj_status_t; }

extern "C" { pub fn pjsip_evsub_instance() -> *mut pjsip_module; }

extern "C" { pub fn pjsip_evsub_register_pkg(pkg_mod: *mut pjsip_module, event_name: *const pj_str_t, expires: ::std::os::raw::c_uint, accept_cnt: ::std::os::raw::c_uint, accept: *const pj_str_t) -> pj_status_t; }

extern "C" { pub fn pjsip_evsub_get_allow_events_hdr(m: *mut pjsip_module) -> *const pjsip_hdr; }

extern "C" { pub fn pjsip_evsub_create_uac(dlg: *mut pjsip_dialog, user_cb: *const pjsip_evsub_user, event: *const pj_str_t, option: ::std::os::raw::c_uint, p_evsub: *mut *mut pjsip_evsub) -> pj_status_t; }

extern "C" { pub fn pjsip_evsub_create_uas(dlg: *mut pjsip_dialog, user_cb: *const pjsip_evsub_user, rdata: *mut pjsip_rx_data, option: ::std::os::raw::c_uint, p_evsub: *mut *mut pjsip_evsub) -> pj_status_t; }

extern "C" { pub fn pjsip_evsub_terminate(sub: *mut pjsip_evsub, notify: pj_bool_t) -> pj_status_t; }

extern "C" { pub fn pjsip_evsub_get_state(sub: *mut pjsip_evsub) -> pjsip_evsub_state; }

extern "C" { pub fn pjsip_evsub_get_state_name(sub: *mut pjsip_evsub) -> *const ::std::os::raw::c_char; }

extern "C" { pub fn pjsip_evsub_get_termination_reason(sub: *mut pjsip_evsub) -> *const pj_str_t; }

extern "C" { pub fn pjsip_evsub_initiate(sub: *mut pjsip_evsub, method: *const pjsip_method, expires: pj_int32_t, p_tdata: *mut *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_evsub_add_header(sub: *mut pjsip_evsub, hdr_list: *const pjsip_hdr) -> pj_status_t; }

extern "C" { pub fn pjsip_evsub_accept(sub: *mut pjsip_evsub, rdata: *mut pjsip_rx_data, st_code: ::std::os::raw::c_int, hdr_list: *const pjsip_hdr) -> pj_status_t; }

extern "C" { pub fn pjsip_evsub_notify(sub: *mut pjsip_evsub, state: pjsip_evsub_state, state_str: *const pj_str_t, reason: *const pj_str_t, p_tdata: *mut *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_evsub_current_notify(sub: *mut pjsip_evsub, p_tdata: *mut *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_evsub_send_request(sub: *mut pjsip_evsub, tdata: *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_tsx_get_evsub(tsx: *mut pjsip_transaction) -> *mut pjsip_evsub; }

extern "C" { pub fn pjsip_evsub_set_mod_data(sub: *mut pjsip_evsub, mod_id: ::std::os::raw::c_uint, data: *mut ::std::os::raw::c_void); }

extern "C" { pub fn pjsip_evsub_get_mod_data(sub: *mut pjsip_evsub, mod_id: ::std::os::raw::c_uint) -> *mut ::std::os::raw::c_void; }

extern "C" { pub fn pjsip_evsub_add_ref(sub: *mut pjsip_evsub) -> pj_status_t; }

extern "C" { pub fn pjsip_evsub_dec_ref(sub: *mut pjsip_evsub) -> pj_status_t; }

extern "C" { pub fn pjsip_evsub_uas_set_timeout(sub: *mut pjsip_evsub, seconds: pj_uint32_t); }

extern "C" {
    #[link_name = "\u{1}pjsip_refer_method"]
    pub static mut pjsip_refer_method: pjsip_method;
}

extern "C" { pub fn pjsip_get_refer_method() -> *const pjsip_method; }

extern "C" { pub fn pjsip_xfer_init_module(endpt: *mut pjsip_endpoint) -> pj_status_t; }

extern "C" { pub fn pjsip_xfer_create_uac(dlg: *mut pjsip_dialog, user_cb: *const pjsip_evsub_user, p_evsub: *mut *mut pjsip_evsub) -> pj_status_t; }

extern "C" { pub fn pjsip_xfer_create_uas(dlg: *mut pjsip_dialog, user_cb: *const pjsip_evsub_user, rdata: *mut pjsip_rx_data, p_evsub: *mut *mut pjsip_evsub) -> pj_status_t; }

extern "C" { pub fn pjsip_xfer_initiate(sub: *mut pjsip_evsub, refer_to_uri: *const pj_str_t, p_tdata: *mut *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_xfer_accept(sub: *mut pjsip_evsub, rdata: *mut pjsip_rx_data, st_code: ::std::os::raw::c_int, hdr_list: *const pjsip_hdr) -> pj_status_t; }

extern "C" { pub fn pjsip_xfer_notify(sub: *mut pjsip_evsub, state: pjsip_evsub_state, xfer_st_code: ::std::os::raw::c_int, xfer_st_text: *const pj_str_t, p_tdata: *mut *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_xfer_current_notify(sub: *mut pjsip_evsub, p_tdata: *mut *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_xfer_send_request(sub: *mut pjsip_evsub, tdata: *mut pjsip_tx_data) -> pj_status_t; }

extern "C" {
    #[link_name = "\u{1}pjsip_prack_method"]
    pub static mut pjsip_prack_method: pjsip_method;
}

extern "C" { pub fn pjsip_get_prack_method() -> *const pjsip_method; }

extern "C" { pub fn pjsip_100rel_init_module(endpt: *mut pjsip_endpoint) -> pj_status_t; }

extern "C" { pub fn pjsip_100rel_attach(inv: *mut pjsip_inv_session) -> pj_status_t; }

extern "C" { pub fn pjsip_100rel_is_reliable(rdata: *mut pjsip_rx_data) -> pj_bool_t; }

extern "C" { pub fn pjsip_100rel_create_prack(inv: *mut pjsip_inv_session, rdata: *mut pjsip_rx_data, p_tdata: *mut *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_100rel_send_prack(inv: *mut pjsip_inv_session, tdata: *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_100rel_on_rx_prack(inv: *mut pjsip_inv_session, rdata: *mut pjsip_rx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_100rel_tx_response(inv: *mut pjsip_inv_session, tdata: *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_100rel_end_session(inv: *mut pjsip_inv_session) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_timer_setting { pub min_se: ::std::os::raw::c_uint, pub sess_expires: ::std::os::raw::c_uint }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_sess_expires_hdr { pub prev: *mut pjsip_sess_expires_hdr, pub next: *mut pjsip_sess_expires_hdr, pub type_: pjsip_hdr_e, pub name: pj_str_t, pub sname: pj_str_t, pub vptr: *mut pjsip_hdr_vptr, pub sess_expires: ::std::os::raw::c_uint, pub refresher: pj_str_t, pub other_param: pjsip_param }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_min_se_hdr { pub prev: *mut pjsip_min_se_hdr, pub next: *mut pjsip_min_se_hdr, pub type_: pjsip_hdr_e, pub name: pj_str_t, pub sname: pj_str_t, pub vptr: *mut pjsip_hdr_vptr, pub min_se: ::std::os::raw::c_uint, pub other_param: pjsip_param }

extern "C" { pub fn pjsip_timer_init_module(endpt: *mut pjsip_endpoint) -> pj_status_t; }

extern "C" { pub fn pjsip_timer_setting_default(setting: *mut pjsip_timer_setting) -> pj_status_t; }

extern "C" { pub fn pjsip_timer_init_session(inv: *mut pjsip_inv_session, setting: *const pjsip_timer_setting) -> pj_status_t; }

extern "C" { pub fn pjsip_sess_expires_hdr_create(pool: *mut pj_pool_t) -> *mut pjsip_sess_expires_hdr; }

extern "C" { pub fn pjsip_min_se_hdr_create(pool: *mut pj_pool_t) -> *mut pjsip_min_se_hdr; }

extern "C" { pub fn pjsip_timer_update_req(inv: *mut pjsip_inv_session, tdata: *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_timer_process_resp(inv: *mut pjsip_inv_session, rdata: *const pjsip_rx_data, st_code: *mut pjsip_status_code) -> pj_status_t; }

extern "C" { pub fn pjsip_timer_handle_refresh_error(inv: *mut pjsip_inv_session, event: *mut pjsip_event) -> pj_status_t; }

extern "C" { pub fn pjsip_timer_process_req(inv: *mut pjsip_inv_session, rdata: *const pjsip_rx_data, st_code: *mut pjsip_status_code) -> pj_status_t; }

extern "C" { pub fn pjsip_timer_update_resp(inv: *mut pjsip_inv_session, tdata: *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_timer_end_session(inv: *mut pjsip_inv_session) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_event_hdr { pub prev: *mut pjsip_event_hdr, pub next: *mut pjsip_event_hdr, pub type_: pjsip_hdr_e, pub name: pj_str_t, pub sname: pj_str_t, pub vptr: *mut pjsip_hdr_vptr, pub event_type: pj_str_t, pub id_param: pj_str_t, pub other_param: pjsip_param }

extern "C" { pub fn pjsip_event_hdr_create(pool: *mut pj_pool_t) -> *mut pjsip_event_hdr; }

pub type pjsip_allow_events_hdr = pjsip_generic_array_hdr;

extern "C" { pub fn pjsip_allow_events_hdr_create(pool: *mut pj_pool_t) -> *mut pjsip_allow_events_hdr; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_sub_state_hdr { pub prev: *mut pjsip_sub_state_hdr, pub next: *mut pjsip_sub_state_hdr, pub type_: pjsip_hdr_e, pub name: pj_str_t, pub sname: pj_str_t, pub vptr: *mut pjsip_hdr_vptr, pub sub_state: pj_str_t, pub reason_param: pj_str_t, pub expires_param: ::std::os::raw::c_int, pub retry_after: ::std::os::raw::c_int, pub other_param: pjsip_param }

extern "C" { pub fn pjsip_sub_state_hdr_create(pool: *mut pj_pool_t) -> *mut pjsip_sub_state_hdr; }

extern "C" { pub fn pjsip_evsub_init_parser(); }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_xml_attr { pub prev: *mut pj_xml_attr, pub next: *mut pj_xml_attr, pub name: pj_str_t, pub value: pj_str_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_xml_node_head { pub prev: *mut pj_xml_node, pub next: *mut pj_xml_node }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_xml_node { pub prev: *mut pj_xml_node, pub next: *mut pj_xml_node, pub name: pj_str_t, pub attr_head: pj_xml_attr, pub node_head: pj_xml_node_head, pub content: pj_str_t }

extern "C" { pub fn pj_xml_parse(pool: *mut pj_pool_t, msg: *mut ::std::os::raw::c_char, len: pj_size_t) -> *mut pj_xml_node; }

extern "C" { pub fn pj_xml_print(node: *const pj_xml_node, buf: *mut ::std::os::raw::c_char, len: pj_size_t, prolog: pj_bool_t) -> ::std::os::raw::c_int; }

extern "C" { pub fn pj_xml_clone(pool: *mut pj_pool_t, rhs: *const pj_xml_node) -> *mut pj_xml_node; }

extern "C" { pub fn pj_xml_node_new(pool: *mut pj_pool_t, name: *const pj_str_t) -> *mut pj_xml_node; }

extern "C" { pub fn pj_xml_attr_new(pool: *mut pj_pool_t, name: *const pj_str_t, value: *const pj_str_t) -> *mut pj_xml_attr; }

extern "C" { pub fn pj_xml_add_node(parent: *mut pj_xml_node, node: *mut pj_xml_node); }

extern "C" { pub fn pj_xml_add_attr(node: *mut pj_xml_node, attr: *mut pj_xml_attr); }

extern "C" { pub fn pj_xml_find_node(parent: *const pj_xml_node, name: *const pj_str_t) -> *mut pj_xml_node; }

extern "C" { pub fn pj_xml_find_next_node(parent: *const pj_xml_node, node: *const pj_xml_node, name: *const pj_str_t) -> *mut pj_xml_node; }

extern "C" { pub fn pj_xml_find_node_rec(parent: *const pj_xml_node, name: *const pj_str_t) -> *mut pj_xml_node; }

extern "C" { pub fn pj_xml_find_attr(node: *const pj_xml_node, name: *const pj_str_t, value: *const pj_str_t) -> *mut pj_xml_attr; }

extern "C" { pub fn pj_xml_find(parent: *const pj_xml_node, name: *const pj_str_t, data: *const ::std::os::raw::c_void, match_: ::std::option::Option<unsafe extern "C" fn(arg1: *const pj_xml_node, arg2: *const ::std::os::raw::c_void) -> pj_bool_t>) -> *mut pj_xml_node; }

extern "C" { pub fn pj_xml_find_rec(parent: *const pj_xml_node, name: *const pj_str_t, data: *const ::std::os::raw::c_void, match_: ::std::option::Option<unsafe extern "C" fn(arg1: *const pj_xml_node, arg2: *const ::std::os::raw::c_void) -> pj_bool_t>) -> *mut pj_xml_node; }

extern "C" { pub fn pjsip_iscomposing_create_xml(pool: *mut pj_pool_t, is_composing: pj_bool_t, lst_actv: *const pj_time_val, content_tp: *const pj_str_t, refresh: ::std::os::raw::c_int) -> *mut pj_xml_node; }

extern "C" { pub fn pjsip_iscomposing_create_body(pool: *mut pj_pool_t, is_composing: pj_bool_t, lst_actv: *const pj_time_val, content_tp: *const pj_str_t, refresh: ::std::os::raw::c_int) -> *mut pjsip_msg_body; }

extern "C" { pub fn pjsip_iscomposing_parse(pool: *mut pj_pool_t, msg: *mut ::std::os::raw::c_char, len: pj_size_t, p_is_composing: *mut pj_bool_t, p_last_active: *mut *mut pj_str_t, p_content_type: *mut *mut pj_str_t, p_refresh: *mut ::std::os::raw::c_int) -> pj_status_t; }

extern "C" { pub fn pjsip_mwi_init_module(endpt: *mut pjsip_endpoint, mod_evsub: *mut pjsip_module) -> pj_status_t; }

extern "C" { pub fn pjsip_mwi_instance() -> *mut pjsip_module; }

extern "C" { pub fn pjsip_mwi_create_uac(dlg: *mut pjsip_dialog, user_cb: *const pjsip_evsub_user, options: ::std::os::raw::c_uint, p_evsub: *mut *mut pjsip_evsub) -> pj_status_t; }

extern "C" { pub fn pjsip_mwi_create_uas(dlg: *mut pjsip_dialog, user_cb: *const pjsip_evsub_user, rdata: *mut pjsip_rx_data, p_evsub: *mut *mut pjsip_evsub) -> pj_status_t; }

extern "C" { pub fn pjsip_mwi_terminate(sub: *mut pjsip_evsub, notify: pj_bool_t) -> pj_status_t; }

extern "C" { pub fn pjsip_mwi_initiate(sub: *mut pjsip_evsub, expires: pj_int32_t, p_tdata: *mut *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_mwi_accept(sub: *mut pjsip_evsub, rdata: *mut pjsip_rx_data, st_code: ::std::os::raw::c_int, hdr_list: *const pjsip_hdr) -> pj_status_t; }

extern "C" { pub fn pjsip_mwi_notify(sub: *mut pjsip_evsub, state: pjsip_evsub_state, state_str: *const pj_str_t, reason: *const pj_str_t, mime_type: *const pjsip_media_type, body: *const pj_str_t, p_tdata: *mut *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_mwi_current_notify(sub: *mut pjsip_evsub, p_tdata: *mut *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_mwi_send_request(sub: *mut pjsip_evsub, tdata: *mut pjsip_tx_data) -> pj_status_t; }

pub type pjpidf_pres = pj_xml_node;
pub type pjpidf_tuple = pj_xml_node;
pub type pjpidf_status = pj_xml_node;
pub type pjpidf_note = pj_xml_node;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjpidf_status_op { pub construct: ::std::option::Option<unsafe extern "C" fn(arg1: *mut pj_pool_t, arg2: *mut pjpidf_status)>, pub is_basic_open: ::std::option::Option<unsafe extern "C" fn(arg1: *const pjpidf_status) -> pj_bool_t>, pub set_basic_open: ::std::option::Option<unsafe extern "C" fn(arg1: *mut pjpidf_status, arg2: pj_bool_t)> }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjpidf_tuple_op { pub construct: ::std::option::Option<unsafe extern "C" fn(arg1: *mut pj_pool_t, arg2: *mut pjpidf_tuple, arg3: *const pj_str_t)>, pub get_id: ::std::option::Option<unsafe extern "C" fn(arg1: *const pjpidf_tuple) -> *const pj_str_t>, pub set_id: ::std::option::Option<unsafe extern "C" fn(arg1: *mut pj_pool_t, arg2: *mut pjpidf_tuple, arg3: *const pj_str_t)>, pub get_status: ::std::option::Option<unsafe extern "C" fn(arg1: *mut pjpidf_tuple) -> *mut pjpidf_status>, pub get_contact: ::std::option::Option<unsafe extern "C" fn(arg1: *const pjpidf_tuple) -> *const pj_str_t>, pub set_contact: ::std::option::Option<unsafe extern "C" fn(arg1: *mut pj_pool_t, arg2: *mut pjpidf_tuple, arg3: *const pj_str_t)>, pub set_contact_prio: ::std::option::Option<unsafe extern "C" fn(arg1: *mut pj_pool_t, arg2: *mut pjpidf_tuple, arg3: *const pj_str_t)>, pub get_contact_prio: ::std::option::Option<unsafe extern "C" fn(arg1: *const pjpidf_tuple) -> *const pj_str_t>, pub add_note: ::std::option::Option<unsafe extern "C" fn(arg1: *mut pj_pool_t, arg2: *mut pjpidf_tuple, arg3: *const pj_str_t) -> *mut pjpidf_note>, pub get_first_note: ::std::option::Option<unsafe extern "C" fn(arg1: *mut pjpidf_tuple) -> *mut pjpidf_note>, pub get_next_note: ::std::option::Option<unsafe extern "C" fn(arg1: *mut pjpidf_tuple, arg2: *mut pjpidf_note) -> *mut pjpidf_note>, pub get_timestamp: ::std::option::Option<unsafe extern "C" fn(arg1: *const pjpidf_tuple) -> *const pj_str_t>, pub set_timestamp: ::std::option::Option<unsafe extern "C" fn(arg1: *mut pj_pool_t, arg2: *mut pjpidf_tuple, arg3: *const pj_str_t)>, pub set_timestamp_np: ::std::option::Option<unsafe extern "C" fn(arg1: *mut pj_pool_t, arg2: *mut pjpidf_tuple, arg3: *mut pj_str_t)> }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjpidf_pres_op { pub construct: ::std::option::Option<unsafe extern "C" fn(arg1: *mut pj_pool_t, arg2: *mut pjpidf_pres, arg3: *const pj_str_t)>, pub add_tuple: ::std::option::Option<unsafe extern "C" fn(arg1: *mut pj_pool_t, arg2: *mut pjpidf_pres, arg3: *const pj_str_t) -> *mut pjpidf_tuple>, pub get_first_tuple: ::std::option::Option<unsafe extern "C" fn(arg1: *mut pjpidf_pres) -> *mut pjpidf_tuple>, pub get_next_tuple: ::std::option::Option<unsafe extern "C" fn(arg1: *mut pjpidf_pres, arg2: *mut pjpidf_tuple) -> *mut pjpidf_tuple>, pub find_tuple: ::std::option::Option<unsafe extern "C" fn(arg1: *mut pjpidf_pres, arg2: *const pj_str_t) -> *mut pjpidf_tuple>, pub remove_tuple: ::std::option::Option<unsafe extern "C" fn(arg1: *mut pjpidf_pres, arg2: *mut pjpidf_tuple)>, pub add_note: ::std::option::Option<unsafe extern "C" fn(arg1: *mut pj_pool_t, arg2: *mut pjpidf_pres, arg3: *const pj_str_t) -> *mut pjpidf_note>, pub get_first_note: ::std::option::Option<unsafe extern "C" fn(arg1: *mut pjpidf_pres) -> *mut pjpidf_note>, pub get_next_note: ::std::option::Option<unsafe extern "C" fn(arg1: *mut pjpidf_pres, arg2: *mut pjpidf_note) -> *mut pjpidf_note> }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjpidf_op_desc { pub pres: pjpidf_pres_op, pub tuple: pjpidf_tuple_op, pub status: pjpidf_status_op }

extern "C" {
    #[link_name = "\u{1}pjpidf_op"]
    pub static mut pjpidf_op: pjpidf_op_desc;
}

extern "C" { pub fn pjpidf_create(pool: *mut pj_pool_t, entity: *const pj_str_t) -> *mut pjpidf_pres; }

extern "C" { pub fn pjpidf_parse(pool: *mut pj_pool_t, text: *mut ::std::os::raw::c_char, len: ::std::os::raw::c_int) -> *mut pjpidf_pres; }

extern "C" { pub fn pjpidf_print(pres: *const pjpidf_pres, buf: *mut ::std::os::raw::c_char, len: ::std::os::raw::c_int) -> ::std::os::raw::c_int; }

extern "C" { pub fn pjpidf_pres_construct(pool: *mut pj_pool_t, pres: *mut pjpidf_pres, entity: *const pj_str_t); }

extern "C" { pub fn pjpidf_pres_add_tuple(pool: *mut pj_pool_t, pres: *mut pjpidf_pres, id: *const pj_str_t) -> *mut pjpidf_tuple; }

extern "C" { pub fn pjpidf_pres_get_first_tuple(pres: *mut pjpidf_pres) -> *mut pjpidf_tuple; }

extern "C" { pub fn pjpidf_pres_get_next_tuple(pres: *mut pjpidf_pres, t: *mut pjpidf_tuple) -> *mut pjpidf_tuple; }

extern "C" { pub fn pjpidf_pres_find_tuple(pres: *mut pjpidf_pres, id: *const pj_str_t) -> *mut pjpidf_tuple; }

extern "C" { pub fn pjpidf_pres_remove_tuple(pres: *mut pjpidf_pres, arg1: *mut pjpidf_tuple); }

extern "C" { pub fn pjpidf_pres_add_note(pool: *mut pj_pool_t, pres: *mut pjpidf_pres, text: *const pj_str_t) -> *mut pjpidf_note; }

extern "C" { pub fn pjpidf_pres_get_first_note(pres: *mut pjpidf_pres) -> *mut pjpidf_note; }

extern "C" { pub fn pjpidf_pres_get_next_note(arg1: *mut pjpidf_pres, arg2: *mut pjpidf_note) -> *mut pjpidf_note; }

extern "C" { pub fn pjpidf_tuple_construct(pool: *mut pj_pool_t, t: *mut pjpidf_tuple, id: *const pj_str_t); }

extern "C" { pub fn pjpidf_tuple_get_id(t: *const pjpidf_tuple) -> *const pj_str_t; }

extern "C" { pub fn pjpidf_tuple_set_id(pool: *mut pj_pool_t, t: *mut pjpidf_tuple, id: *const pj_str_t); }

extern "C" { pub fn pjpidf_tuple_get_status(t: *mut pjpidf_tuple) -> *mut pjpidf_status; }

extern "C" { pub fn pjpidf_tuple_get_contact(t: *const pjpidf_tuple) -> *const pj_str_t; }

extern "C" { pub fn pjpidf_tuple_set_contact(pool: *mut pj_pool_t, t: *mut pjpidf_tuple, contact: *const pj_str_t); }

extern "C" { pub fn pjpidf_tuple_set_contact_prio(pool: *mut pj_pool_t, t: *mut pjpidf_tuple, prio: *const pj_str_t); }

extern "C" { pub fn pjpidf_tuple_get_contact_prio(t: *const pjpidf_tuple) -> *const pj_str_t; }

extern "C" { pub fn pjpidf_tuple_add_note(pool: *mut pj_pool_t, t: *mut pjpidf_tuple, text: *const pj_str_t) -> *mut pjpidf_note; }

extern "C" { pub fn pjpidf_tuple_get_first_note(t: *mut pjpidf_tuple) -> *mut pjpidf_note; }

extern "C" { pub fn pjpidf_tuple_get_next_note(t: *mut pjpidf_tuple, n: *mut pjpidf_note) -> *mut pjpidf_note; }

extern "C" { pub fn pjpidf_tuple_get_timestamp(t: *const pjpidf_tuple) -> *const pj_str_t; }

extern "C" { pub fn pjpidf_tuple_set_timestamp(pool: *mut pj_pool_t, t: *mut pjpidf_tuple, ts: *const pj_str_t); }

extern "C" { pub fn pjpidf_tuple_set_timestamp_np(arg1: *mut pj_pool_t, t: *mut pjpidf_tuple, ts: *mut pj_str_t); }

extern "C" { pub fn pjpidf_status_construct(arg1: *mut pj_pool_t, arg2: *mut pjpidf_status); }

extern "C" { pub fn pjpidf_status_is_basic_open(arg1: *const pjpidf_status) -> pj_bool_t; }

extern "C" { pub fn pjpidf_status_set_basic_open(arg1: *mut pjpidf_status, arg2: pj_bool_t); }

pub type pjxpidf_pres = pj_xml_node;

extern "C" { pub fn pjxpidf_create(pool: *mut pj_pool_t, uri: *const pj_str_t) -> *mut pjxpidf_pres; }

extern "C" { pub fn pjxpidf_parse(pool: *mut pj_pool_t, text: *mut ::std::os::raw::c_char, len: pj_size_t) -> *mut pjxpidf_pres; }

extern "C" { pub fn pjxpidf_print(pres: *mut pjxpidf_pres, text: *mut ::std::os::raw::c_char, len: pj_size_t) -> ::std::os::raw::c_int; }

extern "C" { pub fn pjxpidf_get_uri(pres: *mut pjxpidf_pres) -> *mut pj_str_t; }

extern "C" { pub fn pjxpidf_set_uri(pool: *mut pj_pool_t, pres: *mut pjxpidf_pres, uri: *const pj_str_t) -> pj_status_t; }

extern "C" { pub fn pjxpidf_get_status(pres: *mut pjxpidf_pres) -> pj_bool_t; }

extern "C" { pub fn pjxpidf_set_status(pres: *mut pjxpidf_pres, status: pj_bool_t) -> pj_status_t; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjrpid_activity { PJRPID_ACTIVITY_UNKNOWN = 0, PJRPID_ACTIVITY_AWAY = 1, PJRPID_ACTIVITY_BUSY = 2 }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjrpid_element_type { PJRPID_ELEMENT_TYPE_PERSON = 0 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjrpid_element { pub type_: pjrpid_element_type, pub id: pj_str_t, pub activity: pjrpid_activity, pub note: pj_str_t }

extern "C" { pub fn pjrpid_element_dup(pool: *mut pj_pool_t, dst: *mut pjrpid_element, src: *const pjrpid_element); }

extern "C" { pub fn pjrpid_add_element(pres: *mut pjpidf_pres, pool: *mut pj_pool_t, options: ::std::os::raw::c_uint, elem: *const pjrpid_element) -> pj_status_t; }

extern "C" { pub fn pjrpid_get_element(pres: *const pjpidf_pres, pool: *mut pj_pool_t, elem: *mut pjrpid_element) -> pj_status_t; }

extern "C" { pub fn pjsip_pres_init_module(endpt: *mut pjsip_endpoint, mod_evsub: *mut pjsip_module) -> pj_status_t; }

extern "C" { pub fn pjsip_pres_instance() -> *mut pjsip_module; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_pres_status { pub info_cnt: ::std::os::raw::c_uint, pub info: [pjsip_pres_status__bindgen_ty_1; 8usize], pub _is_valid: pj_bool_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_pres_status__bindgen_ty_1 { pub basic_open: pj_bool_t, pub rpid: pjrpid_element, pub id: pj_str_t, pub contact: pj_str_t, pub tuple_node: *mut pj_xml_node }

extern "C" { pub fn pjsip_pres_create_uac(dlg: *mut pjsip_dialog, user_cb: *const pjsip_evsub_user, options: ::std::os::raw::c_uint, p_evsub: *mut *mut pjsip_evsub) -> pj_status_t; }

extern "C" { pub fn pjsip_pres_create_uas(dlg: *mut pjsip_dialog, user_cb: *const pjsip_evsub_user, rdata: *mut pjsip_rx_data, p_evsub: *mut *mut pjsip_evsub) -> pj_status_t; }

extern "C" { pub fn pjsip_pres_terminate(sub: *mut pjsip_evsub, notify: pj_bool_t) -> pj_status_t; }

extern "C" { pub fn pjsip_pres_initiate(sub: *mut pjsip_evsub, expires: pj_int32_t, p_tdata: *mut *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_pres_add_header(sub: *mut pjsip_evsub, hdr_list: *const pjsip_hdr) -> pj_status_t; }

extern "C" { pub fn pjsip_pres_accept(sub: *mut pjsip_evsub, rdata: *mut pjsip_rx_data, st_code: ::std::os::raw::c_int, hdr_list: *const pjsip_hdr) -> pj_status_t; }

extern "C" { pub fn pjsip_pres_notify(sub: *mut pjsip_evsub, state: pjsip_evsub_state, state_str: *const pj_str_t, reason: *const pj_str_t, p_tdata: *mut *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_pres_current_notify(sub: *mut pjsip_evsub, p_tdata: *mut *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_pres_send_request(sub: *mut pjsip_evsub, tdata: *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_pres_get_status(sub: *mut pjsip_evsub, status: *mut pjsip_pres_status) -> pj_status_t; }

extern "C" { pub fn pjsip_pres_set_status(sub: *mut pjsip_evsub, status: *const pjsip_pres_status) -> pj_status_t; }

extern "C" { pub fn pjsip_pres_create_pidf(pool: *mut pj_pool_t, status: *const pjsip_pres_status, entity: *const pj_str_t, p_body: *mut *mut pjsip_msg_body) -> pj_status_t; }

extern "C" { pub fn pjsip_pres_create_xpidf(pool: *mut pj_pool_t, status: *const pjsip_pres_status, entity: *const pj_str_t, p_body: *mut *mut pjsip_msg_body) -> pj_status_t; }

extern "C" { pub fn pjsip_pres_parse_pidf(rdata: *mut pjsip_rx_data, pool: *mut pj_pool_t, status: *mut pjsip_pres_status) -> pj_status_t; }

extern "C" { pub fn pjsip_pres_parse_pidf2(body: *mut ::std::os::raw::c_char, body_len: ::std::os::raw::c_uint, pool: *mut pj_pool_t, status: *mut pjsip_pres_status) -> pj_status_t; }

extern "C" { pub fn pjsip_pres_parse_xpidf(rdata: *mut pjsip_rx_data, pool: *mut pj_pool_t, status: *mut pjsip_pres_status) -> pj_status_t; }

extern "C" { pub fn pjsip_pres_parse_xpidf2(body: *mut ::std::os::raw::c_char, body_len: ::std::os::raw::c_uint, pool: *mut pj_pool_t, status: *mut pjsip_pres_status) -> pj_status_t; }

extern "C" {
    #[link_name = "\u{1}pjsip_publish_method"]
    pub static mut pjsip_publish_method: pjsip_method;
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_publishc { _unused: [u8; 0] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_publishc_opt { pub queue_request: pj_bool_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsip_publishc_cbparam { pub pubc: *mut pjsip_publishc, pub token: *mut ::std::os::raw::c_void, pub status: pj_status_t, pub code: ::std::os::raw::c_int, pub reason: pj_str_t, pub rdata: *mut pjsip_rx_data, pub expiration: ::std::os::raw::c_int }

pub type pjsip_publishc_cb = ::std::option::Option<unsafe extern "C" fn(param: *mut pjsip_publishc_cbparam)>;

extern "C" { pub fn pjsip_publishc_opt_default(opt: *mut pjsip_publishc_opt); }

extern "C" { pub fn pjsip_publishc_init_module(endpt: *mut pjsip_endpoint) -> pj_status_t; }

extern "C" { pub fn pjsip_publishc_create(endpt: *mut pjsip_endpoint, opt: *const pjsip_publishc_opt, token: *mut ::std::os::raw::c_void, cb: pjsip_publishc_cb, p_pubc: *mut *mut pjsip_publishc) -> pj_status_t; }

extern "C" { pub fn pjsip_publishc_destroy(pubc: *mut pjsip_publishc) -> pj_status_t; }

extern "C" { pub fn pjsip_publishc_get_pool(pubc: *mut pjsip_publishc) -> *mut pj_pool_t; }

extern "C" { pub fn pjsip_publishc_init(pubc: *mut pjsip_publishc, event: *const pj_str_t, target_uri: *const pj_str_t, from_uri: *const pj_str_t, to_uri: *const pj_str_t, expires: pj_uint32_t) -> pj_status_t; }

extern "C" { pub fn pjsip_publishc_set_credentials(pubc: *mut pjsip_publishc, count: ::std::os::raw::c_int, c: *const pjsip_cred_info) -> pj_status_t; }

extern "C" { pub fn pjsip_publishc_set_route_set(pubc: *mut pjsip_publishc, rs: *const pjsip_route_hdr) -> pj_status_t; }

extern "C" { pub fn pjsip_publishc_set_headers(pubc: *mut pjsip_publishc, hdr_list: *const pjsip_hdr) -> pj_status_t; }

extern "C" { pub fn pjsip_publishc_set_via_sent_by(pubc: *mut pjsip_publishc, via_addr: *mut pjsip_host_port, via_tp: *mut pjsip_transport) -> pj_status_t; }

extern "C" { pub fn pjsip_publishc_publish(pubc: *mut pjsip_publishc, auto_refresh: pj_bool_t, p_tdata: *mut *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_publishc_unpublish(pubc: *mut pjsip_publishc, p_tdata: *mut *mut pjsip_tx_data) -> pj_status_t; }

extern "C" { pub fn pjsip_publishc_update_expires(pubc: *mut pjsip_publishc, expires: pj_uint32_t) -> pj_status_t; }

extern "C" { pub fn pjsip_publishc_send(pubc: *mut pjsip_publishc, tdata: *mut pjsip_tx_data) -> pj_status_t; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_stun_nat_type { PJ_STUN_NAT_TYPE_UNKNOWN = 0, PJ_STUN_NAT_TYPE_ERR_UNKNOWN = 1, PJ_STUN_NAT_TYPE_OPEN = 2, PJ_STUN_NAT_TYPE_BLOCKED = 3, PJ_STUN_NAT_TYPE_SYMMETRIC_UDP = 4, PJ_STUN_NAT_TYPE_FULL_CONE = 5, PJ_STUN_NAT_TYPE_SYMMETRIC = 6, PJ_STUN_NAT_TYPE_RESTRICTED = 7, PJ_STUN_NAT_TYPE_PORT_RESTRICTED = 8 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_stun_nat_detect_result { pub status: pj_status_t, pub status_text: *const ::std::os::raw::c_char, pub nat_type: pj_stun_nat_type, pub nat_type_name: *const ::std::os::raw::c_char }

pub type pj_stun_nat_detect_cb = ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, res: *const pj_stun_nat_detect_result)>;

extern "C" { pub fn pj_stun_get_nat_name(type_: pj_stun_nat_type) -> *const ::std::os::raw::c_char; }

extern "C" { pub fn pj_stun_detect_nat_type(server: *const pj_sockaddr_in, stun_cfg: *mut pj_stun_config, user_data: *mut ::std::os::raw::c_void, cb: pj_stun_nat_detect_cb) -> pj_status_t; }

extern "C" { pub fn pj_stun_detect_nat_type2(server: *const pj_sockaddr, stun_cfg: *mut pj_stun_config, user_data: *mut ::std::os::raw::c_void, cb: pj_stun_nat_detect_cb) -> pj_status_t; }

extern "C" {
    #[link_name = "\u{1}pj_optarg"]
    pub static mut pj_optarg: *mut ::std::os::raw::c_char;
}

extern "C" {
    #[link_name = "\u{1}pj_optind"]
    pub static mut pj_optind: ::std::os::raw::c_int;
}

extern "C" {
    #[link_name = "\u{1}pj_optopt"]
    pub static mut pj_optopt: ::std::os::raw::c_int;
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_getopt_option { pub name: *const ::std::os::raw::c_char, pub has_arg: ::std::os::raw::c_int, pub flag: *mut ::std::os::raw::c_int, pub val: ::std::os::raw::c_int }

extern "C" { pub fn pj_getopt(argc: ::std::os::raw::c_int, argv: *const *mut ::std::os::raw::c_char, shortopts: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int; }

extern "C" { pub fn pj_getopt_long(argc: ::std::os::raw::c_int, argv: *const *mut ::std::os::raw::c_char, options: *const ::std::os::raw::c_char, longopts: *const pj_getopt_option, longind: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int; }

extern "C" { pub fn pj_getopt_long_only(argc: ::std::os::raw::c_int, argv: *const *mut ::std::os::raw::c_char, shortopts: *const ::std::os::raw::c_char, longopts: *const pj_getopt_option, longind: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int; }

extern "C" { pub fn pj_base64_encode(input: *const pj_uint8_t, in_len: ::std::os::raw::c_int, output: *mut ::std::os::raw::c_char, out_len: *mut ::std::os::raw::c_int) -> pj_status_t; }

extern "C" { pub fn pj_base64_decode(input: *const pj_str_t, out: *mut pj_uint8_t, out_len: *mut ::std::os::raw::c_int) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_crc32_context { pub crc_state: pj_uint32_t }

extern "C" { pub fn pj_crc32_init(ctx: *mut pj_crc32_context); }

extern "C" { pub fn pj_crc32_update(ctx: *mut pj_crc32_context, data: *const pj_uint8_t, nbytes: pj_size_t) -> pj_uint32_t; }

extern "C" { pub fn pj_crc32_final(ctx: *mut pj_crc32_context) -> pj_uint32_t; }

extern "C" { pub fn pj_crc32_calc(data: *const pj_uint8_t, nbytes: pj_size_t) -> pj_uint32_t; }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pj_md5_context { pub buf: [pj_uint32_t; 4usize], pub bits: [pj_uint32_t; 2usize], pub in_: [pj_uint8_t; 64usize] }

extern "C" { pub fn pj_md5_init(pms: *mut pj_md5_context); }

extern "C" { pub fn pj_md5_update(pms: *mut pj_md5_context, data: *const pj_uint8_t, nbytes: ::std::os::raw::c_uint); }

extern "C" { pub fn pj_md5_final(pms: *mut pj_md5_context, digest: *mut pj_uint8_t); }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pj_hmac_md5_context { pub context: pj_md5_context, pub k_opad: [pj_uint8_t; 64usize] }

extern "C" { pub fn pj_hmac_md5(input: *const pj_uint8_t, input_len: ::std::os::raw::c_uint, key: *const pj_uint8_t, key_len: ::std::os::raw::c_uint, digest: *mut pj_uint8_t); }

extern "C" { pub fn pj_hmac_md5_init(hctx: *mut pj_hmac_md5_context, key: *const pj_uint8_t, key_len: ::std::os::raw::c_uint); }

extern "C" { pub fn pj_hmac_md5_update(hctx: *mut pj_hmac_md5_context, input: *const pj_uint8_t, input_len: ::std::os::raw::c_uint); }

extern "C" { pub fn pj_hmac_md5_final(hctx: *mut pj_hmac_md5_context, digest: *mut pj_uint8_t); }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pj_sha1_context { pub state: [pj_uint32_t; 5usize], pub count: [pj_uint32_t; 2usize], pub buffer: [pj_uint8_t; 64usize] }

extern "C" { pub fn pj_sha1_init(ctx: *mut pj_sha1_context); }

extern "C" { pub fn pj_sha1_update(ctx: *mut pj_sha1_context, data: *const pj_uint8_t, nbytes: pj_size_t); }

extern "C" { pub fn pj_sha1_final(ctx: *mut pj_sha1_context, digest: *mut pj_uint8_t); }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pj_hmac_sha1_context { pub context: pj_sha1_context, pub k_opad: [pj_uint8_t; 64usize] }

extern "C" { pub fn pj_hmac_sha1(input: *const pj_uint8_t, input_len: ::std::os::raw::c_uint, key: *const pj_uint8_t, key_len: ::std::os::raw::c_uint, digest: *mut pj_uint8_t); }

extern "C" { pub fn pj_hmac_sha1_init(hctx: *mut pj_hmac_sha1_context, key: *const pj_uint8_t, key_len: ::std::os::raw::c_uint); }

extern "C" { pub fn pj_hmac_sha1_update(hctx: *mut pj_hmac_sha1_context, input: *const pj_uint8_t, input_len: ::std::os::raw::c_uint); }

extern "C" { pub fn pj_hmac_sha1_final(hctx: *mut pj_hmac_sha1_context, digest: *mut pj_uint8_t); }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_dns_srv_option { PJ_DNS_SRV_FALLBACK_A = 1, PJ_DNS_SRV_FALLBACK_AAAA = 2, PJ_DNS_SRV_RESOLVE_AAAA = 4, PJ_DNS_SRV_RESOLVE_AAAA_ONLY = 8 }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pj_dns_srv_record { pub count: ::std::os::raw::c_uint, pub entry: [pj_dns_srv_record__bindgen_ty_1; 8usize] }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pj_dns_srv_record__bindgen_ty_1 { pub priority: ::std::os::raw::c_uint, pub weight: ::std::os::raw::c_uint, pub port: pj_uint16_t, pub server: pj_dns_addr_record }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_dns_srv_async_query { _unused: [u8; 0] }

pub type pj_dns_srv_resolver_cb = ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void, status: pj_status_t, rec: *const pj_dns_srv_record)>;

extern "C" { pub fn pj_dns_srv_resolve(domain_name: *const pj_str_t, res_name: *const pj_str_t, def_port: ::std::os::raw::c_uint, pool: *mut pj_pool_t, resolver: *mut pj_dns_resolver, option: ::std::os::raw::c_uint, token: *mut ::std::os::raw::c_void, cb: pj_dns_srv_resolver_cb, p_query: *mut *mut pj_dns_srv_async_query) -> pj_status_t; }

extern "C" { pub fn pj_dns_srv_cancel_query(query: *mut pj_dns_srv_async_query, notify: pj_bool_t) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_dns_server { _unused: [u8; 0] }

extern "C" { pub fn pj_dns_server_create(pf: *mut pj_pool_factory, ioqueue: *mut pj_ioqueue_t, af: ::std::os::raw::c_int, port: ::std::os::raw::c_uint, flags: ::std::os::raw::c_uint, p_srv: *mut *mut pj_dns_server) -> pj_status_t; }

extern "C" { pub fn pj_dns_server_destroy(srv: *mut pj_dns_server) -> pj_status_t; }

extern "C" { pub fn pj_dns_server_add_rec(srv: *mut pj_dns_server, count: ::std::os::raw::c_uint, rr: *const pj_dns_parsed_rr) -> pj_status_t; }

extern "C" { pub fn pj_dns_server_del_rec(srv: *mut pj_dns_server, dns_class: ::std::os::raw::c_int, type_: pj_dns_type, name: *const pj_str_t) -> pj_status_t; }

extern "C" { pub fn pj_str_unescape(pool: *mut pj_pool_t, src: *const pj_str_t) -> pj_str_t; }

extern "C" { pub fn pj_strcpy_unescape(dst: *mut pj_str_t, src: *const pj_str_t) -> *mut pj_str_t; }

extern "C" { pub fn pj_strncpy_escape(dst: *mut pj_str_t, src: *const pj_str_t, max: pj_ssize_t, unres: *const pj_cis_t) -> *mut pj_str_t; }

extern "C" { pub fn pj_strncpy2_escape(dst: *mut ::std::os::raw::c_char, src: *const pj_str_t, max: pj_ssize_t, unres: *const pj_cis_t) -> pj_ssize_t; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_json_val_type { PJ_JSON_VAL_NULL = 0, PJ_JSON_VAL_BOOL = 1, PJ_JSON_VAL_NUMBER = 2, PJ_JSON_VAL_STRING = 3, PJ_JSON_VAL_ARRAY = 4, PJ_JSON_VAL_OBJ = 5 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_json_list { pub prev: *mut pj_json_elem, pub next: *mut pj_json_elem }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pj_json_elem { pub prev: *mut pj_json_elem, pub next: *mut pj_json_elem, pub name: pj_str_t, pub type_: pj_json_val_type, pub value: pj_json_elem__bindgen_ty_1 }

#[repr(C)]
#[derive(Copy, Clone)]
pub union pj_json_elem__bindgen_ty_1 { pub is_true: pj_bool_t, pub num: f32, pub str: pj_str_t, pub children: pj_json_list, _bindgen_union_align: [u32; 2usize] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_json_err_info { pub line: ::std::os::raw::c_uint, pub col: ::std::os::raw::c_uint, pub err_char: ::std::os::raw::c_int }

pub type pj_json_writer = ::std::option::Option<unsafe extern "C" fn(s: *const ::std::os::raw::c_char, size: ::std::os::raw::c_uint, user_data: *mut ::std::os::raw::c_void) -> pj_status_t>;

extern "C" { pub fn pj_json_elem_null(el: *mut pj_json_elem, name: *mut pj_str_t); }

extern "C" { pub fn pj_json_elem_bool(el: *mut pj_json_elem, name: *mut pj_str_t, val: pj_bool_t); }

extern "C" { pub fn pj_json_elem_number(el: *mut pj_json_elem, name: *mut pj_str_t, val: f32); }

extern "C" { pub fn pj_json_elem_string(el: *mut pj_json_elem, name: *mut pj_str_t, val: *mut pj_str_t); }

extern "C" { pub fn pj_json_elem_array(el: *mut pj_json_elem, name: *mut pj_str_t); }

extern "C" { pub fn pj_json_elem_obj(el: *mut pj_json_elem, name: *mut pj_str_t); }

extern "C" { pub fn pj_json_elem_add(el: *mut pj_json_elem, child: *mut pj_json_elem); }

extern "C" { pub fn pj_json_parse(pool: *mut pj_pool_t, buffer: *mut ::std::os::raw::c_char, size: *mut ::std::os::raw::c_uint, err_info: *mut pj_json_err_info) -> *mut pj_json_elem; }

extern "C" { pub fn pj_json_write(elem: *const pj_json_elem, buffer: *mut ::std::os::raw::c_char, size: *mut ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pj_json_writef(elem: *const pj_json_elem, writer: pj_json_writer, user_data: *mut ::std::os::raw::c_void) -> pj_status_t; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjstun_msg_type { PJSTUN_BINDING_REQUEST = 1, PJSTUN_BINDING_RESPONSE = 257, PJSTUN_BINDING_ERROR_RESPONSE = 273, PJSTUN_SHARED_SECRET_REQUEST = 2, PJSTUN_SHARED_SECRET_RESPONSE = 258, PJSTUN_SHARED_SECRET_ERROR_RESPONSE = 274 }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjstun_attr_type { PJSTUN_ATTR_MAPPED_ADDR = 1, PJSTUN_ATTR_RESPONSE_ADDR = 2, PJSTUN_ATTR_CHANGE_REQUEST = 3, PJSTUN_ATTR_SOURCE_ADDR = 4, PJSTUN_ATTR_CHANGED_ADDR = 5, PJSTUN_ATTR_USERNAME = 6, PJSTUN_ATTR_PASSWORD = 7, PJSTUN_ATTR_MESSAGE_INTEGRITY = 8, PJSTUN_ATTR_ERROR_CODE = 9, PJSTUN_ATTR_UNKNOWN_ATTRIBUTES = 10, PJSTUN_ATTR_REFLECTED_FROM = 11, PJSTUN_ATTR_XOR_MAPPED_ADDR = 32 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjstun_msg_hdr { pub type_: pj_uint16_t, pub length: pj_uint16_t, pub tsx: [pj_uint32_t; 4usize] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjstun_attr_hdr { pub type_: pj_uint16_t, pub length: pj_uint16_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjstun_mapped_addr_attr { pub hdr: pjstun_attr_hdr, pub ignored: pj_uint8_t, pub family: pj_uint8_t, pub port: pj_uint16_t, pub addr: pj_uint32_t }

pub type pjstun_response_addr_attr = pjstun_mapped_addr_attr;
pub type pjstun_changed_addr_attr = pjstun_mapped_addr_attr;
pub type pjstun_src_addr_attr = pjstun_mapped_addr_attr;
pub type pjstun_reflected_form_attr = pjstun_mapped_addr_attr;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjstun_change_request_attr { pub hdr: pjstun_attr_hdr, pub value: pj_uint32_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjstun_username_attr { pub hdr: pjstun_attr_hdr, pub value: [pj_uint32_t; 1usize] }

pub type pjstun_password_attr = pjstun_username_attr;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjstun_error_code_attr { pub hdr: pjstun_attr_hdr, pub ignored: pj_uint16_t, pub err_class: pj_uint8_t, pub number: pj_uint8_t, pub reason: [::std::os::raw::c_char; 4usize] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjstun_msg { pub hdr: *mut pjstun_msg_hdr, pub attr_count: ::std::os::raw::c_int, pub attr: [*mut pjstun_attr_hdr; 16usize] }

extern "C" { pub fn pjstun_create_bind_req(pool: *mut pj_pool_t, msg: *mut *mut ::std::os::raw::c_void, len: *mut pj_size_t, id_hi: pj_uint32_t, id_lo: pj_uint32_t) -> pj_status_t; }

extern "C" { pub fn pjstun_parse_msg(buf: *mut ::std::os::raw::c_void, len: pj_size_t, msg: *mut pjstun_msg) -> pj_status_t; }

extern "C" { pub fn pjstun_msg_find_attr(msg: *mut pjstun_msg, t: pjstun_attr_type) -> *mut ::std::os::raw::c_void; }

extern "C" { pub fn pjstun_get_mapped_addr(pf: *mut pj_pool_factory, sock_cnt: ::std::os::raw::c_int, sock: *mut pj_sock_t, srv1: *const pj_str_t, port1: ::std::os::raw::c_int, srv2: *const pj_str_t, port2: ::std::os::raw::c_int, mapped_addr: *mut pj_sockaddr_in) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjstun_setting { pub use_stun2: pj_bool_t, pub af: ::std::os::raw::c_int, pub srv1: pj_str_t, pub port1: ::std::os::raw::c_int, pub srv2: pj_str_t, pub port2: ::std::os::raw::c_int }

extern "C" { pub fn pjstun_get_mapped_addr2(pf: *mut pj_pool_factory, opt: *const pjstun_setting, sock_cnt: ::std::os::raw::c_int, sock: *mut pj_sock_t, mapped_addr: *mut pj_sockaddr_in) -> pj_status_t; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_pcap_link_type { PJ_PCAP_LINK_TYPE_ETH = 1 }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_pcap_proto_type { PJ_PCAP_PROTO_TYPE_UDP = 17 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_pcap_udp_hdr { pub src_port: pj_uint16_t, pub dst_port: pj_uint16_t, pub len: pj_uint16_t, pub csum: pj_uint16_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_pcap_filter { pub link: pj_pcap_link_type, pub proto: pj_pcap_proto_type, pub ip_src: pj_uint32_t, pub ip_dst: pj_uint32_t, pub src_port: pj_uint16_t, pub dst_port: pj_uint16_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_pcap_file { _unused: [u8; 0] }

extern "C" { pub fn pj_pcap_filter_default(filter: *mut pj_pcap_filter); }

extern "C" { pub fn pj_pcap_open(pool: *mut pj_pool_t, path: *const ::std::os::raw::c_char, p_file: *mut *mut pj_pcap_file) -> pj_status_t; }

extern "C" { pub fn pj_pcap_close(file: *mut pj_pcap_file) -> pj_status_t; }

extern "C" { pub fn pj_pcap_set_filter(file: *mut pj_pcap_file, filter: *const pj_pcap_filter) -> pj_status_t; }

extern "C" { pub fn pj_pcap_read_udp(file: *mut pj_pcap_file, udp_hdr: *mut pj_pcap_udp_hdr, udp_payload: *mut pj_uint8_t, udp_payload_size: *mut pj_size_t) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_activesock_t { _unused: [u8; 0] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_activesock_cb { pub on_data_read: ::std::option::Option<unsafe extern "C" fn(asock: *mut pj_activesock_t, data: *mut ::std::os::raw::c_void, size: pj_size_t, status: pj_status_t, remainder: *mut pj_size_t) -> pj_bool_t>, pub on_data_recvfrom: ::std::option::Option<unsafe extern "C" fn(asock: *mut pj_activesock_t, data: *mut ::std::os::raw::c_void, size: pj_size_t, src_addr: *const pj_sockaddr_t, addr_len: ::std::os::raw::c_int, status: pj_status_t) -> pj_bool_t>, pub on_data_sent: ::std::option::Option<unsafe extern "C" fn(asock: *mut pj_activesock_t, send_key: *mut pj_ioqueue_op_key_t, sent: pj_ssize_t) -> pj_bool_t>, pub on_accept_complete: ::std::option::Option<unsafe extern "C" fn(asock: *mut pj_activesock_t, newsock: pj_sock_t, src_addr: *const pj_sockaddr_t, src_addr_len: ::std::os::raw::c_int) -> pj_bool_t>, pub on_accept_complete2: ::std::option::Option<unsafe extern "C" fn(asock: *mut pj_activesock_t, newsock: pj_sock_t, src_addr: *const pj_sockaddr_t, src_addr_len: ::std::os::raw::c_int, status: pj_status_t) -> pj_bool_t>, pub on_connect_complete: ::std::option::Option<unsafe extern "C" fn(asock: *mut pj_activesock_t, status: pj_status_t) -> pj_bool_t> }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_activesock_cfg { pub grp_lock: *mut pj_grp_lock_t, pub async_cnt: ::std::os::raw::c_uint, pub concurrency: ::std::os::raw::c_int, pub whole_data: pj_bool_t }

extern "C" { pub fn pj_activesock_cfg_default(cfg: *mut pj_activesock_cfg); }

extern "C" { pub fn pj_activesock_create(pool: *mut pj_pool_t, sock: pj_sock_t, sock_type: ::std::os::raw::c_int, opt: *const pj_activesock_cfg, ioqueue: *mut pj_ioqueue_t, cb: *const pj_activesock_cb, user_data: *mut ::std::os::raw::c_void, p_asock: *mut *mut pj_activesock_t) -> pj_status_t; }

extern "C" { pub fn pj_activesock_create_udp(pool: *mut pj_pool_t, addr: *const pj_sockaddr, opt: *const pj_activesock_cfg, ioqueue: *mut pj_ioqueue_t, cb: *const pj_activesock_cb, user_data: *mut ::std::os::raw::c_void, p_asock: *mut *mut pj_activesock_t, bound_addr: *mut pj_sockaddr) -> pj_status_t; }

extern "C" { pub fn pj_activesock_close(asock: *mut pj_activesock_t) -> pj_status_t; }

extern "C" { pub fn pj_activesock_set_user_data(asock: *mut pj_activesock_t, user_data: *mut ::std::os::raw::c_void) -> pj_status_t; }

extern "C" { pub fn pj_activesock_get_user_data(asock: *mut pj_activesock_t) -> *mut ::std::os::raw::c_void; }

extern "C" { pub fn pj_activesock_start_read(asock: *mut pj_activesock_t, pool: *mut pj_pool_t, buff_size: ::std::os::raw::c_uint, flags: pj_uint32_t) -> pj_status_t; }

extern "C" { pub fn pj_activesock_start_read2(asock: *mut pj_activesock_t, pool: *mut pj_pool_t, buff_size: ::std::os::raw::c_uint, readbuf: *mut *mut ::std::os::raw::c_void, flags: pj_uint32_t) -> pj_status_t; }

extern "C" { pub fn pj_activesock_start_recvfrom(asock: *mut pj_activesock_t, pool: *mut pj_pool_t, buff_size: ::std::os::raw::c_uint, flags: pj_uint32_t) -> pj_status_t; }

extern "C" { pub fn pj_activesock_start_recvfrom2(asock: *mut pj_activesock_t, pool: *mut pj_pool_t, buff_size: ::std::os::raw::c_uint, readbuf: *mut *mut ::std::os::raw::c_void, flags: pj_uint32_t) -> pj_status_t; }

extern "C" { pub fn pj_activesock_send(asock: *mut pj_activesock_t, send_key: *mut pj_ioqueue_op_key_t, data: *const ::std::os::raw::c_void, size: *mut pj_ssize_t, flags: ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" { pub fn pj_activesock_sendto(asock: *mut pj_activesock_t, send_key: *mut pj_ioqueue_op_key_t, data: *const ::std::os::raw::c_void, size: *mut pj_ssize_t, flags: ::std::os::raw::c_uint, addr: *const pj_sockaddr_t, addr_len: ::std::os::raw::c_int) -> pj_status_t; }

extern "C" { pub fn pj_activesock_start_accept(asock: *mut pj_activesock_t, pool: *mut pj_pool_t) -> pj_status_t; }

extern "C" { pub fn pj_activesock_start_connect(asock: *mut pj_activesock_t, pool: *mut pj_pool_t, remaddr: *const pj_sockaddr_t, addr_len: ::std::os::raw::c_int) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_http_req { _unused: [u8; 0] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_http_header_elmt { pub name: pj_str_t, pub value: pj_str_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_http_headers { pub count: ::std::os::raw::c_uint, pub header: [pj_http_header_elmt; 32usize] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_http_auth_cred { pub scheme: pj_str_t, pub realm: pj_str_t, pub username: pj_str_t, pub data_type: ::std::os::raw::c_uint, pub data: pj_str_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_http_req_param { pub addr_family: ::std::os::raw::c_int, pub method: pj_str_t, pub version: pj_str_t, pub timeout: pj_time_val, pub user_data: *mut ::std::os::raw::c_void, pub headers: pj_http_headers, pub reqdata: pj_http_req_param_pj_http_reqdata, pub auth_cred: pj_http_auth_cred, pub source_port_range_start: pj_uint16_t, pub source_port_range_size: pj_uint16_t, pub max_retries: pj_uint16_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_http_req_param_pj_http_reqdata { pub data: *mut ::std::os::raw::c_void, pub size: pj_size_t, pub total_size: pj_size_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_http_auth_chal { pub scheme: pj_str_t, pub realm: pj_str_t, pub domain: pj_str_t, pub nonce: pj_str_t, pub opaque: pj_str_t, pub stale: ::std::os::raw::c_int, pub algorithm: pj_str_t, pub qop: pj_str_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_http_resp { pub version: pj_str_t, pub status_code: pj_uint16_t, pub reason: pj_str_t, pub headers: pj_http_headers, pub auth_chal: pj_http_auth_chal, pub content_length: pj_int32_t, pub data: *mut ::std::os::raw::c_void, pub size: pj_size_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_http_url { pub username: pj_str_t, pub passwd: pj_str_t, pub protocol: pj_str_t, pub host: pj_str_t, pub port: pj_uint16_t, pub path: pj_str_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_http_req_callback { pub on_response: ::std::option::Option<unsafe extern "C" fn(http_req: *mut pj_http_req, resp: *const pj_http_resp)>, pub on_send_data: ::std::option::Option<unsafe extern "C" fn(http_req: *mut pj_http_req, data: *mut *mut ::std::os::raw::c_void, size: *mut pj_size_t)>, pub on_data_read: ::std::option::Option<unsafe extern "C" fn(http_req: *mut pj_http_req, data: *mut ::std::os::raw::c_void, size: pj_size_t)>, pub on_complete: ::std::option::Option<unsafe extern "C" fn(http_req: *mut pj_http_req, status: pj_status_t, resp: *const pj_http_resp)> }

extern "C" { pub fn pj_http_req_param_default(param: *mut pj_http_req_param); }

extern "C" { pub fn pj_http_headers_add_elmt(headers: *mut pj_http_headers, name: *mut pj_str_t, val: *mut pj_str_t) -> pj_status_t; }

extern "C" { pub fn pj_http_headers_add_elmt2(headers: *mut pj_http_headers, name: *mut ::std::os::raw::c_char, val: *mut ::std::os::raw::c_char) -> pj_status_t; }

extern "C" { pub fn pj_http_req_parse_url(url: *const pj_str_t, hurl: *mut pj_http_url) -> pj_status_t; }

extern "C" { pub fn pj_http_req_create(pool: *mut pj_pool_t, url: *const pj_str_t, timer: *mut pj_timer_heap_t, ioqueue: *mut pj_ioqueue_t, param: *const pj_http_req_param, hcb: *const pj_http_req_callback, http_req: *mut *mut pj_http_req) -> pj_status_t; }

extern "C" { pub fn pj_http_req_set_timeout(http_req: *mut pj_http_req, timeout: *const pj_time_val); }

extern "C" { pub fn pj_http_req_start(http_req: *mut pj_http_req) -> pj_status_t; }

extern "C" { pub fn pj_http_req_cancel(http_req: *mut pj_http_req, notify: pj_bool_t) -> pj_status_t; }

extern "C" { pub fn pj_http_req_destroy(http_req: *mut pj_http_req) -> pj_status_t; }

extern "C" { pub fn pj_http_req_is_running(http_req: *const pj_http_req) -> pj_bool_t; }

extern "C" { pub fn pj_http_req_get_user_data(http_req: *mut pj_http_req) -> *mut ::std::os::raw::c_void; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_cli_t { _unused: [u8; 0] }

pub type pj_cli_cmd_id = ::std::os::raw::c_int;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_cli_cfg { pub name: pj_str_t, pub title: pj_str_t, pub pf: *mut pj_pool_factory }

pub type pj_cli_arg_id = ::std::os::raw::c_int;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_cli_cmd_spec { _unused: [u8; 0] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_cli_arg_spec { _unused: [u8; 0] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_cli_cmd_val { pub sess: *mut pj_cli_sess, pub cmd: *const pj_cli_cmd_spec, pub argc: ::std::os::raw::c_int, pub argv: [pj_str_t; 8usize] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_cli_hint_info { pub name: pj_str_t, pub type_: pj_str_t, pub desc: pj_str_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_cli_exec_info { pub err_pos: ::std::os::raw::c_int, pub cmd_id: pj_cli_cmd_id, pub cmd_ret: pj_status_t, pub hint_cnt: ::std::os::raw::c_uint, pub hint: [pj_cli_hint_info; 32usize] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_cli_arg_choice_val { pub value: pj_str_t, pub desc: pj_str_t }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_cli_dyn_choice_param { pub sess: *mut pj_cli_sess, pub cmd: *mut pj_cli_cmd_spec, pub arg_id: pj_cli_arg_id, pub max_cnt: ::std::os::raw::c_uint, pub pool: *mut pj_pool_t, pub cnt: ::std::os::raw::c_uint, pub choice: [pj_cli_arg_choice_val; 16usize] }

pub type pj_cli_get_dyn_choice = ::std::option::Option<unsafe extern "C" fn(param: *mut pj_cli_dyn_choice_param)>;
pub type pj_cli_cmd_handler = ::std::option::Option<unsafe extern "C" fn(cval: *mut pj_cli_cmd_val) -> pj_status_t>;

extern "C" { pub fn pj_cli_write_log(cli: *mut pj_cli_t, level: ::std::os::raw::c_int, buffer: *const ::std::os::raw::c_char, len: ::std::os::raw::c_int); }

extern "C" { pub fn pj_cli_create(cfg: *mut pj_cli_cfg, p_cli: *mut *mut pj_cli_t) -> pj_status_t; }

extern "C" { pub fn pj_cli_get_cmd_id(cmd: *const pj_cli_cmd_spec) -> pj_cli_cmd_id; }

extern "C" { pub fn pj_cli_get_param(cli: *mut pj_cli_t) -> *mut pj_cli_cfg; }

extern "C" { pub fn pj_cli_quit(cli: *mut pj_cli_t, req: *mut pj_cli_sess, restart: pj_bool_t); }

extern "C" { pub fn pj_cli_is_quitting(cli: *mut pj_cli_t) -> pj_bool_t; }

extern "C" { pub fn pj_cli_is_restarting(cli: *mut pj_cli_t) -> pj_bool_t; }

extern "C" { pub fn pj_cli_destroy(cli: *mut pj_cli_t); }

extern "C" { pub fn pj_cli_cfg_default(param: *mut pj_cli_cfg); }

extern "C" { pub fn pj_cli_register_front_end(cli: *mut pj_cli_t, fe: *mut pj_cli_front_end); }

extern "C" { pub fn pj_cli_add_cmd_from_xml(cli: *mut pj_cli_t, group: *mut pj_cli_cmd_spec, xml: *const pj_str_t, handler: pj_cli_cmd_handler, p_cmd: *mut *mut pj_cli_cmd_spec, get_choice: pj_cli_get_dyn_choice) -> pj_status_t; }

extern "C" { pub fn pj_cli_exec_info_default(param: *mut pj_cli_exec_info); }

extern "C" { pub fn pj_cli_sess_write_msg(sess: *mut pj_cli_sess, buffer: *const ::std::os::raw::c_char, len: pj_size_t); }

extern "C" { pub fn pj_cli_sess_parse(sess: *mut pj_cli_sess, cmdline: *mut ::std::os::raw::c_char, val: *mut pj_cli_cmd_val, pool: *mut pj_pool_t, info: *mut pj_cli_exec_info) -> pj_status_t; }

extern "C" { pub fn pj_cli_sess_end_session(sess: *mut pj_cli_sess); }

extern "C" { pub fn pj_cli_sess_exec(sess: *mut pj_cli_sess, cmdline: *mut ::std::os::raw::c_char, pool: *mut pj_pool_t, info: *mut pj_cli_exec_info) -> pj_status_t; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_cli_front_end_type { PJ_CLI_CONSOLE_FRONT_END = 0, PJ_CLI_TELNET_FRONT_END = 1, PJ_CLI_HTTP_FRONT_END = 2, PJ_CLI_GUI_FRONT_END = 3 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_cli_front_end_op { pub on_write_log: ::std::option::Option<unsafe extern "C" fn(fe: *mut pj_cli_front_end, level: ::std::os::raw::c_int, data: *const ::std::os::raw::c_char, len: pj_size_t)>, pub on_quit: ::std::option::Option<unsafe extern "C" fn(fe: *mut pj_cli_front_end, req: *mut pj_cli_sess)>, pub on_destroy: ::std::option::Option<unsafe extern "C" fn(fe: *mut pj_cli_front_end)> }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_cli_front_end { pub prev: *mut pj_cli_front_end, pub next: *mut pj_cli_front_end, pub type_: pj_cli_front_end_type, pub cli: *mut pj_cli_t, pub op: *mut pj_cli_front_end_op }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_cli_sess_op { pub destroy: ::std::option::Option<unsafe extern "C" fn(sess: *mut pj_cli_sess)> }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_cli_sess { pub prev: *mut pj_cli_sess, pub next: *mut pj_cli_sess, pub fe: *mut pj_cli_front_end, pub op: *mut pj_cli_sess_op, pub info: pj_str_t, pub log_level: ::std::os::raw::c_int }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_cli_console_cfg { pub log_level: ::std::os::raw::c_int, pub prompt_str: pj_str_t, pub quit_command: pj_str_t }

extern "C" { pub fn pj_cli_console_cfg_default(param: *mut pj_cli_console_cfg); }

extern "C" { pub fn pj_cli_console_create(cli: *mut pj_cli_t, param: *const pj_cli_console_cfg, p_sess: *mut *mut pj_cli_sess, p_fe: *mut *mut pj_cli_front_end) -> pj_status_t; }

extern "C" { pub fn pj_cli_console_process(sess: *mut pj_cli_sess, buf: *mut ::std::os::raw::c_char, maxlen: ::std::os::raw::c_uint) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_cli_telnet_info { pub ip_address: pj_str_t, pub port: pj_uint16_t, pub buf_: [::std::os::raw::c_char; 32usize] }

pub type pj_cli_telnet_on_started = ::std::option::Option<unsafe extern "C" fn(status: pj_status_t)>;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_cli_telnet_cfg { pub port: pj_uint16_t, pub ioqueue: *mut pj_ioqueue_t, pub log_level: ::std::os::raw::c_int, pub passwd: pj_str_t, pub welcome_msg: pj_str_t, pub prompt_str: pj_str_t, pub on_started: pj_cli_telnet_on_started }

extern "C" { pub fn pj_cli_telnet_cfg_default(param: *mut pj_cli_telnet_cfg); }

extern "C" { pub fn pj_cli_telnet_create(cli: *mut pj_cli_t, param: *mut pj_cli_telnet_cfg, p_fe: *mut *mut pj_cli_front_end) -> pj_status_t; }

extern "C" { pub fn pj_cli_telnet_get_info(fe: *mut pj_cli_front_end, info: *mut pj_cli_telnet_info) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_hostent { pub h_name: *mut ::std::os::raw::c_char, pub h_aliases: *mut *mut ::std::os::raw::c_char, pub h_addrtype: ::std::os::raw::c_int, pub h_length: ::std::os::raw::c_int, pub h_addr_list: *mut *mut ::std::os::raw::c_char }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pj_addrinfo { pub ai_canonname: [::std::os::raw::c_char; 128usize], pub ai_addr: pj_sockaddr }

extern "C" { pub fn pj_gethostbyname(name: *const pj_str_t, he: *mut pj_hostent) -> pj_status_t; }

extern "C" { pub fn pj_gethostip(af: ::std::os::raw::c_int, addr: *mut pj_sockaddr) -> pj_status_t; }

extern "C" { pub fn pj_getipinterface(af: ::std::os::raw::c_int, dst: *const pj_str_t, itf_addr: *mut pj_sockaddr, allow_resolve: pj_bool_t, p_dst_addr: *mut pj_sockaddr) -> pj_status_t; }

extern "C" { pub fn pj_getdefaultipinterface(af: ::std::os::raw::c_int, addr: *mut pj_sockaddr) -> pj_status_t; }

extern "C" { pub fn pj_getaddrinfo(af: ::std::os::raw::c_int, name: *const pj_str_t, count: *mut ::std::os::raw::c_uint, ai: *mut pj_addrinfo) -> pj_status_t; }

extern "C" { pub fn pj_array_insert(array: *mut ::std::os::raw::c_void, elem_size: ::std::os::raw::c_uint, count: ::std::os::raw::c_uint, pos: ::std::os::raw::c_uint, value: *const ::std::os::raw::c_void); }

extern "C" { pub fn pj_array_erase(array: *mut ::std::os::raw::c_void, elem_size: ::std::os::raw::c_uint, count: ::std::os::raw::c_uint, pos: ::std::os::raw::c_uint); }

extern "C" { pub fn pj_array_find(array: *const ::std::os::raw::c_void, elem_size: ::std::os::raw::c_uint, count: ::std::os::raw::c_uint, matching: ::std::option::Option<unsafe extern "C" fn(value: *const ::std::os::raw::c_void) -> pj_status_t>, result: *mut *mut ::std::os::raw::c_void) -> pj_status_t; }

pub type __jmp_buf = [::std::os::raw::c_int; 6usize];

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag { pub __jmpbuf: __jmp_buf, pub __mask_was_saved: ::std::os::raw::c_int, pub __saved_mask: __sigset_t }

pub type jmp_buf = [__jmp_buf_tag; 1usize];
pub type pj_jmp_buf = jmp_buf;

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_log_decoration { PJ_LOG_HAS_DAY_NAME = 1, PJ_LOG_HAS_YEAR = 2, PJ_LOG_HAS_MONTH = 4, PJ_LOG_HAS_DAY_OF_MON = 8, PJ_LOG_HAS_TIME = 16, PJ_LOG_HAS_MICRO_SEC = 32, PJ_LOG_HAS_SENDER = 64, PJ_LOG_HAS_NEWLINE = 128, PJ_LOG_HAS_CR = 256, PJ_LOG_HAS_SPACE = 512, PJ_LOG_HAS_COLOR = 1024, PJ_LOG_HAS_LEVEL_TEXT = 2048, PJ_LOG_HAS_THREAD_ID = 4096, PJ_LOG_HAS_THREAD_SWC = 8192, PJ_LOG_HAS_INDENT = 16384 }

pub type pj_log_func = ::std::option::Option<unsafe extern "C" fn(level: ::std::os::raw::c_int, data: *const ::std::os::raw::c_char, len: ::std::os::raw::c_int)>;

extern "C" { pub fn pj_log_write(level: ::std::os::raw::c_int, buffer: *const ::std::os::raw::c_char, len: ::std::os::raw::c_int); }

extern "C" { pub fn pj_log(sender: *const ::std::os::raw::c_char, level: ::std::os::raw::c_int, format: *const ::std::os::raw::c_char, marker: va_list); }

extern "C" { pub fn pj_log_set_log_func(func: pj_log_func); }

extern "C" { pub fn pj_log_get_log_func() -> pj_log_func; }

extern "C" { pub fn pj_log_set_level(level: ::std::os::raw::c_int); }

extern "C" { pub fn pj_log_get_level() -> ::std::os::raw::c_int; }

extern "C" { pub fn pj_log_set_decor(decor: ::std::os::raw::c_uint); }

extern "C" { pub fn pj_log_get_decor() -> ::std::os::raw::c_uint; }

extern "C" { pub fn pj_log_add_indent(indent: ::std::os::raw::c_int); }

extern "C" { pub fn pj_log_push_indent(); }

extern "C" { pub fn pj_log_pop_indent(); }

extern "C" { pub fn pj_log_set_color(level: ::std::os::raw::c_int, color: pj_color_t); }

extern "C" { pub fn pj_log_get_color(level: ::std::os::raw::c_int) -> pj_color_t; }

extern "C" { pub fn pj_log_init() -> pj_status_t; }

extern "C" { pub fn pj_log_1(src: *const ::std::os::raw::c_char, format: *const ::std::os::raw::c_char, ...); }

extern "C" { pub fn pj_log_2(src: *const ::std::os::raw::c_char, format: *const ::std::os::raw::c_char, ...); }

extern "C" { pub fn pj_log_3(src: *const ::std::os::raw::c_char, format: *const ::std::os::raw::c_char, ...); }

extern "C" { pub fn pj_log_4(src: *const ::std::os::raw::c_char, format: *const ::std::os::raw::c_char, ...); }

extern "C" { pub fn pj_log_5(src: *const ::std::os::raw::c_char, format: *const ::std::os::raw::c_char, ...); }

extern "C" { pub fn pj_exception_id_alloc(name: *const ::std::os::raw::c_char, id: *mut pj_exception_id_t) -> pj_status_t; }

extern "C" { pub fn pj_exception_id_free(id: pj_exception_id_t) -> pj_status_t; }

extern "C" { pub fn pj_exception_id_name(id: pj_exception_id_t) -> *const ::std::os::raw::c_char; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_exception_state_t { pub state: pj_jmp_buf, pub prev: *mut pj_exception_state_t }

extern "C" { pub fn pj_throw_exception_(id: pj_exception_id_t); }

extern "C" { pub fn pj_push_exception_handler_(rec: *mut pj_exception_state_t); }

extern "C" { pub fn pj_pop_exception_handler_(rec: *mut pj_exception_state_t); }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_fifobuf_t { pub first: *mut ::std::os::raw::c_char, pub last: *mut ::std::os::raw::c_char, pub ubegin: *mut ::std::os::raw::c_char, pub uend: *mut ::std::os::raw::c_char, pub full: ::std::os::raw::c_int }

extern "C" { pub fn pj_fifobuf_init(fb: *mut pj_fifobuf_t, buffer: *mut ::std::os::raw::c_void, size: ::std::os::raw::c_uint); }

extern "C" { pub fn pj_fifobuf_max_size(fb: *mut pj_fifobuf_t) -> ::std::os::raw::c_uint; }

extern "C" { pub fn pj_fifobuf_alloc(fb: *mut pj_fifobuf_t, size: ::std::os::raw::c_uint) -> *mut ::std::os::raw::c_void; }

extern "C" { pub fn pj_fifobuf_unalloc(fb: *mut pj_fifobuf_t, buf: *mut ::std::os::raw::c_void) -> pj_status_t; }

extern "C" { pub fn pj_fifobuf_free(fb: *mut pj_fifobuf_t, buf: *mut ::std::os::raw::c_void) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_file_stat { pub size: pj_off_t, pub atime: pj_time_val, pub mtime: pj_time_val, pub ctime: pj_time_val }

extern "C" { pub fn pj_file_exists(filename: *const ::std::os::raw::c_char) -> pj_bool_t; }

extern "C" { pub fn pj_file_size(filename: *const ::std::os::raw::c_char) -> pj_off_t; }

extern "C" { pub fn pj_file_delete(filename: *const ::std::os::raw::c_char) -> pj_status_t; }

extern "C" { pub fn pj_file_move(oldname: *const ::std::os::raw::c_char, newname: *const ::std::os::raw::c_char) -> pj_status_t; }

extern "C" { pub fn pj_file_getstat(filename: *const ::std::os::raw::c_char, stat: *mut pj_file_stat) -> pj_status_t; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_file_access { PJ_O_RDONLY = 4353, PJ_O_WRONLY = 4354, PJ_O_RDWR = 4355, PJ_O_APPEND = 4360 }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_file_seek_type { PJ_SEEK_SET = 4609, PJ_SEEK_CUR = 4610, PJ_SEEK_END = 4611 }

extern "C" { pub fn pj_file_open(pool: *mut pj_pool_t, pathname: *const ::std::os::raw::c_char, flags: ::std::os::raw::c_uint, fd: *mut pj_oshandle_t) -> pj_status_t; }

extern "C" { pub fn pj_file_close(fd: pj_oshandle_t) -> pj_status_t; }

extern "C" { pub fn pj_file_write(fd: pj_oshandle_t, data: *const ::std::os::raw::c_void, size: *mut pj_ssize_t) -> pj_status_t; }

extern "C" { pub fn pj_file_read(fd: pj_oshandle_t, data: *mut ::std::os::raw::c_void, size: *mut pj_ssize_t) -> pj_status_t; }

extern "C" { pub fn pj_file_setpos(fd: pj_oshandle_t, offset: pj_off_t, whence: pj_file_seek_type) -> pj_status_t; }

extern "C" { pub fn pj_file_getpos(fd: pj_oshandle_t, pos: *mut pj_off_t) -> pj_status_t; }

extern "C" { pub fn pj_file_flush(fd: pj_oshandle_t) -> pj_status_t; }

extern "C" {
    #[link_name = "\u{1}PJ_GUID_STRING_LENGTH"]
    pub static mut PJ_GUID_STRING_LENGTH: ::std::os::raw::c_uint;
}

extern "C" { pub fn pj_GUID_STRING_LENGTH() -> ::std::os::raw::c_uint; }

extern "C" { pub fn pj_generate_unique_string(str: *mut pj_str_t) -> *mut pj_str_t; }

extern "C" { pub fn pj_generate_unique_string_lower(str: *mut pj_str_t) -> *mut pj_str_t; }

extern "C" { pub fn pj_create_unique_string(pool: *mut pj_pool_t, str: *mut pj_str_t); }

extern "C" { pub fn pj_create_unique_string_lower(pool: *mut pj_pool_t, str: *mut pj_str_t); }

pub type pj_hash_entry_buf = [*mut ::std::os::raw::c_void; 5usize];

extern "C" { pub fn pj_hash_calc(hval: pj_uint32_t, key: *const ::std::os::raw::c_void, keylen: ::std::os::raw::c_uint) -> pj_uint32_t; }

extern "C" { pub fn pj_hash_calc_tolower(hval: pj_uint32_t, result: *mut ::std::os::raw::c_char, key: *const pj_str_t) -> pj_uint32_t; }

extern "C" { pub fn pj_hash_create(pool: *mut pj_pool_t, size: ::std::os::raw::c_uint) -> *mut pj_hash_table_t; }

extern "C" { pub fn pj_hash_get(ht: *mut pj_hash_table_t, key: *const ::std::os::raw::c_void, keylen: ::std::os::raw::c_uint, hval: *mut pj_uint32_t) -> *mut ::std::os::raw::c_void; }

extern "C" { pub fn pj_hash_get_lower(ht: *mut pj_hash_table_t, key: *const ::std::os::raw::c_void, keylen: ::std::os::raw::c_uint, hval: *mut pj_uint32_t) -> *mut ::std::os::raw::c_void; }

extern "C" { pub fn pj_hash_set(pool: *mut pj_pool_t, ht: *mut pj_hash_table_t, key: *const ::std::os::raw::c_void, keylen: ::std::os::raw::c_uint, hval: pj_uint32_t, value: *mut ::std::os::raw::c_void); }

extern "C" { pub fn pj_hash_set_lower(pool: *mut pj_pool_t, ht: *mut pj_hash_table_t, key: *const ::std::os::raw::c_void, keylen: ::std::os::raw::c_uint, hval: pj_uint32_t, value: *mut ::std::os::raw::c_void); }

extern "C" { pub fn pj_hash_set_np(ht: *mut pj_hash_table_t, key: *const ::std::os::raw::c_void, keylen: ::std::os::raw::c_uint, hval: pj_uint32_t, entry_buf: *mut *mut ::std::os::raw::c_void, value: *mut ::std::os::raw::c_void); }

extern "C" { pub fn pj_hash_set_np_lower(ht: *mut pj_hash_table_t, key: *const ::std::os::raw::c_void, keylen: ::std::os::raw::c_uint, hval: pj_uint32_t, entry_buf: *mut *mut ::std::os::raw::c_void, value: *mut ::std::os::raw::c_void); }

extern "C" { pub fn pj_hash_count(ht: *mut pj_hash_table_t) -> ::std::os::raw::c_uint; }

extern "C" { pub fn pj_hash_first(ht: *mut pj_hash_table_t, it: *mut pj_hash_iterator_t) -> *mut pj_hash_iterator_t; }

extern "C" { pub fn pj_hash_next(ht: *mut pj_hash_table_t, it: *mut pj_hash_iterator_t) -> *mut pj_hash_iterator_t; }

extern "C" { pub fn pj_hash_this(ht: *mut pj_hash_table_t, it: *mut pj_hash_iterator_t) -> *mut ::std::os::raw::c_void; }

#[repr(C)]
#[derive(Copy, Clone)]
pub union pj_ip_route_entry { pub ipv4: pj_ip_route_entry__bindgen_ty_1, _bindgen_union_align: [u32; 3usize] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_ip_route_entry__bindgen_ty_1 { pub if_addr: pj_in_addr, pub dst_addr: pj_in_addr, pub mask: pj_in_addr }

extern "C" { pub fn pj_enum_ip_interface(af: ::std::os::raw::c_int, count: *mut ::std::os::raw::c_uint, ifs: *mut pj_sockaddr) -> pj_status_t; }

extern "C" { pub fn pj_enum_ip_route(count: *mut ::std::os::raw::c_uint, routes: *mut pj_ip_route_entry) -> pj_status_t; }

extern "C" { pub fn pj_pool_create_on_buf(name: *const ::std::os::raw::c_char, buf: *mut ::std::os::raw::c_void, size: pj_size_t) -> *mut pj_pool_t; }

extern "C" { pub fn pj_srand(seed: ::std::os::raw::c_uint); }

extern "C" { pub fn pj_rand() -> ::std::os::raw::c_int; }

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pj_rbcolor_t { PJ_RBCOLOR_BLACK = 0, PJ_RBCOLOR_RED = 1 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_rbtree_node { pub parent: *mut pj_rbtree_node, pub left: *mut pj_rbtree_node, pub right: *mut pj_rbtree_node, pub key: *const ::std::os::raw::c_void, pub user_data: *mut ::std::os::raw::c_void, pub color: pj_rbcolor_t }

pub type pj_rbtree_comp = ::std::option::Option<unsafe extern "C" fn(key1: *const ::std::os::raw::c_void, key2: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int>;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_rbtree { pub null_node: pj_rbtree_node, pub null: *mut pj_rbtree_node, pub root: *mut pj_rbtree_node, pub size: ::std::os::raw::c_uint, pub comp: pj_rbtree_comp }

extern "C" { pub fn pj_rbtree_init(tree: *mut pj_rbtree, comp: pj_rbtree_comp); }

extern "C" { pub fn pj_rbtree_first(tree: *mut pj_rbtree) -> *mut pj_rbtree_node; }

extern "C" { pub fn pj_rbtree_last(tree: *mut pj_rbtree) -> *mut pj_rbtree_node; }

extern "C" { pub fn pj_rbtree_next(tree: *mut pj_rbtree, node: *mut pj_rbtree_node) -> *mut pj_rbtree_node; }

extern "C" { pub fn pj_rbtree_prev(tree: *mut pj_rbtree, node: *mut pj_rbtree_node) -> *mut pj_rbtree_node; }

extern "C" { pub fn pj_rbtree_insert(tree: *mut pj_rbtree, node: *mut pj_rbtree_node) -> ::std::os::raw::c_int; }

extern "C" { pub fn pj_rbtree_find(tree: *mut pj_rbtree, key: *const ::std::os::raw::c_void) -> *mut pj_rbtree_node; }

extern "C" { pub fn pj_rbtree_erase(tree: *mut pj_rbtree, node: *mut pj_rbtree_node) -> *mut pj_rbtree_node; }

extern "C" { pub fn pj_rbtree_max_height(tree: *mut pj_rbtree, node: *mut pj_rbtree_node) -> ::std::os::raw::c_uint; }

extern "C" { pub fn pj_rbtree_min_height(tree: *mut pj_rbtree, node: *mut pj_rbtree_node) -> ::std::os::raw::c_uint; }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pj_fd_set_t { pub data: [pj_sock_t; 68usize] }

extern "C" { pub fn PJ_FD_ZERO(fdsetp: *mut pj_fd_set_t); }

extern "C" { pub fn PJ_FD_COUNT(fdsetp: *const pj_fd_set_t) -> pj_size_t; }

extern "C" { pub fn PJ_FD_SET(fd: pj_sock_t, fdsetp: *mut pj_fd_set_t); }

extern "C" { pub fn PJ_FD_CLR(fd: pj_sock_t, fdsetp: *mut pj_fd_set_t); }

extern "C" { pub fn PJ_FD_ISSET(fd: pj_sock_t, fdsetp: *const pj_fd_set_t) -> pj_bool_t; }

extern "C" { pub fn pj_sock_select(n: ::std::os::raw::c_int, readfds: *mut pj_fd_set_t, writefds: *mut pj_fd_set_t, exceptfds: *mut pj_fd_set_t, timeout: *const pj_time_val) -> ::std::os::raw::c_int; }

extern "C" { pub fn pj_ansi_to_unicode(str: *const ::std::os::raw::c_char, len: ::std::os::raw::c_int, wbuf: *mut wchar_t, wbuf_count: ::std::os::raw::c_int) -> *mut wchar_t; }

extern "C" { pub fn pj_unicode_to_ansi(wstr: *const wchar_t, len: pj_ssize_t, buf: *mut ::std::os::raw::c_char, buf_size: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char; }

#[repr(i32)]
/// Constant to identify invalid ID for all sorts of IDs.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsua_invalid_id_const_ { PJSUA_INVALID_ID = -1 }

/// Call identification
pub type pjsua_call_id = ::std::os::raw::c_int;
/// Account identification
pub type pjsua_acc_id = ::std::os::raw::c_int;
/// Buddy identification
pub type pjsua_buddy_id = ::std::os::raw::c_int;
/// File player identification
pub type pjsua_player_id = ::std::os::raw::c_int;
/// File recorder identification
pub type pjsua_recorder_id = ::std::os::raw::c_int;
/// Conference port identification
pub type pjsua_conf_port_id = ::std::os::raw::c_int;

#[repr(u32)]
/// This enumeration represents pjsua state.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsua_state {
    /// The library has not been initialized.
    PJSUA_STATE_NULL = 0,
    /// After pjsua_create() is called but before pjsua_init() is called.
    PJSUA_STATE_CREATED = 1,
    /// After pjsua_init() is called but before pjsua_start() is called.
    PJSUA_STATE_INIT = 2,
    /// After pjsua_start() is called but before everything is running.
    PJSUA_STATE_STARTING = 3,
    /// After pjsua_start() is called and before pjsua_destroy() is called.
    PJSUA_STATE_RUNNING = 4,
    /// After pjsua_destroy() is called but before the function returns.
    PJSUA_STATE_CLOSING = 5,
}

/// Logging configuration, which can be (optionally) specified when calling
/// #pjsua_init(). Application must call #pjsua_logging_config_default() to
/// initialize this structure with the default values.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsua_logging_config {
    /// Log incoming and outgoing SIP message? Yes!
    pub msg_logging: pj_bool_t,
    /// Input verbosity level. Value 5 is reasonable.
    pub level: ::std::os::raw::c_uint,
    /// Verbosity level for console. Value 4 is reasonable.
    pub console_level: ::std::os::raw::c_uint,
    /// Log decoration.
    pub decor: ::std::os::raw::c_uint,
    /// Optional log filename.
    pub log_filename: pj_str_t,
    /// Additional flags to be given to #pj_file_open() when opening
    /// the log file. By default, the flag is PJ_O_WRONLY. Application
    /// may set PJ_O_APPEND here so that logs are appended to existing
    /// file instead of overwriting it.
    ///
    /// Default is 0.
    pub log_file_flags: ::std::os::raw::c_uint,
    /// Optional callback function to be called to write log to
    /// application specific device. This function will be called for
    /// log messages on input verbosity level.
    pub cb: ::std::option::Option<unsafe extern "C" fn(level: ::std::os::raw::c_int, data: *const ::std::os::raw::c_char, len: ::std::os::raw::c_int)>,
}

extern "C" {
    /// Use this function to initialize logging config.
///
/// @param cfg	The logging config to be initialized.
    pub fn pjsua_logging_config_default(cfg: *mut pjsua_logging_config);
}

extern "C" {
    /// Use this function to duplicate logging config.
///
/// @param pool	    Pool to use.
/// @param dst	    Destination config.
/// @param src	    Source config.
    pub fn pjsua_logging_config_dup(pool: *mut pj_pool_t, dst: *mut pjsua_logging_config, src: *const pjsua_logging_config);
}

/// Structure to be passed on MWI callback.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsua_mwi_info {
    /// < Event subscription session, for
    /// reference.
    pub evsub: *mut pjsip_evsub,
    /// < The received NOTIFY request.
    pub rdata: *mut pjsip_rx_data,
}

/// Structure to be passed on registration callback.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsua_reg_info {
    /// < Parameters returned by
    /// registration callback.
    pub cbparam: *mut pjsip_regc_cbparam,
    /// < Client registration
    /// structure.
    pub regc: *mut pjsip_regc,
    /// < Non-zero for registration and
    /// zero for unregistration.
    pub renew: pj_bool_t,
}

/// Structure to be passed to on stream created callback.
/// See #on_stream_created2().
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsua_on_stream_created_param {
    /// The media stream, read-only.
    pub stream: *mut pjmedia_stream,
    /// Stream index in the media session, read-only.
    pub stream_idx: ::std::os::raw::c_uint,
    /// Specify if PJSUA should take ownership of the port returned in
    /// the port parameter below. If set to PJ_TRUE,
    /// pjmedia_port_destroy() will be called on the port when it is
    /// no longer needed.
    ///
    /// Default: PJ_FALSE
    pub destroy_port: pj_bool_t,
    /// On input, it specifies the media port of the stream. Application
    /// may modify this pointer to point to different media port to be
    /// registered to the conference bridge.
    pub port: *mut pjmedia_port,
}

#[repr(u32)]
/// Enumeration of media transport state types.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsua_med_tp_st {
    /// Null, this is the state before media transport is created.
    PJSUA_MED_TP_NULL = 0,
    /// Just before media transport is created, which can finish
    /// asynchronously later.
    PJSUA_MED_TP_CREATING = 1,
    /// Media transport creation is completed, but not initialized yet.
    PJSUA_MED_TP_IDLE = 2,
    /// Initialized (media_create() has been called).
    PJSUA_MED_TP_INIT = 3,
    /// Running (media_start() has been called).
    PJSUA_MED_TP_RUNNING = 4,
    /// Disabled (transport is initialized, but media is being disabled).
    PJSUA_MED_TP_DISABLED = 5,
}

/// Structure to be passed on media transport state callback.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsua_med_tp_state_info {
    /// The media index.
    pub med_idx: ::std::os::raw::c_uint,
    /// The media transport state
    pub state: pjsua_med_tp_st,
    /// The last error code related to the media transport state.
    pub status: pj_status_t,
    /// Optional SIP error code.
    pub sip_err_code: ::std::os::raw::c_int,
    /// Optional extended info, the content is specific for each transport type.
    pub ext_info: *mut ::std::os::raw::c_void,
}

/// Type of callback to be called when media transport state is changed.
///
/// @param call_id	The call ID.
/// @param info         The media transport state info.
///
/// @return		The callback must return PJ_SUCCESS at the moment.
pub type pjsua_med_tp_state_cb = ::std::option::Option<unsafe extern "C" fn(call_id: pjsua_call_id, info: *const pjsua_med_tp_state_info) -> pj_status_t>;
/// Typedef of callback to be registered to #pjsua_resolve_stun_servers()
/// and to be called when STUN resolution completes.
pub type pj_stun_resolve_cb = ::std::option::Option<unsafe extern "C" fn(result: *const pj_stun_resolve_result)>;

#[repr(u32)]
/// This enumeration specifies the options for custom media transport creation.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsua_create_media_transport_flag {
    /// This flag indicates that the media transport must also close its
    /// "member" or "child" transport when pjmedia_transport_close() is
    /// called. If this flag is not specified, then the media transport
    /// must not call pjmedia_transport_close() of its member transport.
    PJSUA_MED_TP_CLOSE_MEMBER = 1,
}

#[repr(u32)]
/// This enumeration specifies the contact rewrite method.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsua_contact_rewrite_method {
    /// The Contact update will be done by sending unregistration
    /// to the currently registered Contact, while simultaneously sending new
    /// registration (with different Call-ID) for the updated Contact.
    PJSUA_CONTACT_REWRITE_UNREGISTER = 1,
    /// The Contact update will be done in a single, current
    /// registration session, by removing the current binding (by setting its
    /// Contact's expires parameter to zero) and adding a new Contact binding,
    /// all done in a single request.
    PJSUA_CONTACT_REWRITE_NO_UNREG = 2,
    /// The Contact update will be done when receiving any registration final
    /// response. If this flag is not specified, contact update will only be
    /// done upon receiving 2xx response. This flag MUST be used with
    /// PJSUA_CONTACT_REWRITE_UNREGISTER or PJSUA_CONTACT_REWRITE_NO_UNREG
    /// above to specify how the Contact update should be performed when
    /// receiving 2xx response.
    PJSUA_CONTACT_REWRITE_ALWAYS_UPDATE = 4,
}

#[repr(u32)]
/// This enumeration specifies the operation when handling IP change.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsua_ip_change_op {
    /// Hasn't start ip change process.
    PJSUA_IP_CHANGE_OP_NULL = 0,
    /// The restart listener process.
    PJSUA_IP_CHANGE_OP_RESTART_LIS = 1,
    /// The shutdown transport process.
    PJSUA_IP_CHANGE_OP_ACC_SHUTDOWN_TP = 2,
    /// The update contact process.
    PJSUA_IP_CHANGE_OP_ACC_UPDATE_CONTACT = 3,
    /// The hanging up call process.
    PJSUA_IP_CHANGE_OP_ACC_HANGUP_CALLS = 4,
    /// The re-INVITE call process.
    PJSUA_IP_CHANGE_OP_ACC_REINVITE_CALLS = 5,
}

/// This will contain the information of the callback \a on_ip_change_progress.
#[repr(C)]
#[derive(Copy, Clone)]
pub union pjsua_ip_change_op_info { pub lis_restart: pjsua_ip_change_op_info__bindgen_ty_1, pub acc_shutdown_tp: pjsua_ip_change_op_info__bindgen_ty_2, pub acc_update_contact: pjsua_ip_change_op_info__bindgen_ty_3, pub acc_hangup_calls: pjsua_ip_change_op_info__bindgen_ty_4, pub acc_reinvite_calls: pjsua_ip_change_op_info__bindgen_ty_5, _bindgen_union_align: [u32; 3usize] }

/// The information from listener restart operation.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsua_ip_change_op_info__bindgen_ty_1 { pub transport_id: ::std::os::raw::c_int }

/// The information from shutdown transport.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsua_ip_change_op_info__bindgen_ty_2 { pub acc_id: ::std::os::raw::c_int }

/// The information from updating contact.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsua_ip_change_op_info__bindgen_ty_3 {
    pub acc_id: pjsua_acc_id,
    /// < SIP Register if PJ_TRUE.
    pub is_register: pj_bool_t,
    /// < SIP status code received.
    pub code: ::std::os::raw::c_int,
}

/// The information from hanging up call operation.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsua_ip_change_op_info__bindgen_ty_4 { pub acc_id: pjsua_acc_id, pub call_id: pjsua_call_id }

/// The information from re-Invite call operation.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsua_ip_change_op_info__bindgen_ty_5 { pub acc_id: pjsua_acc_id, pub call_id: pjsua_call_id }

/// Call settings.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsua_call_setting {
    /// Bitmask of #pjsua_call_flag constants.
    ///
    /// Default: PJSUA_CALL_INCLUDE_DISABLED_MEDIA
    pub flag: ::std::os::raw::c_uint,
    /// This flag controls what methods to request keyframe are allowed on
    /// the call. Value is bitmask of #pjsua_vid_req_keyframe_method.
    ///
    /// Default: PJSUA_VID_REQ_KEYFRAME_SIP_INFO
    pub req_keyframe_method: ::std::os::raw::c_uint,
    /// Number of simultaneous active audio streams for this call. Setting
    /// this to zero will disable audio in this call.
    ///
    /// Default: 1
    pub aud_cnt: ::std::os::raw::c_uint,
    /// Number of simultaneous active video streams for this call. Setting
    /// this to zero will disable video in this call.
    ///
    /// Default: 1 (if video feature is enabled, otherwise it is zero)
    pub vid_cnt: ::std::os::raw::c_uint,
}

/// This structure describes application callback to receive various event
/// notification from PJSUA-API. All of these callbacks are OPTIONAL,
/// although definitely application would want to implement some of
/// the important callbacks (such as \a on_incoming_call).
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsua_callback {
    /// Notify application when call state has changed.
    /// Application may then query the call info to get the
    /// detail call states by calling  pjsua_call_get_info() function.
    ///
    /// @param call_id	The call index.
    /// @param e		Event which causes the call state to change.
    pub on_call_state: ::std::option::Option<unsafe extern "C" fn(call_id: pjsua_call_id, e: *mut pjsip_event)>,
    /// Notify application on incoming call.
    ///
    /// @param acc_id	The account which match the incoming call.
    /// @param call_id	The call id that has just been created for
    /// the call.
    /// @param rdata	The incoming INVITE request.
    pub on_incoming_call: ::std::option::Option<unsafe extern "C" fn(acc_id: pjsua_acc_id, call_id: pjsua_call_id, rdata: *mut pjsip_rx_data)>,
    /// This is a general notification callback which is called whenever
    /// a transaction within the call has changed state. Application can
    /// implement this callback for example to monitor the state of
    /// outgoing requests, or to answer unhandled incoming requests
    /// (such as INFO) with a final response.
    ///
    /// @param call_id	Call identification.
    /// @param tsx	The transaction which has changed state.
    /// @param e		Transaction event that caused the state change.
    pub on_call_tsx_state: ::std::option::Option<unsafe extern "C" fn(call_id: pjsua_call_id, tsx: *mut pjsip_transaction, e: *mut pjsip_event)>,
    /// Notify application when media state in the call has changed.
    /// Normal application would need to implement this callback, e.g.
    /// to connect the call's media to sound device. When ICE is used,
    /// this callback will also be called to report ICE negotiation
    /// failure. When DTLS-SRTP is used, this callback will also be called
    /// to report DTLS negotiation failure.
    ///
    /// @param call_id	The call index.
    pub on_call_media_state: ::std::option::Option<unsafe extern "C" fn(call_id: pjsua_call_id)>,
    /// Notify application when a call has just created a local SDP (for
    /// initial or subsequent SDP offer/answer). Application can implement
    /// this callback to modify the SDP, before it is being sent and/or
    /// negotiated with remote SDP, for example to apply per account/call
    /// basis codecs priority or to add custom/proprietary SDP attributes.
    ///
    /// @param call_id	The call index.
    /// @param sdp	The SDP has just been created.
    /// @param pool	The pool instance, application should use this pool
    /// to modify the SDP.
    /// @param rem_sdp	The remote SDP, will be NULL if local is SDP offerer.
    pub on_call_sdp_created: ::std::option::Option<unsafe extern "C" fn(call_id: pjsua_call_id, sdp: *mut pjmedia_sdp_session, pool: *mut pj_pool_t, rem_sdp: *const pjmedia_sdp_session)>,
    /// Notify application when media session is created and before it is
    /// registered to the conference bridge. Application may return different
    /// media port if it has added media processing port to the stream. This
    /// media port then will be added to the conference bridge instead.
    ///
    /// Note: if implemented, #on_stream_created2() callback will be called
    /// instead of this one.
    ///
    /// @param call_id	    Call identification.
    /// @param strm	    Media stream.
    /// @param stream_idx    Stream index in the media session.
    /// @param p_port	    On input, it specifies the media port of the
    /// stream. Application may modify this pointer to
    /// point to different media port to be registered
    /// to the conference bridge.
    pub on_stream_created: ::std::option::Option<unsafe extern "C" fn(call_id: pjsua_call_id, strm: *mut pjmedia_stream, stream_idx: ::std::os::raw::c_uint, p_port: *mut *mut pjmedia_port)>,
    /// Notify application when media session is created and before it is
    /// registered to the conference bridge. Application may return different
    /// media port if it has added media processing port to the stream. This
    /// media port then will be added to the conference bridge instead.
    ///
    /// @param call_id	    Call identification.
    /// @param param	    The on stream created callback parameter.
    pub on_stream_created2: ::std::option::Option<unsafe extern "C" fn(call_id: pjsua_call_id, param: *mut pjsua_on_stream_created_param)>,
    /// Notify application when media session has been unregistered from the
    /// conference bridge and about to be destroyed.
    ///
    /// @param call_id	    Call identification.
    /// @param strm	    Media stream.
    /// @param stream_idx    Stream index in the media session.
    pub on_stream_destroyed: ::std::option::Option<unsafe extern "C" fn(call_id: pjsua_call_id, strm: *mut pjmedia_stream, stream_idx: ::std::os::raw::c_uint)>,
    /// Notify application upon incoming DTMF digits.
    ///
    /// @param call_id	The call index.
    /// @param digit	DTMF ASCII digit.
    pub on_dtmf_digit: ::std::option::Option<unsafe extern "C" fn(call_id: pjsua_call_id, digit: ::std::os::raw::c_int)>,
    /// Notify application on call being transferred (i.e. REFER is received).
    /// Application can decide to accept/reject transfer request
    /// by setting the code (default is 202). When this callback
    /// is not defined, the default behavior is to accept the
    /// transfer. See also on_call_transfer_request2() callback for
    /// the version with \a pjsua_call_setting in the argument list.
    ///
    /// @param call_id	The call index.
    /// @param dst	The destination where the call will be
    /// transferred to.
    /// @param code	Status code to be returned for the call transfer
    /// request. On input, it contains status code 200.
    pub on_call_transfer_request: ::std::option::Option<unsafe extern "C" fn(call_id: pjsua_call_id, dst: *const pj_str_t, code: *mut pjsip_status_code)>,
    /// Notify application on call being transferred (i.e. REFER is received).
    /// Application can decide to accept/reject transfer request
    /// by setting the code (default is 202). When this callback
    /// is not defined, the default behavior is to accept the
    /// transfer.
    ///
    /// @param call_id	The call index.
    /// @param dst	The destination where the call will be
    /// transferred to.
    /// @param code	Status code to be returned for the call transfer
    /// request. On input, it contains status code 200.
    /// @param opt	The current call setting, application can update
    /// this setting for the call being transferred.
    pub on_call_transfer_request2: ::std::option::Option<unsafe extern "C" fn(call_id: pjsua_call_id, dst: *const pj_str_t, code: *mut pjsip_status_code, opt: *mut pjsua_call_setting)>,
    /// Notify application of the status of previously sent call
    /// transfer request. Application can monitor the status of the
    /// call transfer request, for example to decide whether to
    /// terminate existing call.
    ///
    /// @param call_id	    Call ID.
    /// @param st_code	    Status progress of the transfer request.
    /// @param st_text	    Status progress text.
    /// @param final	    If non-zero, no further notification will
    /// be reported. The st_code specified in
    /// this callback is the final status.
    /// @param p_cont	    Initially will be set to non-zero, application
    /// can set this to FALSE if it no longer wants
    /// to receie further notification (for example,
    /// after it hangs up the call).
    pub on_call_transfer_status: ::std::option::Option<unsafe extern "C" fn(call_id: pjsua_call_id, st_code: ::std::os::raw::c_int, st_text: *const pj_str_t, final_: pj_bool_t, p_cont: *mut pj_bool_t)>,
    /// Notify application about incoming INVITE with Replaces header.
    /// Application may reject the request by setting non-2xx code.
    /// See also on_call_replace_request2() callback for the version
    /// with \a pjsua_call_setting in the argument list.
    ///
    /// @param call_id	    The call ID to be replaced.
    /// @param rdata	    The incoming INVITE request to replace the call.
    /// @param st_code	    Status code to be set by application. Application
    /// should only return a final status (200-699).
    /// @param st_text	    Optional status text to be set by application.
    pub on_call_replace_request: ::std::option::Option<unsafe extern "C" fn(call_id: pjsua_call_id, rdata: *mut pjsip_rx_data, st_code: *mut ::std::os::raw::c_int, st_text: *mut pj_str_t)>,
    /// Notify application about incoming INVITE with Replaces header.
    /// Application may reject the request by setting non-2xx code.
    ///
    /// @param call_id	    The call ID to be replaced.
    /// @param rdata	    The incoming INVITE request to replace the call.
    /// @param st_code	    Status code to be set by application. Application
    /// should only return a final status (200-699).
    /// @param st_text	    Optional status text to be set by application.
    /// @param opt	    The current call setting, application can update
    /// this setting for the call being replaced.
    pub on_call_replace_request2: ::std::option::Option<unsafe extern "C" fn(call_id: pjsua_call_id, rdata: *mut pjsip_rx_data, st_code: *mut ::std::os::raw::c_int, st_text: *mut pj_str_t, opt: *mut pjsua_call_setting)>,
    /// Notify application that an existing call has been replaced with
    /// a new call. This happens when PJSUA-API receives incoming INVITE
    /// request with Replaces header.
    ///
    /// After this callback is called, normally PJSUA-API will disconnect
    /// \a old_call_id and establish \a new_call_id.
    ///
    /// @param old_call_id   Existing call which to be replaced with the
    /// new call.
    /// @param new_call_id   The new call.
    /// @param rdata	    The incoming INVITE with Replaces request.
    pub on_call_replaced: ::std::option::Option<unsafe extern "C" fn(old_call_id: pjsua_call_id, new_call_id: pjsua_call_id)>,
    /// Notify application when call has received new offer from remote
    /// (i.e. re-INVITE/UPDATE with SDP is received, or from the
    /// INVITE response in the case that the initial outgoing INVITE
    /// has no SDP). Application can
    /// decide to accept/reject the offer by setting the code (default
    /// is 200). If the offer is accepted, application can update the
    /// call setting to be applied in the answer. When this callback is
    /// not defined, the default behavior is to accept the offer using
    /// current call setting.
    ///
    /// @param call_id	The call index.
    /// @param offer	The new offer received.
    /// @param reserved	Reserved param, currently not used.
    /// @param code	Status code to be returned for answering the
    /// offer. On input, it contains status code 200.
    /// Currently, valid values are only 200 and 488.
    /// @param opt	The current call setting, application can update
    /// this setting for answering the offer.
    pub on_call_rx_offer: ::std::option::Option<unsafe extern "C" fn(call_id: pjsua_call_id, offer: *const pjmedia_sdp_session, reserved: *mut ::std::os::raw::c_void, code: *mut pjsip_status_code, opt: *mut pjsua_call_setting)>,
    /// Notify application when call has received INVITE with no SDP offer.
    /// Application can update the call setting (e.g: add audio/video), or
    /// enable/disable codecs, or update other media session settings from
    /// within the callback, however, as mandated by the standard (RFC3261
    /// section 14.2), it must ensure that the update overlaps with the
    /// existing media session (in codecs, transports, or other parameters)
    /// that require support from the peer, this is to avoid the need for
    /// the peer to reject the offer.
    ///
    /// When this callback is not defined, the default behavior is to send
    /// SDP offer using current active media session (with all enabled codecs
    /// on each media type).
    ///
    /// @param call_id	The call index.
    /// @param reserved	Reserved param, currently not used.
    /// @param opt	The current call setting, application can update
    /// this setting for generating the offer.
    pub on_call_tx_offer: ::std::option::Option<unsafe extern "C" fn(call_id: pjsua_call_id, reserved: *mut ::std::os::raw::c_void, opt: *mut pjsua_call_setting)>,
    /// Notify application when registration or unregistration has been
    /// initiated. Note that this only notifies the initial registration
    /// and unregistration. Once registration session is active, subsequent
    /// refresh will not cause this callback to be called.
    ///
    /// @param acc_id	    The account ID.
    /// @param renew	    Non-zero for registration and zero for
    /// unregistration.
    pub on_reg_started: ::std::option::Option<unsafe extern "C" fn(acc_id: pjsua_acc_id, renew: pj_bool_t)>,
    /// This is the alternative version of the \a on_reg_started() callback with
    /// \a pjsua_reg_info argument.
    ///
    /// @param acc_id	    The account ID.
    /// @param info	    The registration info.
    pub on_reg_started2: ::std::option::Option<unsafe extern "C" fn(acc_id: pjsua_acc_id, info: *mut pjsua_reg_info)>,
    /// Notify application when registration status has changed.
    /// Application may then query the account info to get the
    /// registration details.
    ///
    /// @param acc_id	    The account ID.
    pub on_reg_state: ::std::option::Option<unsafe extern "C" fn(acc_id: pjsua_acc_id)>,
    /// Notify application when registration status has changed.
    /// Application may inspect the registration info to get the
    /// registration status details.
    ///
    /// @param acc_id	    The account ID.
    /// @param info	    The registration info.
    pub on_reg_state2: ::std::option::Option<unsafe extern "C" fn(acc_id: pjsua_acc_id, info: *mut pjsua_reg_info)>,
    /// Notification when incoming SUBSCRIBE request is received. Application
    /// may use this callback to authorize the incoming subscribe request
    /// (e.g. ask user permission if the request should be granted).
    ///
    /// If this callback is not implemented, all incoming presence subscription
    /// requests will be accepted.
    ///
    /// If this callback is implemented, application has several choices on
    /// what to do with the incoming request:
    /// - it may reject the request immediately by specifying non-200 class
    /// final response in the \a code argument.
    /// - it may immediately accept the request by specifying 200 as the
    /// \a code argument. This is the default value if application doesn't
    /// set any value to the \a code argument. In this case, the library
    /// will automatically send NOTIFY request upon returning from this
    /// callback.
    /// - it may delay the processing of the request, for example to request
    /// user permission whether to accept or reject the request. In this
    /// case, the application MUST set the \a code argument to 202, then
    /// IMMEDIATELY calls #pjsua_pres_notify() with state
    /// PJSIP_EVSUB_STATE_PENDING and later calls #pjsua_pres_notify()
    /// again to accept or reject the subscription request.
    ///
    /// Any \a code other than 200 and 202 will be treated as 200.
    ///
    /// Application MUST return from this callback immediately (e.g. it must
    /// not block in this callback while waiting for user confirmation).
    ///
    /// @param srv_pres	    Server presence subscription instance. If
    /// application delays the acceptance of the request,
    /// it will need to specify this object when calling
    /// #pjsua_pres_notify().
    /// @param acc_id	    Account ID most appropriate for this request.
    /// @param buddy_id	    ID of the buddy matching the sender of the
    /// request, if any, or PJSUA_INVALID_ID if no
    /// matching buddy is found.
    /// @param from	    The From URI of the request.
    /// @param rdata	    The incoming request.
    /// @param code	    The status code to respond to the request. The
    /// default value is 200. Application may set this
    /// to other final status code to accept or reject
    /// the request.
    /// @param reason	    The reason phrase to respond to the request.
    /// @param msg_data	    If the application wants to send additional
    /// headers in the response, it can put it in this
    /// parameter.
    pub on_incoming_subscribe: ::std::option::Option<unsafe extern "C" fn(acc_id: pjsua_acc_id, srv_pres: *mut pjsua_srv_pres, buddy_id: pjsua_buddy_id, from: *const pj_str_t, rdata: *mut pjsip_rx_data, code: *mut pjsip_status_code, reason: *mut pj_str_t, msg_data: *mut pjsua_msg_data)>,
    /// Notification when server side subscription state has changed.
    /// This callback is optional as application normally does not need
    /// to do anything to maintain server side presence subscription.
    ///
    /// @param acc_id	    The account ID.
    /// @param srv_pres	    Server presence subscription object.
    /// @param remote_uri    Remote URI string.
    /// @param state	    New subscription state.
    /// @param event	    PJSIP event that triggers the state change.
    pub on_srv_subscribe_state: ::std::option::Option<unsafe extern "C" fn(acc_id: pjsua_acc_id, srv_pres: *mut pjsua_srv_pres, remote_uri: *const pj_str_t, state: pjsip_evsub_state, event: *mut pjsip_event)>,
    /// Notify application when the buddy state has changed.
    /// Application may then query the buddy into to get the details.
    ///
    /// @param buddy_id	    The buddy id.
    pub on_buddy_state: ::std::option::Option<unsafe extern "C" fn(buddy_id: pjsua_buddy_id)>,
    /// Notify application when the state of client subscription session
    /// associated with a buddy has changed. Application may use this
    /// callback to retrieve more detailed information about the state
    /// changed event.
    ///
    /// @param buddy_id	    The buddy id.
    /// @param sub	    Event subscription session.
    /// @param event	    The event which triggers state change event.
    pub on_buddy_evsub_state: ::std::option::Option<unsafe extern "C" fn(buddy_id: pjsua_buddy_id, sub: *mut pjsip_evsub, event: *mut pjsip_event)>,
    /// Notify application on incoming pager (i.e. MESSAGE request).
    /// Argument call_id will be -1 if MESSAGE request is not related to an
    /// existing call.
    ///
    /// See also \a on_pager2() callback for the version with \a pjsip_rx_data
    /// passed as one of the argument.
    ///
    /// @param call_id	    Containts the ID of the call where the IM was
    /// sent, or PJSUA_INVALID_ID if the IM was sent
    /// outside call context.
    /// @param from	    URI of the sender.
    /// @param to	    URI of the destination message.
    /// @param contact	    The Contact URI of the sender, if present.
    /// @param mime_type	    MIME type of the message.
    /// @param body	    The message content.
    pub on_pager: ::std::option::Option<unsafe extern "C" fn(call_id: pjsua_call_id, from: *const pj_str_t, to: *const pj_str_t, contact: *const pj_str_t, mime_type: *const pj_str_t, body: *const pj_str_t)>,
    /// This is the alternative version of the \a on_pager() callback with
    /// \a pjsip_rx_data argument.
    ///
    /// @param call_id	    Containts the ID of the call where the IM was
    /// sent, or PJSUA_INVALID_ID if the IM was sent
    /// outside call context.
    /// @param from	    URI of the sender.
    /// @param to	    URI of the destination message.
    /// @param contact	    The Contact URI of the sender, if present.
    /// @param mime_type	    MIME type of the message.
    /// @param body	    The message content.
    /// @param rdata	    The incoming MESSAGE request.
    /// @param acc_id	    Account ID most suitable for this message.
    pub on_pager2: ::std::option::Option<unsafe extern "C" fn(call_id: pjsua_call_id, from: *const pj_str_t, to: *const pj_str_t, contact: *const pj_str_t, mime_type: *const pj_str_t, body: *const pj_str_t, rdata: *mut pjsip_rx_data, acc_id: pjsua_acc_id)>,
    /// Notify application about the delivery status of outgoing pager
    /// request. See also on_pager_status2() callback for the version with
    /// \a pjsip_rx_data in the argument list.
    ///
    /// @param call_id	    Containts the ID of the call where the IM was
    /// sent, or PJSUA_INVALID_ID if the IM was sent
    /// outside call context.
    /// @param to	    Destination URI.
    /// @param body	    Message body.
    /// @param user_data	    Arbitrary data that was specified when sending
    /// IM message.
    /// @param status	    Delivery status.
    /// @param reason	    Delivery status reason.
    pub on_pager_status: ::std::option::Option<unsafe extern "C" fn(call_id: pjsua_call_id, to: *const pj_str_t, body: *const pj_str_t, user_data: *mut ::std::os::raw::c_void, status: pjsip_status_code, reason: *const pj_str_t)>,
    /// Notify application about the delivery status of outgoing pager
    /// request.
    ///
    /// @param call_id	    Containts the ID of the call where the IM was
    /// sent, or PJSUA_INVALID_ID if the IM was sent
    /// outside call context.
    /// @param to	    Destination URI.
    /// @param body	    Message body.
    /// @param user_data	    Arbitrary data that was specified when sending
    /// IM message.
    /// @param status	    Delivery status.
    /// @param reason	    Delivery status reason.
    /// @param tdata	    The original MESSAGE request.
    /// @param rdata	    The incoming MESSAGE response, or NULL if the
    /// message transaction fails because of time out
    /// or transport error.
    /// @param acc_id	    Account ID from this the instant message was
    /// send.
    pub on_pager_status2: ::std::option::Option<unsafe extern "C" fn(call_id: pjsua_call_id, to: *const pj_str_t, body: *const pj_str_t, user_data: *mut ::std::os::raw::c_void, status: pjsip_status_code, reason: *const pj_str_t, tdata: *mut pjsip_tx_data, rdata: *mut pjsip_rx_data, acc_id: pjsua_acc_id)>,
    /// Notify application about typing indication.
    ///
    /// @param call_id	    Containts the ID of the call where the IM was
    /// sent, or PJSUA_INVALID_ID if the IM was sent
    /// outside call context.
    /// @param from	    URI of the sender.
    /// @param to	    URI of the destination message.
    /// @param contact	    The Contact URI of the sender, if present.
    /// @param is_typing	    Non-zero if peer is typing, or zero if peer
    /// has stopped typing a message.
    pub on_typing: ::std::option::Option<unsafe extern "C" fn(call_id: pjsua_call_id, from: *const pj_str_t, to: *const pj_str_t, contact: *const pj_str_t, is_typing: pj_bool_t)>,
    /// Notify application about typing indication.
    ///
    /// @param call_id	    Containts the ID of the call where the IM was
    /// sent, or PJSUA_INVALID_ID if the IM was sent
    /// outside call context.
    /// @param from	    URI of the sender.
    /// @param to	    URI of the destination message.
    /// @param contact	    The Contact URI of the sender, if present.
    /// @param is_typing	    Non-zero if peer is typing, or zero if peer
    /// has stopped typing a message.
    /// @param rdata	    The received request.
    /// @param acc_id	    Account ID most suitable for this message.
    pub on_typing2: ::std::option::Option<unsafe extern "C" fn(call_id: pjsua_call_id, from: *const pj_str_t, to: *const pj_str_t, contact: *const pj_str_t, is_typing: pj_bool_t, rdata: *mut pjsip_rx_data, acc_id: pjsua_acc_id)>,
    /// Callback when the library has finished performing NAT type
    /// detection.
    ///
    /// @param res	    NAT detection result.
    pub on_nat_detect: ::std::option::Option<unsafe extern "C" fn(res: *const pj_stun_nat_detect_result)>,
    /// This callback is called when the call is about to resend the
    /// INVITE request to the specified target, following the previously
    /// received redirection response.
    ///
    /// Application may accept the redirection to the specified target,
    /// reject this target only and make the session continue to try the next
    /// target in the list if such target exists, stop the whole
    /// redirection process altogether and cause the session to be
    /// disconnected, or defer the decision to ask for user confirmation.
    ///
    /// This callback is optional. If this callback is not implemented,
    /// the default behavior is to NOT follow the redirection response.
    ///
    /// @param call_id	The call ID.
    /// @param target	The current target to be tried.
    /// @param e		The event that caused this callback to be called.
    /// This could be the receipt of 3xx response, or
    /// 4xx/5xx response received for the INVITE sent to
    /// subsequent targets, or NULL if this callback is
    /// called from within #pjsua_call_process_redirect()
    /// context.
    ///
    /// @return		Action to be performed for the target. Set this
    /// parameter to one of the value below:
    /// - PJSIP_REDIRECT_ACCEPT: immediately accept the
    /// redirection. When set, the call will immediately
    /// resend INVITE request to the target.
    /// - PJSIP_REDIRECT_ACCEPT_REPLACE: immediately accept
    /// the redirection and replace the To header with the
    /// current target. When set, the call will immediately
    /// resend INVITE request to the target.
    /// - PJSIP_REDIRECT_REJECT: immediately reject this
    /// target. The call will continue retrying with
    /// next target if present, or disconnect the call
    /// if there is no more target to try.
    /// - PJSIP_REDIRECT_STOP: stop the whole redirection
    /// process and immediately disconnect the call. The
    /// on_call_state() callback will be called with
    /// PJSIP_INV_STATE_DISCONNECTED state immediately
    /// after this callback returns.
    /// - PJSIP_REDIRECT_PENDING: set to this value if
    /// no decision can be made immediately (for example
    /// to request confirmation from user). Application
    /// then MUST call #pjsua_call_process_redirect()
    /// to either accept or reject the redirection upon
    /// getting user decision.
    pub on_call_redirected: ::std::option::Option<unsafe extern "C" fn(call_id: pjsua_call_id, target: *const pjsip_uri, e: *const pjsip_event) -> pjsip_redirect_op>,
    /// This callback is called when message waiting indication subscription
    /// state has changed. Application can then query the subscription state
    /// by calling #pjsip_evsub_get_state().
    ///
    /// @param acc_id	The account ID.
    /// @param evsub	The subscription instance.
    pub on_mwi_state: ::std::option::Option<unsafe extern "C" fn(acc_id: pjsua_acc_id, evsub: *mut pjsip_evsub)>,
    /// This callback is called when a NOTIFY request for message summary /
    /// message waiting indication is received.
    ///
    /// @param acc_id	The account ID.
    /// @param mwi_info	Structure containing details of the event,
    /// including the received NOTIFY request in the
    /// \a rdata field.
    pub on_mwi_info: ::std::option::Option<unsafe extern "C" fn(acc_id: pjsua_acc_id, mwi_info: *mut pjsua_mwi_info)>,
    /// This callback is called when transport state is changed. See also
    /// #pjsip_tp_state_callback.
    pub on_transport_state: pjsip_tp_state_callback,
    /// This callback is called when media transport state is changed. See
    /// also #pjsua_med_tp_state_cb.
    pub on_call_media_transport_state: pjsua_med_tp_state_cb,
    /// This callback is called to report error in ICE media transport.
    /// Currently it is used to report TURN Refresh error.
    ///
    /// @param index	Transport index.
    /// @param op	Operation which trigger the failure.
    /// @param status	Error status.
    /// @param param	Additional info about the event. Currently this will
    /// always be set to NULL.
    pub on_ice_transport_error: ::std::option::Option<unsafe extern "C" fn(index: ::std::os::raw::c_int, op: pj_ice_strans_op, status: pj_status_t, param: *mut ::std::os::raw::c_void)>,
    /// Callback when the sound device is about to be opened or closed.
    /// This callback will be called even when null sound device or no
    /// sound device is configured by the application (i.e. the
    /// #pjsua_set_null_snd_dev() and #pjsua_set_no_snd_dev() APIs).
    /// Application can use the API #pjsua_get_snd_dev() to get the info
    /// about which sound device is going to be opened/closed.
    ///
    /// This callback is mostly useful when the application wants to manage
    /// the sound device by itself (i.e. with #pjsua_set_no_snd_dev()),
    /// to get notified when it should open or close the sound device.
    ///
    /// @param operation	The value will be set to 0 to signal that sound
    /// device is about to be closed, and 1 to be opened.
    ///
    /// @return		The callback must return PJ_SUCCESS at the moment.
    pub on_snd_dev_operation: ::std::option::Option<unsafe extern "C" fn(operation: ::std::os::raw::c_int) -> pj_status_t>,
    /// Notification about media events such as video notifications. This
    /// callback will most likely be called from media threads, thus
    /// application must not perform heavy processing in this callback.
    /// Especially, application must not destroy the call or media in this
    /// callback. If application needs to perform more complex tasks to
    /// handle the event, it should post the task to another thread.
    ///
    /// @param call_id	The call id.
    /// @param med_idx	The media stream index.
    /// @param event 	The media event.
    pub on_call_media_event: ::std::option::Option<unsafe extern "C" fn(call_id: pjsua_call_id, med_idx: ::std::os::raw::c_uint, event: *mut pjmedia_event)>,
    /// This callback can be used by application to implement custom media
    /// transport adapter for the call, or to replace the media transport
    /// with something completely new altogether.
    ///
    /// This callback is called when a new call is created. The library has
    /// created a media transport for the call, and it is provided as the
    /// \a base_tp argument of this callback. Upon returning, the callback
    /// must return an instance of media transport to be used by the call.
    ///
    /// @param call_id       Call ID
    /// @param media_idx     The media index in the SDP for which this media
    /// transport will be used.
    /// @param base_tp       The media transport which otherwise will be
    /// used by the call has this callback not been
    /// implemented.
    /// @param flags         Bitmask from pjsua_create_media_transport_flag.
    ///
    /// @return              The callback must return an instance of media
    /// transport to be used by the call.
    pub on_create_media_transport: ::std::option::Option<unsafe extern "C" fn(call_id: pjsua_call_id, media_idx: ::std::os::raw::c_uint, base_tp: *mut pjmedia_transport, flags: ::std::os::raw::c_uint) -> *mut pjmedia_transport>,
    /// This callback is called when SRTP media transport is created.
    /// Application can modify the SRTP setting \a srtp_opt to specify
    /// the cryptos and keys which are going to be used. Note that
    /// application should not modify the field
    /// \a pjmedia_srtp_setting.close_member_tp and can only modify
    /// the field \a pjmedia_srtp_setting.use for initial INVITE.
    ///
    /// @param call_id       Call ID
    /// @param media_idx     The media index in the SDP for which this SRTP
    /// media transport will be used.
    /// @param srtp_opt      The SRTP setting. Application can modify this.
    pub on_create_media_transport_srtp: ::std::option::Option<unsafe extern "C" fn(call_id: pjsua_call_id, media_idx: ::std::os::raw::c_uint, srtp_opt: *mut pjmedia_srtp_setting)>,
    /// This callback can be used by application to override the account
    /// to be used to handle an incoming message. Initially, the account to
    /// be used will be calculated automatically by the library. This initial
    /// account will be used if application does not implement this callback,
    /// or application sets an invalid account upon returning from this
    /// callback.
    ///
    /// Note that currently the incoming messages requiring account assignment
    /// are INVITE, MESSAGE, SUBSCRIBE, and unsolicited NOTIFY. This callback
    /// may be called before the callback of the SIP event itself, i.e:
    /// incoming call, pager, subscription, or unsolicited-event.
    ///
    /// @param rdata	The incoming message.
    /// @param acc_id 	On input, initial account ID calculated automatically
    /// by the library. On output, the account ID prefered
    /// by application to handle the incoming message.
    pub on_acc_find_for_incoming: ::std::option::Option<unsafe extern "C" fn(rdata: *const pjsip_rx_data, acc_id: *mut pjsua_acc_id)>,
    /// Calling #pjsua_init() will initiate an async process to resolve and
    /// contact each of the STUN server entries to find which is usable.
    /// This callback is called when the process is complete, and can be
    /// used by the application to start creating and registering accounts.
    /// This way, the accounts can avoid call setup delay caused by pending
    /// STUN resolution.
    ///
    /// See also #pj_stun_resolve_cb.
    pub on_stun_resolution_complete: pj_stun_resolve_cb,
    /// Calling #pjsua_handle_ip_change() may involve different operation. This
    /// callback is called to report the progress of each enabled operation.
    ///
    /// @param op	The operation.
    /// @param status	The status of operation.
    /// @param info	The info from the operation
    ///
    pub on_ip_change_progress: ::std::option::Option<unsafe extern "C" fn(op: pjsua_ip_change_op, status: pj_status_t, info: *const pjsua_ip_change_op_info)>,
}

#[repr(u32)]
/// This enumeration specifies the usage of SIP Session Timers extension.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsua_sip_timer_use {
    /// When this flag is specified, Session Timers will not be used in any
    /// session, except it is explicitly required in the remote request.
    PJSUA_SIP_TIMER_INACTIVE = 0,
    /// When this flag is specified, Session Timers will be used in all
    /// sessions whenever remote supports and uses it.
    PJSUA_SIP_TIMER_OPTIONAL = 1,
    /// When this flag is specified, Session Timers support will be
    /// a requirement for the remote to be able to establish a session.
    PJSUA_SIP_TIMER_REQUIRED = 2,
    /// When this flag is specified, Session Timers will always be used
    /// in all sessions, regardless whether remote supports/uses it or not.
    PJSUA_SIP_TIMER_ALWAYS = 3,
}

#[repr(u32)]
/// This constants controls the use of 100rel extension.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsua_100rel_use {
    /// Not used. For UAC, support for 100rel will be indicated in Supported
    /// header so that peer can opt to use it if it wants to. As UAS, this
    /// option will NOT cause 100rel to be used even if UAC indicates that
    /// it supports this feature.
    PJSUA_100REL_NOT_USED = 0,
    /// Mandatory. UAC will place 100rel in Require header, and UAS will
    /// reject incoming calls unless it has 100rel in Supported header.
    PJSUA_100REL_MANDATORY = 1,
    /// Optional. Similar to PJSUA_100REL_NOT_USED, except that as UAS, this
    /// option will cause 100rel to be used if UAC indicates that it supports it.
    PJSUA_100REL_OPTIONAL = 2,
}

/// This structure describes the settings to control the API and
/// user agent behavior, and can be specified when calling #pjsua_init().
/// Before setting the values, application must call #pjsua_config_default()
/// to initialize this structure with the default values.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsua_config {
    /// Maximum calls to support (default: 4). The value specified here
    /// must be smaller than the compile time maximum settings
    /// PJSUA_MAX_CALLS, which by default is 32. To increase this
    /// limit, the library must be recompiled with new PJSUA_MAX_CALLS
    /// value.
    pub max_calls: ::std::os::raw::c_uint,
    /// Number of worker threads. Normally application will want to have at
    /// least one worker thread, unless when it wants to poll the library
    /// periodically, which in this case the worker thread can be set to
    /// zero.
    pub thread_cnt: ::std::os::raw::c_uint,
    /// Number of nameservers. If no name server is configured, the SIP SRV
    /// resolution would be disabled, and domain will be resolved with
    /// standard pj_gethostbyname() function.
    pub nameserver_count: ::std::os::raw::c_uint,
    /// Array of nameservers to be used by the SIP resolver subsystem.
    /// The order of the name server specifies the priority (first name
    /// server will be used first, unless it is not reachable).
    pub nameserver: [pj_str_t; 4usize],
    /// Force loose-route to be used in all route/proxy URIs (outbound_proxy
    /// and account's proxy settings). When this setting is enabled, the
    /// library will check all the route/proxy URIs specified in the settings
    /// and append ";lr" parameter to the URI if the parameter is not present.
    ///
    /// Default: 1
    pub force_lr: pj_bool_t,
    /// Number of outbound proxies in the \a outbound_proxy array.
    pub outbound_proxy_cnt: ::std::os::raw::c_uint,
    /// Specify the URL of outbound proxies to visit for all outgoing requests.
    /// The outbound proxies will be used for all accounts, and it will
    /// be used to build the route set for outgoing requests. The final
    /// route set for outgoing requests will consists of the outbound proxies
    /// and the proxy configured in the account.
    pub outbound_proxy: [pj_str_t; 4usize],
    /// Warning: deprecated, please use \a stun_srv field instead. To maintain
    /// backward compatibility, if \a stun_srv_cnt is zero then the value of
    /// this field will be copied to \a stun_srv field, if present.
    ///
    /// Specify domain name to be resolved with DNS SRV resolution to get the
    /// address of the STUN server. Alternatively application may specify
    /// \a stun_host instead.
    ///
    /// If DNS SRV resolution failed for this domain, then DNS A resolution
    /// will be performed only if \a stun_host is specified.
    pub stun_domain: pj_str_t,
    /// Warning: deprecated, please use \a stun_srv field instead. To maintain
    /// backward compatibility, if \a stun_srv_cnt is zero then the value of
    /// this field will be copied to \a stun_srv field, if present.
    ///
    /// Specify STUN server to be used, in "HOST[:PORT]" format. If port is
    /// not specified, default port 3478 will be used.
    pub stun_host: pj_str_t,
    /// Number of STUN server entries in \a stun_srv array.
    pub stun_srv_cnt: ::std::os::raw::c_uint,
    /// Array of STUN servers to try. The library will try to resolve and
    /// contact each of the STUN server entry until it finds one that is
    /// usable. Each entry may be a domain name, host name, IP address, and
    /// it may contain an optional port number. For example:
    /// - "pjsip.org" (domain name)
    /// - "sip.pjsip.org" (host name)
    /// - "pjsip.org:33478" (domain name and a non-standard port number)
    /// - "10.0.0.1:3478" (IP address and port number)
    ///
    /// When nameserver is configured in the \a pjsua_config.nameserver field,
    /// if entry is not an IP address, it will be resolved with DNS SRV
    /// resolution first, and it will fallback to use DNS A resolution if this
    /// fails. Port number may be specified even if the entry is a domain name,
    /// in case the DNS SRV resolution should fallback to a non-standard port.
    ///
    /// When nameserver is not configured, entries will be resolved with
    /// #pj_gethostbyname() if it's not an IP address. Port number may be
    /// specified if the server is not listening in standard STUN port.
    pub stun_srv: [pj_str_t; 8usize],
    /// This specifies if the library should try to do an IPv6 resolution of
    /// the STUN servers if the IPv4 resolution fails. It can be useful
    /// in an IPv6-only environment, including on NAT64.
    ///
    /// Default: PJ_FALSE
    pub stun_try_ipv6: pj_bool_t,
    /// This specifies if the library should ignore failure with the
    /// STUN servers. If this is set to PJ_FALSE, the library will refuse to
    /// start if it fails to resolve or contact any of the STUN servers.
    ///
    /// This setting will also determine what happens if STUN servers are
    /// unavailable during runtime (if set to PJ_FALSE, calls will
    /// directly fail, otherwise (if PJ_TRUE) call medias will
    /// fallback to proceed as though not using STUN servers.
    ///
    /// Default: PJ_TRUE
    pub stun_ignore_failure: pj_bool_t,
    /// This specifies whether STUN requests for resolving socket mapped
    /// address should use the new format, i.e: having STUN magic cookie
    /// in its transaction ID.
    ///
    /// Default: PJ_FALSE
    pub stun_map_use_stun2: pj_bool_t,
    /// Support for adding and parsing NAT type in the SDP to assist
    /// troubleshooting. The valid values are:
    /// - 0: no information will be added in SDP, and parsing is disabled.
    /// - 1: only the NAT type number is added.
    /// - 2: add both NAT type number and name.
    ///
    /// Default: 1
    pub nat_type_in_sdp: ::std::os::raw::c_int,
    /// Specify how the support for reliable provisional response (100rel/
    /// PRACK) should be used by default. Note that this setting can be
    /// further customized in account configuration (#pjsua_acc_config).
    ///
    /// Default: PJSUA_100REL_NOT_USED
    pub require_100rel: pjsua_100rel_use,
    /// Specify the usage of Session Timers for all sessions. See the
    /// #pjsua_sip_timer_use for possible values. Note that this setting can be
    /// further customized in account configuration (#pjsua_acc_config).
    ///
    /// Default: PJSUA_SIP_TIMER_OPTIONAL
    pub use_timer: pjsua_sip_timer_use,
    /// Handle unsolicited NOTIFY requests containing message waiting
    /// indication (MWI) info. Unsolicited MWI is incoming NOTIFY requests
    /// which are not requested by client with SUBSCRIBE request.
    ///
    /// If this is enabled, the library will respond 200/OK to the NOTIFY
    /// request and forward the request to \a on_mwi_info() callback.
    ///
    /// See also \a mwi_enabled field #on pjsua_acc_config.
    ///
    /// Default: PJ_TRUE
    ///
    pub enable_unsolicited_mwi: pj_bool_t,
    /// Specify Session Timer settings, see #pjsip_timer_setting.
    /// Note that this setting can be further customized in account
    /// configuration (#pjsua_acc_config).
    pub timer_setting: pjsip_timer_setting,
    /// Number of credentials in the credential array.
    pub cred_count: ::std::os::raw::c_uint,
    /// Array of credentials. These credentials will be used by all accounts,
    /// and can be used to authenticate against outbound proxies. If the
    /// credential is specific to the account, then application should set
    /// the credential in the pjsua_acc_config rather than the credential
    /// here.
    pub cred_info: [pjsip_cred_info; 8usize],
    /// Application callback to receive various event notifications from
    /// the library.
    pub cb: pjsua_callback,
    /// Optional user agent string (default empty). If it's empty, no
    /// User-Agent header will be sent with outgoing requests.
    pub user_agent: pj_str_t,
    /// Specify default value of secure media transport usage.
    /// Valid values are PJMEDIA_SRTP_DISABLED, PJMEDIA_SRTP_OPTIONAL, and
    /// PJMEDIA_SRTP_MANDATORY.
    ///
    /// Note that this setting can be further customized in account
    /// configuration (#pjsua_acc_config).
    ///
    /// Default: #PJSUA_DEFAULT_USE_SRTP
    pub use_srtp: pjmedia_srtp_use,
    /// Specify whether SRTP requires secure signaling to be used. This option
    /// is only used when \a use_srtp option above is non-zero.
    ///
    /// Valid values are:
    /// 0: SRTP does not require secure signaling
    /// 1: SRTP requires secure transport such as TLS
    /// 2: SRTP requires secure end-to-end transport (SIPS)
    ///
    /// Note that this setting can be further customized in account
    /// configuration (#pjsua_acc_config).
    ///
    /// Default: #PJSUA_DEFAULT_SRTP_SECURE_SIGNALING
    pub srtp_secure_signaling: ::std::os::raw::c_int,
    /// This setting has been deprecated and will be ignored.
    pub srtp_optional_dup_offer: pj_bool_t,
    /// Disconnect other call legs when more than one 2xx responses for
    /// outgoing INVITE are received due to forking. Currently the library
    /// is not able to handle simultaneous forked media, so disconnecting
    /// the other call legs is necessary.
    ///
    /// With this setting enabled, the library will handle only one of the
    /// connected call leg, and the other connected call legs will be
    /// disconnected.
    ///
    /// Default: PJ_TRUE (only disable this setting for testing purposes).
    pub hangup_forked_call: pj_bool_t,
}

#[repr(u32)]
/// Flags to be given to pjsua_destroy2()
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsua_destroy_flag {
    /// Allow sending outgoing messages (such as unregistration, event
    /// unpublication, BYEs, unsubscription, etc.), but do not wait for
    /// responses. This is useful to perform "best effort" clean up
    /// without delaying the shutdown process waiting for responses.
    PJSUA_DESTROY_NO_RX_MSG = 1,
    /// If this flag is set, do not send any outgoing messages at all.
    /// This flag is useful if application knows that the network which
    /// the messages are to be sent on is currently down.
    PJSUA_DESTROY_NO_TX_MSG = 2,
    /// Do not send or receive messages during destroy. This flag is
    /// shorthand for  PJSUA_DESTROY_NO_RX_MSG + PJSUA_DESTROY_NO_TX_MSG.
    PJSUA_DESTROY_NO_NETWORK = 3,
}

extern "C" {
    /// Use this function to initialize pjsua config.
///
/// @param cfg	pjsua config to be initialized.
    pub fn pjsua_config_default(cfg: *mut pjsua_config);
}

extern "C" {
    /// Duplicate pjsua_config.
///
/// @param pool	    The pool to get memory from.
/// @param dst	    Destination config.
/// @param src	    Source config.
    pub fn pjsua_config_dup(pool: *mut pj_pool_t, dst: *mut pjsua_config, src: *const pjsua_config);
}

/// This structure describes additional information to be sent with
/// outgoing SIP message. It can (optionally) be specified for example
/// with #pjsua_call_make_call(), #pjsua_call_answer(), #pjsua_call_hangup(),
/// #pjsua_call_set_hold(), #pjsua_call_send_im(), and many more.
///
/// Application MUST call #pjsua_msg_data_init() to initialize this
/// structure before setting its values.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsua_msg_data {
    /// Optional remote target URI (i.e. Target header). If NULL, the target
    /// will be set to the remote URI (To header). At the moment this field
    /// is only used by #pjsua_call_make_call() and #pjsua_im_send().
    pub target_uri: pj_str_t,
    /// Additional message headers as linked list. Application can add
    /// headers to the list by creating the header, either from the heap/pool
    /// or from temporary local variable, and add the header using
    /// linked list operation. See pjsua_app.c for some sample codes.
    pub hdr_list: pjsip_hdr,
    /// MIME type of optional message body.
    pub content_type: pj_str_t,
    /// Optional message body to be added to the message, only when the
    /// message doesn't have a body.
    pub msg_body: pj_str_t,
    /// Content type of the multipart body. If application wants to send
    /// multipart message bodies, it puts the parts in \a parts and set
    /// the content type in \a multipart_ctype. If the message already
    /// contains a body, the body will be added to the multipart bodies.
    pub multipart_ctype: pjsip_media_type,
    /// List of multipart parts. If application wants to send multipart
    /// message bodies, it puts the parts in \a parts and set the content
    /// type in \a multipart_ctype. If the message already contains a body,
    /// the body will be added to the multipart bodies.
    pub multipart_parts: pjsip_multipart_part,
}

extern "C" {
    /// Initialize message data.
///
/// @param msg_data  Message data to be initialized.
    pub fn pjsua_msg_data_init(msg_data: *mut pjsua_msg_data);
}

extern "C" {
    /// Clone message data.
///
/// @param pool	    Pool to allocate memory for the new message data.
/// @param rhs       Message data to be cloned.
///
/// @return          The new message data.
    pub fn pjsua_msg_data_clone(pool: *mut pj_pool_t, rhs: *const pjsua_msg_data) -> *mut pjsua_msg_data;
}

extern "C" {
    /// Instantiate pjsua application. Application must call this function before
/// calling any other functions, to make sure that the underlying libraries
/// are properly initialized. Once this function has returned success,
/// application must call pjsua_destroy() before quitting.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_create() -> pj_status_t;
}

extern "C" {
    /// Initialize pjsua with the specified settings. All the settings are
/// optional, and the default values will be used when the config is not
/// specified.
///
/// Note that #pjsua_create() MUST be called before calling this function.
///
/// @param ua_cfg	User agent configuration.
/// @param log_cfg	Optional logging configuration.
/// @param media_cfg	Optional media configuration.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_init(ua_cfg: *const pjsua_config, log_cfg: *const pjsua_logging_config, media_cfg: *const pjsua_media_config) -> pj_status_t;
}

extern "C" {
    /// Application is recommended to call this function after all initialization
/// is done, so that the library can do additional checking set up
/// additional
///
/// Application may call this function anytime after #pjsua_init().
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_start() -> pj_status_t;
}

extern "C" {
    /// Destroy pjsua. Application is recommended to perform graceful shutdown
/// before calling this function (such as unregister the account from the SIP
/// server, terminate presense subscription, and hangup active calls), however,
/// this function will do all of these if it finds there are active sessions
/// that need to be terminated. This function will approximately block for
/// one second to wait for replies from remote.
///
/// Application.may safely call this function more than once if it doesn't
/// keep track of it's state.
///
/// @see pjsua_destroy2()
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_destroy() -> pj_status_t;
}

extern "C" {
    /// Retrieve pjsua state.
///
/// @return 	pjsua state.
    pub fn pjsua_get_state() -> pjsua_state;
}

extern "C" {
    /// Variant of destroy with additional flags.
///
/// @param flags		Combination of pjsua_destroy_flag enumeration.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_destroy2(flags: ::std::os::raw::c_uint) -> pj_status_t;
}

extern "C" {
    /// Poll pjsua for events, and if necessary block the caller thread for
/// the specified maximum interval (in miliseconds).
///
/// Application doesn't normally need to call this function if it has
/// configured worker thread (\a thread_cnt field) in pjsua_config structure,
/// because polling then will be done by these worker threads instead.
///
/// @param msec_timeout	Maximum time to wait, in miliseconds.
///
/// @return  The number of events that have been handled during the
/// poll. Negative value indicates error, and application
/// can retrieve the error as (status = -return_value).
    pub fn pjsua_handle_events(msec_timeout: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}

extern "C" {
    /// Signal all worker threads to quit. This will only wait until internal
/// threads are done.
    pub fn pjsua_stop_worker_threads();
}

extern "C" {
    /// Create memory pool to be used by the application. Once application
/// finished using the pool, it must be released with pj_pool_release().
///
/// @param name		Optional pool name.
/// @param init_size	Initial size of the pool.
/// @param increment	Increment size.
///
/// @return		The pool, or NULL when there's no memory.
    pub fn pjsua_pool_create(name: *const ::std::os::raw::c_char, init_size: pj_size_t, increment: pj_size_t) -> *mut pj_pool_t;
}

extern "C" {
    /// Application can call this function at any time (after pjsua_create(), of
/// course) to change logging settings.
///
/// @param c		Logging configuration.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_reconfigure_logging(c: *const pjsua_logging_config) -> pj_status_t;
}

extern "C" {
    /// Internal function to get SIP endpoint instance of pjsua, which is
/// needed for example to register module, create transports, etc.
/// Only valid after #pjsua_init() is called.
///
/// @return		SIP endpoint instance.
    pub fn pjsua_get_pjsip_endpt() -> *mut pjsip_endpoint;
}

extern "C" {
    /// Internal function to get media endpoint instance.
/// Only valid after #pjsua_init() is called.
///
/// @return		Media endpoint instance.
    pub fn pjsua_get_pjmedia_endpt() -> *mut pjmedia_endpt;
}

extern "C" {
    /// Internal function to get PJSUA pool factory.
/// Only valid after #pjsua_create() is called.
///
/// @return		Pool factory currently used by PJSUA.
    pub fn pjsua_get_pool_factory() -> *mut pj_pool_factory;
}

/// This structure is used to represent the result of the STUN server
/// resolution and testing, the #pjsua_resolve_stun_servers() function.
/// This structure will be passed in #pj_stun_resolve_cb callback.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pj_stun_resolve_result {
    /// Arbitrary data that was passed to #pjsua_resolve_stun_servers()
    /// function.
    pub token: *mut ::std::os::raw::c_void,
    /// This will contain PJ_SUCCESS if at least one usable STUN server
    /// is found, otherwise it will contain the last error code during
    /// the operation.
    pub status: pj_status_t,
    /// The server name that yields successful result. This will only
    /// contain value if status is successful.
    pub name: pj_str_t,
    /// The server IP address. This will only contain value if status
    /// is successful.
    pub addr: pj_sockaddr,
    /// The index of the usable STUN server.
    pub index: ::std::os::raw::c_uint,
}

/// This structure describe the parameter passed to #pjsua_handle_ip_change().
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsua_ip_change_param {
    /// If set to PJ_TRUE, this will restart the transport listener.
    ///
    /// Default : PJ_TRUE
    pub restart_listener: pj_bool_t,
    /// If \a restart listener is set to PJ_TRUE, some delay might be needed
    /// for the listener to be restarted. Use this to set the delay.
    ///
    /// Default : PJSUA_TRANSPORT_RESTART_DELAY_TIME
    pub restart_lis_delay: ::std::os::raw::c_uint,
}

/// This structure describe the account config specific to IP address change.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsua_ip_change_acc_cfg {
    /// Shutdown the transport used for account registration. If this is set to
    /// PJ_TRUE, the transport will be shutdown altough it's used by multiple
    /// account. Shutdown transport will be followed by re-Registration if
    /// pjsua_acc_config.allow_contact_rewrite is enabled.
    ///
    /// Default: PJ_TRUE
    pub shutdown_tp: pj_bool_t,
    /// Hangup active calls associated with the account. If this is set to
    /// PJ_TRUE, then the calls will be hang up.
    ///
    /// Default: PJ_FALSE
    pub hangup_calls: pj_bool_t,
    /// Specify the call flags used in the re-INVITE when \a hangup_calls is set
    /// to PJ_FALSE. If this is set to 0, no re-INVITE will be sent. The
    /// re-INVITE will be sent after re-Registration is finished.
    ///
    /// Default: PJSUA_CALL_REINIT_MEDIA | PJSUA_CALL_UPDATE_CONTACT |
    /// PJSUA_CALL_UPDATE_VIA
    pub reinvite_flags: ::std::os::raw::c_uint,
}

extern "C" {
    /// Call this function to initialize \a pjsua_ip_change_param with default
/// values.
///
/// @param param	    The IP change param to be initialized.
    pub fn pjsua_ip_change_param_default(param: *mut pjsua_ip_change_param);
}

extern "C" {
    /// This is a utility function to detect NAT type in front of this
/// endpoint. Once invoked successfully, this function will complete
/// asynchronously and report the result in \a on_nat_detect() callback
/// of pjsua_callback.
///
/// After NAT has been detected and the callback is called, application can
/// get the detected NAT type by calling #pjsua_get_nat_type(). Application
/// can also perform NAT detection by calling #pjsua_detect_nat_type()
/// again at later time.
///
/// Note that STUN must be enabled to run this function successfully.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_detect_nat_type() -> pj_status_t;
}

extern "C" {
    /// Get the NAT type as detected by #pjsua_detect_nat_type() function.
/// This function will only return useful NAT type after #pjsua_detect_nat_type()
/// has completed successfully and \a on_nat_detect() callback has been called.
///
/// @param type		NAT type.
///
/// @return		When detection is in progress, this function will
/// return PJ_EPENDING and \a type will be set to
/// PJ_STUN_NAT_TYPE_UNKNOWN. After NAT type has been
/// detected successfully, this function will return
/// PJ_SUCCESS and \a type will be set to the correct
/// value. Other return values indicate error and
/// \a type will be set to PJ_STUN_NAT_TYPE_ERR_UNKNOWN.
///
/// @see pjsua_call_get_rem_nat_type()
    pub fn pjsua_get_nat_type(type_: *mut pj_stun_nat_type) -> pj_status_t;
}

extern "C" {
    /// Update the STUN servers list. The #pjsua_init() must have been called
/// before calling this function.
///
/// @param count		Number of STUN server entries.
/// @param srv		Array of STUN server entries to try. Please see
/// the \a stun_srv field in the #pjsua_config
/// documentation about the format of this entry.
/// @param wait		Specify non-zero to make the function block until
/// it gets the result. In this case, the function
/// will block while the resolution is being done,
/// and the callback will be called before this function
/// returns.
///
/// @return		If \a wait parameter is non-zero, this will return
/// PJ_SUCCESS if one usable STUN server is found.
/// Otherwise it will always return PJ_SUCCESS, and
/// application will be notified about the result in
/// the callback #on_stun_resolution_complete.
    pub fn pjsua_update_stun_servers(count: ::std::os::raw::c_uint, srv: *mut pj_str_t, wait: pj_bool_t) -> pj_status_t;
}

extern "C" {
    /// Auxiliary function to resolve and contact each of the STUN server
/// entries (sequentially) to find which is usable. The #pjsua_init() must
/// have been called before calling this function.
///
/// @param count		Number of STUN server entries to try.
/// @param srv		Array of STUN server entries to try. Please see
/// the \a stun_srv field in the #pjsua_config
/// documentation about the format of this entry.
/// @param wait		Specify non-zero to make the function block until
/// it gets the result. In this case, the function
/// will block while the resolution is being done,
/// and the callback will be called before this function
/// returns.
/// @param token		Arbitrary token to be passed back to application
/// in the callback.
/// @param cb		Callback to be called to notify the result of
/// the function.
///
/// @return		If \a wait parameter is non-zero, this will return
/// PJ_SUCCESS if one usable STUN server is found.
/// Otherwise it will always return PJ_SUCCESS, and
/// application will be notified about the result in
/// the callback.
    pub fn pjsua_resolve_stun_servers(count: ::std::os::raw::c_uint, srv: *mut pj_str_t, wait: pj_bool_t, token: *mut ::std::os::raw::c_void, cb: pj_stun_resolve_cb) -> pj_status_t;
}

extern "C" {
    /// Cancel pending STUN resolution which match the specified token.
///
/// @param token		The token to match. This token was given to
/// #pjsua_resolve_stun_servers()
/// @param notify_cb	Boolean to control whether the callback should
/// be called for cancelled resolutions. When the
/// callback is called, the status in the result
/// will be set as PJ_ECANCELLED.
///
/// @return		PJ_SUCCESS if there is at least one pending STUN
/// resolution cancelled, or PJ_ENOTFOUND if there is
/// no matching one, or other error.
    pub fn pjsua_cancel_stun_resolution(token: *mut ::std::os::raw::c_void, notify_cb: pj_bool_t) -> pj_status_t;
}

extern "C" {
    /// This is a utility function to verify that valid SIP url is given. If the
/// URL is a valid SIP/SIPS scheme, PJ_SUCCESS will be returned.
///
/// @param url		The URL, as NULL terminated string.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
///
/// @see pjsua_verify_url()
    pub fn pjsua_verify_sip_url(url: *const ::std::os::raw::c_char) -> pj_status_t;
}

extern "C" {
    /// This is a utility function to verify that valid URI is given. Unlike
/// pjsua_verify_sip_url(), this function will return PJ_SUCCESS if tel: URI
/// is given.
///
/// @param url		The URL, as NULL terminated string.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
///
/// @see pjsua_verify_sip_url()
    pub fn pjsua_verify_url(url: *const ::std::os::raw::c_char) -> pj_status_t;
}

extern "C" { pub fn pjsua_schedule_timer(entry: *mut pj_timer_entry, delay: *const pj_time_val) -> pj_status_t; }

extern "C" { pub fn pjsua_schedule_timer2(cb: ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>, user_data: *mut ::std::os::raw::c_void, msec_delay: ::std::os::raw::c_uint) -> pj_status_t; }

extern "C" {
    /// Cancel the previously scheduled timer.
///
/// @param entry		Timer heap entry.
///
/// @see pjsip_endpt_cancel_timer()
    pub fn pjsua_cancel_timer(entry: *mut pj_timer_entry);
}

extern "C" {
    /// This is a utility function to display error message for the specified
/// error code. The error message will be sent to the log.
///
/// @param sender	The log sender field.
/// @param title		Message title for the error.
/// @param status	Status code.
    pub fn pjsua_perror(sender: *const ::std::os::raw::c_char, title: *const ::std::os::raw::c_char, status: pj_status_t);
}

extern "C" {
    /// This is a utility function to dump the stack states to log, using
/// verbosity level 3.
///
/// @param detail	Will print detailed output (such as list of
/// SIP transactions) when non-zero.
    pub fn pjsua_dump(detail: pj_bool_t);
}

extern "C" {
    /// Inform the stack that IP address change event was detected.
/// The stack will:
/// 1. Restart the listener (this step is configurable via
/// \a pjsua_ip_change_param.restart_listener).
/// 2. Shutdown the transport used by account registration (this step is
/// configurable via \a pjsua_acc_config.ip_change_cfg.shutdown_tp).
/// 3. Update contact URI by sending re-Registration (this step is configurable
/// via a\ pjsua_acc_config.allow_contact_rewrite and
/// a\ pjsua_acc_config.contact_rewrite_method)
/// 4. Hangup active calls (this step is configurable via
/// a\ pjsua_acc_config.ip_change_cfg.hangup_calls) or
/// continue the call by sending re-INVITE
/// (configurable via \a pjsua_acc_config.ip_change_cfg.reinvite_flags).
///
/// @param param		The IP change parameter, have a look at
/// #pjsua_ip_change_param.
///
/// @return		PJ_SUCCESS on success, other on error.
    pub fn pjsua_handle_ip_change(param: *const pjsua_ip_change_param) -> pj_status_t;
}

/// SIP transport identification.
pub type pjsua_transport_id = ::std::os::raw::c_int;

/// Transport configuration for creating transports for both SIP
/// and media. Before setting some values to this structure, application
/// MUST call #pjsua_transport_config_default() to initialize its
/// values with default settings.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsua_transport_config {
    /// UDP port number to bind locally. This setting MUST be specified
    /// even when default port is desired. If the value is zero, the
    /// transport will be bound to any available port, and application
    /// can query the port by querying the transport info.
    pub port: ::std::os::raw::c_uint,
    /// Specify the port range for socket binding, relative to the start
    /// port number specified in \a port. Note that this setting is only
    /// applicable when the start port number is non zero.
    ///
    /// Default value is zero.
    pub port_range: ::std::os::raw::c_uint,
    /// Optional address to advertise as the address of this transport.
    /// Application can specify any address or hostname for this field,
    /// for example it can point to one of the interface address in the
    /// system, or it can point to the public address of a NAT router
    /// where port mappings have been configured for the application.
    ///
    /// Note: this option can be used for both UDP and TCP as well!
    pub public_addr: pj_str_t,
    /// Optional address where the socket should be bound to. This option
    /// SHOULD only be used to selectively bind the socket to particular
    /// interface (instead of 0.0.0.0), and SHOULD NOT be used to set the
    /// published address of a transport (the public_addr field should be
    /// used for that purpose).
    ///
    /// Note that unlike public_addr field, the address (or hostname) here
    /// MUST correspond to the actual interface address in the host, since
    /// this address will be specified as bind() argument.
    pub bound_addr: pj_str_t,
    /// This specifies TLS settings for TLS transport. It is only be used
    /// when this transport config is being used to create a SIP TLS
    /// transport.
    pub tls_setting: pjsip_tls_setting,
    /// QoS traffic type to be set on this transport. When application wants
    /// to apply QoS tagging to the transport, it's preferable to set this
    /// field rather than \a qos_param fields since this is more portable.
    ///
    /// Default is QoS not set.
    pub qos_type: pj_qos_type,
    /// Set the low level QoS parameters to the transport. This is a lower
    /// level operation than setting the \a qos_type field and may not be
    /// supported on all platforms.
    ///
    /// Default is QoS not set.
    pub qos_params: pj_qos_params,
    /// Specify options to be set on the transport.
    ///
    /// By default there is no options.
    ///
    pub sockopt_params: pj_sockopt_params,
}

extern "C" {
    /// Call this function to initialize UDP config with default values.
///
/// @param cfg	    The UDP config to be initialized.
    pub fn pjsua_transport_config_default(cfg: *mut pjsua_transport_config);
}

extern "C" {
    /// Duplicate transport config.
///
/// @param pool		The pool.
/// @param dst		The destination config.
/// @param src		The source config.
    pub fn pjsua_transport_config_dup(pool: *mut pj_pool_t, dst: *mut pjsua_transport_config, src: *const pjsua_transport_config);
}

/// This structure describes transport information returned by
/// #pjsua_transport_get_info() function.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsua_transport_info {
    /// PJSUA transport identification.
    pub id: pjsua_transport_id,
    /// Transport type.
    pub type_: pjsip_transport_type_e,
    /// Transport type name.
    pub type_name: pj_str_t,
    /// Transport string info/description.
    pub info: pj_str_t,
    /// Transport flag (see ##pjsip_transport_flags_e).
    pub flag: ::std::os::raw::c_uint,
    /// Local address length.
    pub addr_len: ::std::os::raw::c_uint,
    /// Local/bound address.
    pub local_addr: pj_sockaddr,
    /// Published address (or transport address name).
    pub local_name: pjsip_host_port,
    /// Current number of objects currently referencing this transport.
    pub usage_count: ::std::os::raw::c_uint,
}

extern "C" {
    /// Create and start a new SIP transport according to the specified
/// settings.
///
/// @param type		Transport type.
/// @param cfg		Transport configuration.
/// @param p_id		Optional pointer to receive transport ID.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_transport_create(type_: pjsip_transport_type_e, cfg: *const pjsua_transport_config, p_id: *mut pjsua_transport_id) -> pj_status_t;
}

extern "C" {
    /// Register transport that has been created by application. This function
/// is useful if application wants to implement custom SIP transport and use
/// it with pjsua.
///
/// @param tp		Transport instance.
/// @param p_id		Optional pointer to receive transport ID.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_transport_register(tp: *mut pjsip_transport, p_id: *mut pjsua_transport_id) -> pj_status_t;
}

extern "C" {
    /// Enumerate all transports currently created in the system. This function
/// will return all transport IDs, and application may then call
/// #pjsua_transport_get_info() function to retrieve detailed information
/// about the transport.
///
/// @param id		Array to receive transport ids.
/// @param count		In input, specifies the maximum number of elements.
/// On return, it contains the actual number of elements.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_enum_transports(id: *mut pjsua_transport_id, count: *mut ::std::os::raw::c_uint) -> pj_status_t;
}

extern "C" {
    /// Get information about transports.
///
/// @param id		Transport ID.
/// @param info		Pointer to receive transport info.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_transport_get_info(id: pjsua_transport_id, info: *mut pjsua_transport_info) -> pj_status_t;
}

extern "C" {
    /// Disable a transport or re-enable it. By default transport is always
/// enabled after it is created. Disabling a transport does not necessarily
/// close the socket, it will only discard incoming messages and prevent
/// the transport from being used to send outgoing messages.
///
/// @param id		Transport ID.
/// @param enabled	Non-zero to enable, zero to disable.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_transport_set_enable(id: pjsua_transport_id, enabled: pj_bool_t) -> pj_status_t;
}

extern "C" {
    /// Close the transport. If transport is forcefully closed, it will be
/// immediately closed, and any pending transactions that are using the
/// transport may not terminate properly (it may even crash). Otherwise,
/// the system will wait until all transactions are closed while preventing
/// new users from using the transport, and will close the transport when
/// it is safe to do so.
///
/// @param id		Transport ID.
/// @param force		Non-zero to immediately close the transport. This
/// is not recommended!
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_transport_close(id: pjsua_transport_id, force: pj_bool_t) -> pj_status_t;
}

extern "C" {
    /// Start the listener of the transport. This is useful when listener is not
/// automatically started when creating the transport.
///
/// @param id		Transport ID.
/// @param cfg		The new transport config used by the listener.
/// Only port, public_addr and bound_addr are used at the
/// moment.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_transport_lis_start(id: pjsua_transport_id, cfg: *const pjsua_transport_config) -> pj_status_t;
}

#[repr(u32)]
/// This enumeration specifies how we should offer call hold request to
/// remote peer. The default value is set by compile time constant
/// PJSUA_CALL_HOLD_TYPE_DEFAULT, and application may control the setting
/// on per-account basis by manipulating \a call_hold_type field in
/// #pjsua_acc_config.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsua_call_hold_type {
    /// This will follow RFC 3264 recommendation to use a=sendonly,
    /// a=recvonly, and a=inactive attribute as means to signal call
    /// hold status. This is the correct value to use.
    PJSUA_CALL_HOLD_TYPE_RFC3264 = 0,
    /// This will use the old and deprecated method as specified in RFC 2543,
    /// and will offer c=0.0.0.0 in the SDP instead. Using this has many
    /// drawbacks such as inability to keep the media transport alive while
    /// the call is being put on hold, and should only be used if remote
    /// does not understand RFC 3264 style call hold offer.
    PJSUA_CALL_HOLD_TYPE_RFC2543 = 1,
}

#[repr(u32)]
/// This enumeration controls the use of STUN in the account.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsua_stun_use {
    /// Follow the default setting in the global \a pjsua_config.
    PJSUA_STUN_USE_DEFAULT = 0,
    /// Disable STUN. If STUN is not enabled in the global \a pjsua_config,
    /// this setting has no effect.
    PJSUA_STUN_USE_DISABLED = 1,
    /// Retry other STUN servers if the STUN server selected during
    /// startup (#pjsua_init()) or after calling #pjsua_update_stun_servers()
    /// is unavailable during runtime. This setting is valid only for
    /// account's media STUN setting and if the call is using UDP media
    /// transport.
    PJSUA_STUN_RETRY_ON_FAILURE = 2,
}

#[repr(u32)]
/// This enumeration controls the use of ICE settings in the account.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsua_ice_config_use {
    /// Use the default settings in the global \a pjsua_media_config.
    PJSUA_ICE_CONFIG_USE_DEFAULT = 0,
    /// Use the custom \a pjsua_ice_config setting in the account.
    PJSUA_ICE_CONFIG_USE_CUSTOM = 1,
}

#[repr(u32)]
/// This enumeration controls the use of TURN settings in the account.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsua_turn_config_use {
    /// Use the default setting in the global \a pjsua_media_config.
    PJSUA_TURN_CONFIG_USE_DEFAULT = 0,
    /// Use the custom \a pjsua_turn_config setting in the account.
    PJSUA_TURN_CONFIG_USE_CUSTOM = 1,
}

/// ICE setting. This setting is used in the pjsua_acc_config.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsua_ice_config {
    /// Enable ICE.
    pub enable_ice: pj_bool_t,
    /// Set the maximum number of host candidates.
    ///
    /// Default: -1 (maximum not set)
    pub ice_max_host_cands: ::std::os::raw::c_int,
    /// ICE session options.
    pub ice_opt: pj_ice_sess_options,
    /// Disable RTCP component.
    ///
    /// Default: no
    pub ice_no_rtcp: pj_bool_t,
    /// Send re-INVITE/UPDATE every after ICE connectivity check regardless
    /// the default ICE transport address is changed or not. When this is set
    /// to PJ_FALSE, re-INVITE/UPDATE will be sent only when the default ICE
    /// transport address is changed.
    ///
    /// Default: yes
    pub ice_always_update: pj_bool_t,
}

/// TURN setting. This setting is used in the pjsua_acc_config.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsua_turn_config {
    /// Enable TURN candidate in ICE.
    pub enable_turn: pj_bool_t,
    /// Specify TURN domain name or host name, in in "DOMAIN:PORT" or
    /// "HOST:PORT" format.
    pub turn_server: pj_str_t,
    /// Specify the connection type to be used to the TURN server. Valid
    /// values are PJ_TURN_TP_UDP or PJ_TURN_TP_TCP.
    ///
    /// Default: PJ_TURN_TP_UDP
    pub turn_conn_type: pj_turn_tp_type,
    /// Specify the credential to authenticate with the TURN server.
    pub turn_auth_cred: pj_stun_auth_cred,
}

#[repr(u32)]
/// Specify how IPv6 transport should be used in account config.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsua_ipv6_use {
    /// IPv6 is not used.
    PJSUA_IPV6_DISABLED = 0,
    /// IPv6 is enabled.
    PJSUA_IPV6_ENABLED = 1,
}

#[repr(u32)]
/// Specify NAT64 options to be used in account config.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsua_nat64_opt {
    /// NAT64 is not used.
    PJSUA_NAT64_DISABLED = 0,
    /// NAT64 is enabled.
    PJSUA_NAT64_ENABLED = 1,
}

/// This structure describes account configuration to be specified when
/// adding a new account with #pjsua_acc_add(). Application MUST initialize
/// this structure first by calling #pjsua_acc_config_default().
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsua_acc_config {
    /// Arbitrary user data to be associated with the newly created account.
    /// Application may set this later with #pjsua_acc_set_user_data() and
    /// retrieve it with #pjsua_acc_get_user_data().
    pub user_data: *mut ::std::os::raw::c_void,
    /// Account priority, which is used to control the order of matching
    /// incoming/outgoing requests. The higher the number means the higher
    /// the priority is, and the account will be matched first.
    pub priority: ::std::os::raw::c_int,
    /// The full SIP URL for the account. The value can take name address or
    /// URL format, and will look something like "sip:account@serviceprovider"
    /// or "\"Display Name\" <sip:account@provider>".
    ///
    /// This field is mandatory.
    pub id: pj_str_t,
    /// This is the URL to be put in the request URI for the registration,
    /// and will look something like "sip:serviceprovider".
    ///
    /// This field should be specified if registration is desired. If the
    /// value is empty, no account registration will be performed.
    pub reg_uri: pj_str_t,
    /// The optional custom SIP headers to be put in the registration
    /// request.
    pub reg_hdr_list: pjsip_hdr,
    /// Additional parameters that will be appended in the Contact header
    /// for this account. This will only affect REGISTER requests and
    /// will be appended after \a contact_params;
    ///
    /// The parameters should be preceeded by semicolon, and all strings must
    /// be properly escaped. Example:
    /// ";my-param=X;another-param=Hi%20there"
    pub reg_contact_params: pj_str_t,
    /// The optional custom SIP headers to be put in the presence
    /// subscription request.
    pub sub_hdr_list: pjsip_hdr,
    /// Subscribe to message waiting indication events (RFC 3842).
    ///
    /// See also \a enable_unsolicited_mwi field on #pjsua_config.
    ///
    /// Default: no
    pub mwi_enabled: pj_bool_t,
    /// Specify the default expiration time for Message Waiting Indication
    /// (RFC 3842) event subscription. This must not be zero.
    ///
    /// Default: PJSIP_MWI_DEFAULT_EXPIRES
    pub mwi_expires: ::std::os::raw::c_uint,
    /// If this flag is set, the presence information of this account will
    /// be PUBLISH-ed to the server where the account belongs.
    ///
    /// Default: PJ_FALSE
    pub publish_enabled: pj_bool_t,
    /// Event publication options.
    pub publish_opt: pjsip_publishc_opt,
    /// Maximum time to wait for unpublication transaction(s) to complete
    /// during shutdown process, before sending unregistration. The library
    /// tries to wait for the unpublication (un-PUBLISH) to complete before
    /// sending REGISTER request to unregister the account, during library
    /// shutdown process. If the value is set too short, it is possible that
    /// the unregistration is sent before unpublication completes, causing
    /// unpublication request to fail.
    ///
    /// Default: PJSUA_UNPUBLISH_MAX_WAIT_TIME_MSEC
    pub unpublish_max_wait_time_msec: ::std::os::raw::c_uint,
    /// Authentication preference.
    pub auth_pref: pjsip_auth_clt_pref,
    /// Optional PIDF tuple ID for outgoing PUBLISH and NOTIFY. If this value
    /// is not specified, a random string will be used.
    pub pidf_tuple_id: pj_str_t,
    /// Optional URI to be put as Contact for this account. It is recommended
    /// that this field is left empty, so that the value will be calculated
    /// automatically based on the transport address.
    pub force_contact: pj_str_t,
    /// Additional parameters that will be appended in the Contact header
    /// for this account. This will affect the Contact header in all SIP
    /// messages sent on behalf of this account, including but not limited to
    /// REGISTER, INVITE, and SUBCRIBE requests or responses.
    ///
    /// The parameters should be preceeded by semicolon, and all strings must
    /// be properly escaped. Example:
    /// ";my-param=X;another-param=Hi%20there"
    pub contact_params: pj_str_t,
    /// Additional URI parameters that will be appended in the Contact URI
    /// for this account. This will affect the Contact URI in all SIP
    /// messages sent on behalf of this account, including but not limited to
    /// REGISTER, INVITE, and SUBCRIBE requests or responses.
    ///
    /// The parameters should be preceeded by semicolon, and all strings must
    /// be properly escaped. Example:
    /// ";my-param=X;another-param=Hi%20there"
    pub contact_uri_params: pj_str_t,
    /// Specify how support for reliable provisional response (100rel/
    /// PRACK) should be used for all sessions in this account. See the
    /// documentation of pjsua_100rel_use enumeration for more info.
    ///
    /// Default: The default value is taken from the value of
    /// require_100rel in pjsua_config.
    pub require_100rel: pjsua_100rel_use,
    /// Specify the usage of Session Timers for all sessions. See the
    /// #pjsua_sip_timer_use for possible values.
    ///
    /// Default: PJSUA_SIP_TIMER_OPTIONAL
    pub use_timer: pjsua_sip_timer_use,
    /// Specify Session Timer settings, see #pjsip_timer_setting.
    pub timer_setting: pjsip_timer_setting,
    /// Number of proxies in the proxy array below.
    pub proxy_cnt: ::std::os::raw::c_uint,
    /// Optional URI of the proxies to be visited for all outgoing requests
    /// that are using this account (REGISTER, INVITE, etc). Application need
    /// to specify these proxies if the service provider requires that requests
    /// destined towards its network should go through certain proxies first
    /// (for example, border controllers).
    ///
    /// These proxies will be put in the route set for this account, with
    /// maintaining the orders (the first proxy in the array will be visited
    /// first). If global outbound proxies are configured in pjsua_config,
    /// then these account proxies will be placed after the global outbound
    /// proxies in the routeset.
    pub proxy: [pj_str_t; 8usize],
    /// If remote sends SDP answer containing more than one format or codec in
    /// the media line, send re-INVITE or UPDATE with just one codec to lock
    /// which codec to use.
    ///
    /// Default: 1 (Yes). Set to zero to disable.
    pub lock_codec: ::std::os::raw::c_uint,
    /// Optional interval for registration, in seconds. If the value is zero,
    /// default interval will be used (PJSUA_REG_INTERVAL, 300 seconds).
    pub reg_timeout: ::std::os::raw::c_uint,
    /// Specify the number of seconds to refresh the client registration
    /// before the registration expires.
    ///
    /// Default: PJSIP_REGISTER_CLIENT_DELAY_BEFORE_REFRESH, 5 seconds
    pub reg_delay_before_refresh: ::std::os::raw::c_uint,
    /// Specify the maximum time to wait for unregistration requests to
    /// complete during library shutdown sequence.
    ///
    /// Default: PJSUA_UNREG_TIMEOUT
    pub unreg_timeout: ::std::os::raw::c_uint,
    /// Number of credentials in the credential array.
    pub cred_count: ::std::os::raw::c_uint,
    /// Array of credentials. If registration is desired, normally there should
    /// be at least one credential specified, to successfully authenticate
    /// against the service provider. More credentials can be specified, for
    /// example when the requests are expected to be challenged by the
    /// proxies in the route set.
    pub cred_info: [pjsip_cred_info; 8usize],
    /// Optionally bind this account to specific transport. This normally is
    /// not a good idea, as account should be able to send requests using
    /// any available transports according to the destination. But some
    /// application may want to have explicit control over the transport to
    /// use, so in that case it can set this field.
    ///
    /// Default: -1 (PJSUA_INVALID_ID)
    ///
    /// @see pjsua_acc_set_transport()
    pub transport_id: pjsua_transport_id,
    /// This option is used to update the transport address and the Contact
    /// header of REGISTER request. When this option is  enabled, the library
    /// will keep track of the public IP address from the response of REGISTER
    /// request. Once it detects that the address has changed, it will
    /// unregister current Contact, update the Contact with transport address
    /// learned from Via header, and register a new Contact to the registrar.
    /// This will also update the public name of UDP transport if STUN is
    /// configured.
    ///
    /// See also contact_rewrite_method field.
    ///
    /// Default: 1 (yes)
    pub allow_contact_rewrite: pj_bool_t,
    /// Specify how Contact update will be done with the registration, if
    /// \a allow_contact_rewrite is enabled. The value is bitmask combination of
    /// \a pjsua_contact_rewrite_method. See also pjsua_contact_rewrite_method.
    ///
    /// Value PJSUA_CONTACT_REWRITE_UNREGISTER(1) is the legacy behavior.
    ///
    /// Default value: PJSUA_CONTACT_REWRITE_METHOD
    /// (PJSUA_CONTACT_REWRITE_NO_UNREG | PJSUA_CONTACT_REWRITE_ALWAYS_UPDATE)
    pub contact_rewrite_method: ::std::os::raw::c_int,
    /// Specify if source TCP port should be used as the initial Contact
    /// address if TCP/TLS transport is used. Note that this feature will
    /// be automatically turned off when nameserver is configured because
    /// it may yield different destination address due to DNS SRV resolution.
    /// Also some platforms are unable to report the local address of the
    /// TCP socket when it is still connecting. In these cases, this
    /// feature will also be turned off.
    ///
    /// Default: PJ_TRUE (yes).
    pub contact_use_src_port: pj_bool_t,
    /// This option is used to overwrite the "sent-by" field of the Via header
    /// for outgoing messages with the same interface address as the one in
    /// the REGISTER request, as long as the request uses the same transport
    /// instance as the previous REGISTER request.
    ///
    /// Default: 1 (yes)
    pub allow_via_rewrite: pj_bool_t,
    /// This option controls whether the IP address in SDP should be replaced
    /// with the IP address found in Via header of the REGISTER response, ONLY
    /// when STUN and ICE are not used. If the value is FALSE (the original
    /// behavior), then the local IP address will be used. If TRUE, and when
    /// STUN and ICE are disabled, then the IP address found in registration
    /// response will be used.
    ///
    /// Default: PJ_FALSE (no)
    pub allow_sdp_nat_rewrite: pj_bool_t,
    /// Control the use of SIP outbound feature. SIP outbound is described in
    /// RFC 5626 to enable proxies or registrar to send inbound requests back
    /// to UA using the same connection initiated by the UA for its
    /// registration. This feature is highly useful in NAT-ed deployemtns,
    /// hence it is enabled by default.
    ///
    /// Note: currently SIP outbound can only be used with TCP and TLS
    /// transports. If UDP is used for the registration, the SIP outbound
    /// feature will be silently ignored for the account.
    ///
    /// Default: PJ_TRUE
    pub use_rfc5626: ::std::os::raw::c_uint,
    /// Specify SIP outbound (RFC 5626) instance ID to be used by this
    /// application. If empty, an instance ID will be generated based on
    /// the hostname of this agent. If application specifies this parameter, the
    /// value will look like "<urn:uuid:00000000-0000-1000-8000-AABBCCDDEEFF>"
    /// without the doublequote.
    ///
    /// Default: empty
    pub rfc5626_instance_id: pj_str_t,
    /// Specify SIP outbound (RFC 5626) registration ID. The default value
    /// is empty, which would cause the library to automatically generate
    /// a suitable value.
    ///
    /// Default: empty
    pub rfc5626_reg_id: pj_str_t,
    /// Set the interval for periodic keep-alive transmission for this account.
    /// If this value is zero, keep-alive will be disabled for this account.
    /// The keep-alive transmission will be sent to the registrar's address,
    /// after successful registration.
    ///
    /// Default: 15 (seconds)
    pub ka_interval: ::std::os::raw::c_uint,
    /// Specify the data to be transmitted as keep-alive packets.
    ///
    /// Default: CR-LF
    pub ka_data: pj_str_t,
    /// Specify whether incoming video should be shown to screen by default.
    /// This applies to incoming call (INVITE), incoming re-INVITE, and
    /// incoming UPDATE requests.
    ///
    /// Regardless of this setting, application can detect incoming video
    /// by implementing \a on_call_media_state() callback and enumerating
    /// the media stream(s) with #pjsua_call_get_info(). Once incoming
    /// video is recognised, application may retrieve the window associated
    /// with the incoming video and show or hide it with
    /// #pjsua_vid_win_set_show().
    ///
    /// Default: PJ_FALSE
    pub vid_in_auto_show: pj_bool_t,
    /// Specify whether outgoing video should be activated by default when
    /// making outgoing calls and/or when incoming video is detected. This
    /// applies to incoming and outgoing calls, incoming re-INVITE, and
    /// incoming UPDATE. If the setting is non-zero, outgoing video
    /// transmission will be started as soon as response to these requests
    /// is sent (or received).
    ///
    /// Regardless of the value of this setting, application can start and
    /// stop outgoing video transmission with #pjsua_call_set_vid_strm().
    ///
    /// Default: PJ_FALSE
    pub vid_out_auto_transmit: pj_bool_t,
    /// Specify video window's flags. The value is a bitmask combination of
    /// #pjmedia_vid_dev_wnd_flag.
    ///
    /// Default: 0
    pub vid_wnd_flags: ::std::os::raw::c_uint,
    /// Specify the default capture device to be used by this account. If
    /// \a vid_out_auto_transmit is enabled, this device will be used for
    /// capturing video.
    ///
    /// Default: PJMEDIA_VID_DEFAULT_CAPTURE_DEV
    pub vid_cap_dev: pjmedia_vid_dev_index,
    /// Specify the default rendering device to be used by this account.
    ///
    /// Default: PJMEDIA_VID_DEFAULT_RENDER_DEV
    pub vid_rend_dev: pjmedia_vid_dev_index,
    /// Specify the send rate control for video stream.
    ///
    /// Default: see #pjmedia_vid_stream_rc_config
    pub vid_stream_rc_cfg: pjmedia_vid_stream_rc_config,
    /// Specify the send keyframe config for video stream.
    ///
    /// Default: see #pjmedia_vid_stream_sk_config
    pub vid_stream_sk_cfg: pjmedia_vid_stream_sk_config,
    /// Media transport config.
    pub rtp_cfg: pjsua_transport_config,
    /// Specify NAT64 options.
    ///
    /// Default: PJSUA_NAT64_DISABLED
    pub nat64_opt: pjsua_nat64_opt,
    /// Specify whether IPv6 should be used on media.
    pub ipv6_media_use: pjsua_ipv6_use,
    /// Control the use of STUN for the SIP signaling.
    ///
    /// Default: PJSUA_STUN_USE_DEFAULT
    pub sip_stun_use: pjsua_stun_use,
    /// Control the use of STUN for the media transports.
    ///
    /// Default: PJSUA_STUN_RETRY_ON_FAILURE
    pub media_stun_use: pjsua_stun_use,
    /// Control the use of ICE in the account. By default, the settings in the
    /// \a pjsua_media_config will be used.
    ///
    /// Default: PJSUA_ICE_CONFIG_USE_DEFAULT
    pub ice_cfg_use: pjsua_ice_config_use,
    /// The custom ICE setting for this account. This setting will only be
    /// used if \a ice_cfg_use is set to PJSUA_ICE_CONFIG_USE_CUSTOM
    pub ice_cfg: pjsua_ice_config,
    /// Control the use of TURN in the account. By default, the settings in the
    /// \a pjsua_media_config will be used
    ///
    /// Default: PJSUA_TURN_CONFIG_USE_DEFAULT
    pub turn_cfg_use: pjsua_turn_config_use,
    /// The custom TURN setting for this account. This setting will only be
    /// used if \a turn_cfg_use is set to PJSUA_TURN_CONFIG_USE_CUSTOM
    pub turn_cfg: pjsua_turn_config,
    /// Specify whether secure media transport should be used for this account.
    /// Valid values are PJMEDIA_SRTP_DISABLED, PJMEDIA_SRTP_OPTIONAL, and
    /// PJMEDIA_SRTP_MANDATORY.
    ///
    /// Default: #PJSUA_DEFAULT_USE_SRTP
    pub use_srtp: pjmedia_srtp_use,
    /// Specify whether SRTP requires secure signaling to be used. This option
    /// is only used when \a use_srtp option above is non-zero.
    ///
    /// Valid values are:
    /// 0: SRTP does not require secure signaling
    /// 1: SRTP requires secure transport such as TLS
    /// 2: SRTP requires secure end-to-end transport (SIPS)
    ///
    /// Default: #PJSUA_DEFAULT_SRTP_SECURE_SIGNALING
    pub srtp_secure_signaling: ::std::os::raw::c_int,
    /// This setting has been deprecated and will be ignored.
    pub srtp_optional_dup_offer: pj_bool_t,
    /// Specify interval of auto registration retry upon registration failure,
    /// in seconds. Set to 0 to disable auto re-registration. Note that
    /// registration will only be automatically retried for temporal failures
    /// considered to be recoverable in relatively short term, such as:
    /// 408 (Request Timeout), 480 (Temporarily Unavailable),
    /// 500 (Internal Server Error), 502 (Bad Gateway),
    /// 503 (Service Unavailable), 504 (Server Timeout),
    /// 6xx (global failure), and failure caused by transport problem.
    /// For registration retry caused by transport failure, the first retry
    /// will be done after \a reg_first_retry_interval seconds instead.
    /// Note that the interval will be randomized slightly by some seconds
    /// (specified in \a reg_retry_random_interval) to avoid all clients
    /// re-registering at the same time.
    ///
    /// See also \a reg_first_retry_interval setting.
    ///
    /// Default: #PJSUA_REG_RETRY_INTERVAL
    pub reg_retry_interval: ::std::os::raw::c_uint,
    /// This specifies the interval for the first registration retry. The
    /// registration retry is explained in \a reg_retry_interval. Note that
    /// the value here will also be randomized by some seconds (specified
    /// in \a reg_retry_random_interval) to avoid all clients re-registering
    /// at the same time.
    ///
    /// Default: 0
    pub reg_first_retry_interval: ::std::os::raw::c_uint,
    /// This specifies maximum randomized value to be added/substracted
    /// to/from the registration retry interval specified in \a
    /// reg_retry_interval and \a reg_first_retry_interval, in second.
    /// This is useful to avoid all clients re-registering at the same time.
    /// For example, if the registration retry interval is set to 100 seconds
    /// and this is set to 10 seconds, the actual registration retry interval
    /// will be in the range of 90 to 110 seconds.
    ///
    /// Default: 10
    pub reg_retry_random_interval: ::std::os::raw::c_uint,
    /// Specify whether calls of the configured account should be dropped
    /// after registration failure and an attempt of re-registration has
    /// also failed.
    ///
    /// Default: PJ_FALSE (disabled)
    pub drop_calls_on_reg_fail: pj_bool_t,
    /// Specify how the registration uses the outbound and account proxy
    /// settings. This controls if and what Route headers will appear in
    /// the REGISTER request of this account. The value is bitmask combination
    /// of PJSUA_REG_USE_OUTBOUND_PROXY and PJSUA_REG_USE_ACC_PROXY bits.
    /// If the value is set to 0, the REGISTER request will not use any proxy
    /// (i.e. it will not have any Route headers).
    ///
    /// Default: 3 (PJSUA_REG_USE_OUTBOUND_PROXY | PJSUA_REG_USE_ACC_PROXY)
    pub reg_use_proxy: ::std::os::raw::c_uint,
    /// Specify how to offer call hold to remote peer. Please see the
    /// documentation on #pjsua_call_hold_type for more info.
    ///
    /// Default: PJSUA_CALL_HOLD_TYPE_DEFAULT
    pub call_hold_type: pjsua_call_hold_type,
    /// Specify whether the account should register as soon as it is
    /// added to the UA. Application can set this to PJ_FALSE and control
    /// the registration manually with pjsua_acc_set_registration().
    ///
    /// Default: PJ_TRUE
    pub register_on_acc_add: pj_bool_t,
    /// Specify account configuration specific to IP address change used when
    /// calling #pjsua_handle_ip_change().
    pub ip_change_cfg: pjsua_ip_change_acc_cfg,
}

extern "C" {
    /// Initialize ICE config from a media config. If the \a pool argument
/// is NULL, a simple memcpy() will be used.
///
/// @param pool	    Memory to duplicate strings.
/// @param dst	    Destination config.
/// @param src	    Source config.
    pub fn pjsua_ice_config_from_media_config(pool: *mut pj_pool_t, dst: *mut pjsua_ice_config, src: *const pjsua_media_config);
}

extern "C" {
    /// Clone. If the \a pool argument is NULL, a simple memcpy() will be used.
///
/// @param pool	    Memory to duplicate strings.
/// @param dst	    Destination config.
/// @param src	    Source config.
    pub fn pjsua_ice_config_dup(pool: *mut pj_pool_t, dst: *mut pjsua_ice_config, src: *const pjsua_ice_config);
}

extern "C" {
    /// Initialize TURN config from a media config. If the \a pool argument
/// is NULL, a simple memcpy() will be used.
///
/// @param pool	    Memory to duplicate strings.
/// @param dst	    Destination config.
/// @param src	    Source config.
    pub fn pjsua_turn_config_from_media_config(pool: *mut pj_pool_t, dst: *mut pjsua_turn_config, src: *const pjsua_media_config);
}

extern "C" {
    /// Clone. If the \a pool argument is NULL, a simple memcpy() will be used.
///
/// @param pool	    Memory to duplicate strings.
/// @param dst	    Destination config.
/// @param src	    Source config.
    pub fn pjsua_turn_config_dup(pool: *mut pj_pool_t, dst: *mut pjsua_turn_config, src: *const pjsua_turn_config);
}

extern "C" {
    /// Call this function to initialize account config with default values.
///
/// @param cfg	    The account config to be initialized.
    pub fn pjsua_acc_config_default(cfg: *mut pjsua_acc_config);
}

extern "C" {
    /// Duplicate account config.
///
/// @param pool	    Pool to be used for duplicating the config.
/// @param dst	    Destination configuration.
/// @param src	    Source configuration.
    pub fn pjsua_acc_config_dup(pool: *mut pj_pool_t, dst: *mut pjsua_acc_config, src: *const pjsua_acc_config);
}

/// Account info. Application can query account info by calling
/// #pjsua_acc_get_info().
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsua_acc_info {
    /// The account ID.
    pub id: pjsua_acc_id,
    /// Flag to indicate whether this is the default account.
    pub is_default: pj_bool_t,
    /// Account URI
    pub acc_uri: pj_str_t,
    /// Flag to tell whether this account has registration setting
    /// (reg_uri is not empty).
    pub has_registration: pj_bool_t,
    /// An up to date expiration interval for account registration session.
    pub expires: ::std::os::raw::c_int,
    /// Last registration status code. If status code is zero, the account
    /// is currently not registered. Any other value indicates the SIP
    /// status code of the registration.
    pub status: pjsip_status_code,
    /// Last registration error code. When the status field contains a SIP
    /// status code that indicates a registration failure, last registration
    /// error code contains the error code that causes the failure. In any
    /// other case, its value is zero.
    pub reg_last_err: pj_status_t,
    /// String describing the registration status.
    pub status_text: pj_str_t,
    /// Presence online status for this account.
    pub online_status: pj_bool_t,
    /// Presence online status text.
    pub online_status_text: pj_str_t,
    /// Extended RPID online status information.
    pub rpid: pjrpid_element,
    /// Buffer that is used internally to store the status text.
    pub buf_: [::std::os::raw::c_char; 80usize],
}

extern "C" {
    /// Get number of current accounts.
///
/// @return		Current number of accounts.
    pub fn pjsua_acc_get_count() -> ::std::os::raw::c_uint;
}

extern "C" {
    /// Check if the specified account ID is valid.
///
/// @param acc_id	Account ID to check.
///
/// @return		Non-zero if account ID is valid.
    pub fn pjsua_acc_is_valid(acc_id: pjsua_acc_id) -> pj_bool_t;
}

extern "C" {
    /// Set default account to be used when incoming and outgoing
/// requests doesn't match any accounts.
///
/// @param acc_id	The account ID to be used as default.
///
/// @return		PJ_SUCCESS on success.
    pub fn pjsua_acc_set_default(acc_id: pjsua_acc_id) -> pj_status_t;
}

extern "C" {
    /// Get default account to be used when receiving incoming requests (calls),
/// when the destination of the incoming call doesn't match any other
/// accounts.
///
/// @return		The default account ID, or PJSUA_INVALID_ID if no
/// default account is configured.
    pub fn pjsua_acc_get_default() -> pjsua_acc_id;
}

extern "C" {
    /// Add a new account to pjsua. PJSUA must have been initialized (with
/// #pjsua_init()) before calling this function. If registration is configured
/// for this account, this function would also start the SIP registration
/// session with the SIP registrar server. This SIP registration session
/// will be maintained internally by the library, and application doesn't
/// need to do anything to maintain the registration session.
///
///
/// @param acc_cfg	Account configuration.
/// @param is_default	If non-zero, this account will be set as the default
/// account. The default account will be used when sending
/// outgoing requests (e.g. making call) when no account is
/// specified, and when receiving incoming requests when the
/// request does not match any accounts. It is recommended
/// that default account is set to local/LAN account.
/// @param p_acc_id	Pointer to receive account ID of the new account.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_acc_add(acc_cfg: *const pjsua_acc_config, is_default: pj_bool_t, p_acc_id: *mut pjsua_acc_id) -> pj_status_t;
}

extern "C" {
    /// Add a local account. A local account is used to identify local endpoint
/// instead of a specific user, and for this reason, a transport ID is needed
/// to obtain the local address information.
///
/// @param tid		Transport ID to generate account address.
/// @param is_default	If non-zero, this account will be set as the default
/// account. The default account will be used when sending
/// outgoing requests (e.g. making call) when no account is
/// specified, and when receiving incoming requests when the
/// request does not match any accounts. It is recommended
/// that default account is set to local/LAN account.
/// @param p_acc_id	Pointer to receive account ID of the new account.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_acc_add_local(tid: pjsua_transport_id, is_default: pj_bool_t, p_acc_id: *mut pjsua_acc_id) -> pj_status_t;
}

extern "C" {
    /// Set arbitrary data to be associated with the account.
///
/// @param acc_id	The account ID.
/// @param user_data	User/application data.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_acc_set_user_data(acc_id: pjsua_acc_id, user_data: *mut ::std::os::raw::c_void) -> pj_status_t;
}

extern "C" {
    /// Retrieve arbitrary data associated with the account.
///
/// @param acc_id	The account ID.
///
/// @return		The user data. In the case where the account ID is
/// not valid, NULL is returned.
    pub fn pjsua_acc_get_user_data(acc_id: pjsua_acc_id) -> *mut ::std::os::raw::c_void;
}

extern "C" {
    /// Delete an account. This will unregister the account from the SIP server,
/// if necessary, and terminate server side presence subscriptions associated
/// with this account.
///
/// @param acc_id	Id of the account to be deleted.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_acc_del(acc_id: pjsua_acc_id) -> pj_status_t;
}

extern "C" {
    /// Get current config for the account. This will copy current account setting
/// to the specified parameter. Note that all pointers in the settings will
/// point to the original settings in the account and application must not
/// modify the values in any way. Application must also take care that these
/// data is only valid until the account is destroyed.
///
/// @param acc_id	The account ID.
/// @param pool		Pool to duplicate the config.
/// @param acc_cfg	Structure to receive the settings.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_acc_get_config(acc_id: pjsua_acc_id, pool: *mut pj_pool_t, acc_cfg: *mut pjsua_acc_config) -> pj_status_t;
}

extern "C" {
    /// Modify account configuration setting. This function may trigger
/// unregistration (of old account setting) and re-registration (of the new
/// account setting), e.g: changing account ID, credential, registar, or
/// proxy setting.
///
/// Note:
/// - when the new config triggers unregistration, the pjsua callback
/// on_reg_state()/on_reg_state2() for the unregistration will not be called
/// and any failure in the unregistration will be ignored, so if application
/// needs to be sure about the unregistration status, it should unregister
/// manually and wait for the callback before calling this function
/// - when the new config triggers re-registration and the re-registration
/// fails, the account setting will not be reverted back to the old setting
/// and the account will be in unregistered state.
///
/// @param acc_id	Id of the account to be modified.
/// @param acc_cfg	New account configuration.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_acc_modify(acc_id: pjsua_acc_id, acc_cfg: *const pjsua_acc_config) -> pj_status_t;
}

extern "C" {
    /// Modify account's presence status to be advertised to remote/presence
/// subscribers. This would trigger the sending of outgoing NOTIFY request
/// if there are server side presence subscription for this account, and/or
/// outgoing PUBLISH if presence publication is enabled for this account.
///
/// @see pjsua_acc_set_online_status2()
///
/// @param acc_id	The account ID.
/// @param is_online	True of false.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_acc_set_online_status(acc_id: pjsua_acc_id, is_online: pj_bool_t) -> pj_status_t;
}

extern "C" {
    /// Modify account's presence status to be advertised to remote/presence
/// subscribers. This would trigger the sending of outgoing NOTIFY request
/// if there are server side presence subscription for this account, and/or
/// outgoing PUBLISH if presence publication is enabled for this account.
///
/// @see pjsua_acc_set_online_status()
///
/// @param acc_id	The account ID.
/// @param is_online	True of false.
/// @param pr		Extended information in subset of RPID format
/// which allows setting custom presence text.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_acc_set_online_status2(acc_id: pjsua_acc_id, is_online: pj_bool_t, pr: *const pjrpid_element) -> pj_status_t;
}

extern "C" {
    /// Update registration or perform unregistration. If registration is
/// configured for this account, then initial SIP REGISTER will be sent
/// when the account is added with #pjsua_acc_add(). Application normally
/// only need to call this function if it wants to manually update the
/// registration or to unregister from the server.
///
/// @param acc_id	The account ID.
/// @param renew		If renew argument is zero, this will start
/// unregistration process.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_acc_set_registration(acc_id: pjsua_acc_id, renew: pj_bool_t) -> pj_status_t;
}

extern "C" {
    /// Get information about the specified account.
///
/// @param acc_id	Account identification.
/// @param info		Pointer to receive account information.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_acc_get_info(acc_id: pjsua_acc_id, info: *mut pjsua_acc_info) -> pj_status_t;
}

extern "C" {
    /// Enumerate all account currently active in the library. This will fill
/// the array with the account Ids, and application can then query the
/// account information for each id with #pjsua_acc_get_info().
///
/// @see pjsua_acc_enum_info().
///
/// @param ids		Array of account IDs to be initialized.
/// @param count		In input, specifies the maximum number of elements.
/// On return, it contains the actual number of elements.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_enum_accs(ids: *mut pjsua_acc_id, count: *mut ::std::os::raw::c_uint) -> pj_status_t;
}

extern "C" {
    /// Enumerate account informations.
///
/// @param info		Array of account infos to be initialized.
/// @param count		In input, specifies the maximum number of elements.
/// On return, it contains the actual number of elements.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_acc_enum_info(info: *mut pjsua_acc_info, count: *mut ::std::os::raw::c_uint) -> pj_status_t;
}

extern "C" {
    /// This is an internal function to find the most appropriate account to
/// used to reach to the specified URL.
///
/// @param url		The remote URL to reach.
///
/// @return		Account id.
    pub fn pjsua_acc_find_for_outgoing(url: *const pj_str_t) -> pjsua_acc_id;
}

extern "C" {
    /// This is an internal function to find the most appropriate account to be
/// used to handle incoming calls.
///
/// @param rdata		The incoming request message.
///
/// @return		Account id.
    pub fn pjsua_acc_find_for_incoming(rdata: *mut pjsip_rx_data) -> pjsua_acc_id;
}

extern "C" {
    /// Create arbitrary requests using the account. Application should only use
/// this function to create auxiliary requests outside dialog, such as
/// OPTIONS, and use the call or presence API to create dialog related
/// requests.
///
/// @param acc_id	The account ID.
/// @param method	The SIP method of the request.
/// @param target	Target URI.
/// @param p_tdata	Pointer to receive the request.
///
/// @return		PJ_SUCCESS or the error code.
    pub fn pjsua_acc_create_request(acc_id: pjsua_acc_id, method: *const pjsip_method, target: *const pj_str_t, p_tdata: *mut *mut pjsip_tx_data) -> pj_status_t;
}

extern "C" {
    /// Create a suitable Contact header value, based on the specified target URI
/// for the specified account.
///
/// @param pool		Pool to allocate memory for the string.
/// @param contact	The string where the Contact will be stored.
/// @param acc_id	Account ID.
/// @param uri		Destination URI of the request.
///
/// @return		PJ_SUCCESS on success, other on error.
    pub fn pjsua_acc_create_uac_contact(pool: *mut pj_pool_t, contact: *mut pj_str_t, acc_id: pjsua_acc_id, uri: *const pj_str_t) -> pj_status_t;
}

extern "C" {
    /// Create a suitable Contact header value, based on the information in the
/// incoming request.
///
/// @param pool		Pool to allocate memory for the string.
/// @param contact	The string where the Contact will be stored.
/// @param acc_id	Account ID.
/// @param rdata		Incoming request.
///
/// @return		PJ_SUCCESS on success, other on error.
    pub fn pjsua_acc_create_uas_contact(pool: *mut pj_pool_t, contact: *mut pj_str_t, acc_id: pjsua_acc_id, rdata: *mut pjsip_rx_data) -> pj_status_t;
}

extern "C" {
    /// Lock/bind this account to a specific transport/listener. Normally
/// application shouldn't need to do this, as transports will be selected
/// automatically by the stack according to the destination.
///
/// When account is locked/bound to a specific transport, all outgoing
/// requests from this account will use the specified transport (this
/// includes SIP registration, dialog (call and event subscription), and
/// out-of-dialog requests such as MESSAGE).
///
/// Note that transport_id may be specified in pjsua_acc_config too.
///
/// @param acc_id	The account ID.
/// @param tp_id		The transport ID.
///
/// @return		PJ_SUCCESS on success.
    pub fn pjsua_acc_set_transport(acc_id: pjsua_acc_id, tp_id: pjsua_transport_id) -> pj_status_t;
}

/// Video window ID.
pub type pjsua_vid_win_id = ::std::os::raw::c_int;

#[repr(u32)]
/// This enumeration specifies the media status of a call, and it's part
/// of pjsua_call_info structure.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsua_call_media_status {
    /// Call currently has no media, or the media is not used.
    PJSUA_CALL_MEDIA_NONE = 0,
    /// The media is active
    PJSUA_CALL_MEDIA_ACTIVE = 1,
    /// The media is currently put on hold by local endpoint
    PJSUA_CALL_MEDIA_LOCAL_HOLD = 2,
    /// The media is currently put on hold by remote endpoint
    PJSUA_CALL_MEDIA_REMOTE_HOLD = 3,
    /// The media has reported error (e.g. ICE negotiation)
    PJSUA_CALL_MEDIA_ERROR = 4,
}

#[repr(u32)]
/// Enumeration of video keyframe request methods. Keyframe request is
/// triggered by decoder, usually when the incoming video stream cannot
/// be decoded properly due to missing video keyframe.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsua_vid_req_keyframe_method {
    /// Requesting keyframe via SIP INFO message. Note that incoming keyframe
    /// request via SIP INFO will always be handled even if this flag is unset.
    PJSUA_VID_REQ_KEYFRAME_SIP_INFO = 1,
    /// Requesting keyframe via Picture Loss Indication of RTCP feedback.
    /// This is currently not supported.
    PJSUA_VID_REQ_KEYFRAME_RTCP_PLI = 2,
}

/// Call media information.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsua_call_media_info {
    /// Media index in SDP.
    pub index: ::std::os::raw::c_uint,
    /// Media type.
    pub type_: pjmedia_type,
    /// Media direction.
    pub dir: pjmedia_dir,
    /// Call media status.
    pub status: pjsua_call_media_status,
    pub stream: pjsua_call_media_info__bindgen_ty_1,
}

/// The specific media stream info.
#[repr(C)]
#[derive(Copy, Clone)]
pub union pjsua_call_media_info__bindgen_ty_1 { pub aud: pjsua_call_media_info__bindgen_ty_1__bindgen_ty_1, pub vid: pjsua_call_media_info__bindgen_ty_1__bindgen_ty_2, _bindgen_union_align: [u32; 2usize] }

/// Audio stream
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsua_call_media_info__bindgen_ty_1__bindgen_ty_1 {
    /// The conference port number for the call.
    pub conf_slot: pjsua_conf_port_id,
}

/// Video stream
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsua_call_media_info__bindgen_ty_1__bindgen_ty_2 {
    /// The window id for incoming video, if any, or
    /// PJSUA_INVALID_ID.
    pub win_in: pjsua_vid_win_id,
    /// The video capture device for outgoing transmission,
    /// if any, or PJMEDIA_VID_INVALID_DEV
    pub cap_dev: pjmedia_vid_dev_index,
}

/// This structure describes the information and current status of a call.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsua_call_info {
    /// Call identification.
    pub id: pjsua_call_id,
    /// Initial call role (UAC == caller)
    pub role: pjsip_role_e,
    /// The account ID where this call belongs.
    pub acc_id: pjsua_acc_id,
    /// Local URI
    pub local_info: pj_str_t,
    /// Local Contact
    pub local_contact: pj_str_t,
    /// Remote URI
    pub remote_info: pj_str_t,
    /// Remote contact
    pub remote_contact: pj_str_t,
    /// Dialog Call-ID string.
    pub call_id: pj_str_t,
    /// Call setting
    pub setting: pjsua_call_setting,
    /// Call state
    pub state: pjsip_inv_state,
    /// Text describing the state
    pub state_text: pj_str_t,
    /// Last status code heard, which can be used as cause code
    pub last_status: pjsip_status_code,
    /// The reason phrase describing the status.
    pub last_status_text: pj_str_t,
    /// Media status of the first audio stream.
    pub media_status: pjsua_call_media_status,
    /// Media direction of the first audio stream.
    pub media_dir: pjmedia_dir,
    /// The conference port number for the first audio stream.
    pub conf_slot: pjsua_conf_port_id,
    /// Number of active media info in this call.
    pub media_cnt: ::std::os::raw::c_uint,
    /// Array of active media information.
    pub media: [pjsua_call_media_info; 16usize],
    /// Number of provisional media info in this call.
    pub prov_media_cnt: ::std::os::raw::c_uint,
    /// Array of provisional media information. This contains the media info
    /// in the provisioning state, that is when the media session is being
    /// created/updated (SDP offer/answer is on progress).
    pub prov_media: [pjsua_call_media_info; 16usize],
    /// Up-to-date call connected duration (zero when call is not
    /// established)
    pub connect_duration: pj_time_val,
    /// Total call duration, including set-up time
    pub total_duration: pj_time_val,
    /// Flag if remote was SDP offerer
    pub rem_offerer: pj_bool_t,
    /// Number of audio streams offered by remote
    pub rem_aud_cnt: ::std::os::raw::c_uint,
    /// Number of video streams offered by remote
    pub rem_vid_cnt: ::std::os::raw::c_uint,
    pub buf_: pjsua_call_info__bindgen_ty_1,
}

/// Internal
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsua_call_info__bindgen_ty_1 { pub local_info: [::std::os::raw::c_char; 256usize], pub local_contact: [::std::os::raw::c_char; 256usize], pub remote_info: [::std::os::raw::c_char; 256usize], pub remote_contact: [::std::os::raw::c_char; 256usize], pub call_id: [::std::os::raw::c_char; 128usize], pub last_status_text: [::std::os::raw::c_char; 128usize] }

#[repr(u32)]
/// Flags to be given to various call APIs. More than one flags may be
/// specified by bitmasking them.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsua_call_flag {
    /// When the call is being put on hold, specify this flag to unhold it.
    /// This flag is only valid for #pjsua_call_reinvite() and
    /// #pjsua_call_update(). Note: for compatibility reason, this flag must
    /// have value of 1 because previously the unhold option is specified as
    /// boolean value.
    PJSUA_CALL_UNHOLD = 1,
    /// Update the local invite session's contact with the contact URI from
    /// the account. This flag is only valid for #pjsua_call_set_hold2(),
    /// #pjsua_call_reinvite() and #pjsua_call_update(). This flag is useful
    /// in IP address change situation, after the local account's Contact has
    /// been updated (typically with re-registration) use this flag to update
    /// the invite session with the new Contact and to inform this new Contact
    /// to the remote peer with the outgoing re-INVITE or UPDATE.
    PJSUA_CALL_UPDATE_CONTACT = 2,
    /// Include SDP "m=" line with port set to zero for each disabled media
    /// (i.e when aud_cnt or vid_cnt is set to zero). This flag is only valid
    /// for #pjsua_call_make_call(), #pjsua_call_reinvite(), and
    /// #pjsua_call_update(). Note that even this flag is applicable in
    /// #pjsua_call_reinvite() and #pjsua_call_update(), it will only take
    /// effect when the re-INVITE/UPDATE operation regenerates SDP offer,
    /// such as changing audio or video count in the call setting.
    PJSUA_CALL_INCLUDE_DISABLED_MEDIA = 4,
    /// Do not send SDP when sending INVITE or UPDATE. This flag is only valid
    /// for #pjsua_call_make_call(), #pjsua_call_reinvite()/reinvite2(), or
    /// #pjsua_call_update()/update2(). For re-invite/update, specifying
    /// PJSUA_CALL_UNHOLD will take precedence over this flag.
    PJSUA_CALL_NO_SDP_OFFER = 8,
    /// Deinitialize and recreate media, including media transport. This flag
    /// is useful in IP address change situation, if the media transport
    /// address (or address family) changes, for example during IPv4/IPv6
    /// network handover.
    /// This flag is only valid for #pjsua_call_reinvite()/reinvite2(), or
    /// #pjsua_call_update()/update2().
    ///
    /// Warning: If the re-INVITE/UPDATE fails, the old media will not be
    /// reverted.
    PJSUA_CALL_REINIT_MEDIA = 16,
    /// Update the local invite session's Via with the via address from
    /// the account. This flag is only valid for #pjsua_call_set_hold2(),
    /// #pjsua_call_reinvite() and #pjsua_call_update(). Similar to
    /// the flag PJSUA_CALL_UPDATE_CONTACT above, this flag is useful
    /// in IP address change situation, after the local account's Via has
    /// been updated (typically with re-registration).
    PJSUA_CALL_UPDATE_VIA = 32,
}

/// Media stream info.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsua_stream_info {
    /// Media type of this stream.
    pub type_: pjmedia_type,
    pub info: pjsua_stream_info__bindgen_ty_1,
}

/// Stream info (union).
#[repr(C)]
#[derive(Copy, Clone)]
pub union pjsua_stream_info__bindgen_ty_1 {
    /// Audio stream info
    pub aud: pjmedia_stream_info,
    /// Video stream info
    pub vid: pjmedia_vid_stream_info,
    _bindgen_union_align: [u32; 83usize],
}

/// Media stream statistic.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsua_stream_stat {
    /// RTCP statistic.
    pub rtcp: pjmedia_rtcp_stat,
    /// Jitter buffer statistic.
    pub jbuf: pjmedia_jb_state,
}

#[repr(u32)]
/// This enumeration represents video stream operation on a call.
/// See also #pjsua_call_vid_strm_op_param for further info.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsua_call_vid_strm_op {
    /// No operation
    PJSUA_CALL_VID_STRM_NO_OP = 0,
    /// Add a new video stream. This will add a new m=video line to
    /// the media, regardless of whether existing video is/are present
    /// or not.  This will cause re-INVITE or UPDATE to be sent to remote
    /// party.
    PJSUA_CALL_VID_STRM_ADD = 1,
    /// Remove/disable an existing video stream. This will
    /// cause re-INVITE or UPDATE to be sent to remote party.
    PJSUA_CALL_VID_STRM_REMOVE = 2,
    /// Change direction of a video stream. This operation can be used
    /// to activate or deactivate an existing video media. This will
    /// cause re-INVITE or UPDATE to be sent to remote party.
    PJSUA_CALL_VID_STRM_CHANGE_DIR = 3,
    /// Change capture device of a video stream.  This will not send
    /// re-INVITE or UPDATE to remote party.
    PJSUA_CALL_VID_STRM_CHANGE_CAP_DEV = 4,
    /// Start transmitting video stream. This will cause previously
    /// stopped stream to start transmitting again. Note that no
    /// re-INVITE/UPDATE is to be transmitted to remote since this
    /// operation only operates on local stream.
    PJSUA_CALL_VID_STRM_START_TRANSMIT = 5,
    /// Stop transmitting video stream. This will cause the stream to
    /// be paused in TX direction, causing it to stop sending any video
    /// packets. No re-INVITE/UPDATE is to be transmitted to remote
    /// with this operation.
    PJSUA_CALL_VID_STRM_STOP_TRANSMIT = 6,
    /// Send keyframe in the video stream. This will force the stream to
    /// generate and send video keyframe as soon as possible. No
    /// re-INVITE/UPDATE is to be transmitted to remote with this operation.
    PJSUA_CALL_VID_STRM_SEND_KEYFRAME = 7,
}

/// Parameters for video stream operation on a call. Application should
/// use #pjsua_call_vid_strm_op_param_default() to initialize this structure
/// with its default values.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsua_call_vid_strm_op_param {
    /// Specify the media stream index. This can be set to -1 to denote
    /// the default video stream in the call, which is the first active
    /// video stream or any first video stream if none is active.
    ///
    /// This field is valid for all video stream operations, except
    /// PJSUA_CALL_VID_STRM_ADD.
    ///
    /// Default: -1 (first active video stream, or any first video stream
    /// if none is active)
    pub med_idx: ::std::os::raw::c_int,
    /// Specify the media stream direction.
    ///
    /// This field is valid for the following video stream operations:
    /// PJSUA_CALL_VID_STRM_ADD and PJSUA_CALL_VID_STRM_CHANGE_DIR.
    ///
    /// Default: PJMEDIA_DIR_ENCODING_DECODING
    pub dir: pjmedia_dir,
    /// Specify the video capture device ID. This can be set to
    /// PJMEDIA_VID_DEFAULT_CAPTURE_DEV to specify the default capture
    /// device as configured in the account.
    ///
    /// This field is valid for the following video stream operations:
    /// PJSUA_CALL_VID_STRM_ADD and PJSUA_CALL_VID_STRM_CHANGE_CAP_DEV.
    ///
    /// Default: PJMEDIA_VID_DEFAULT_CAPTURE_DEV.
    pub cap_dev: pjmedia_vid_dev_index,
}

extern "C" {
    /// Initialize call settings.
///
/// @param opt		The call setting to be initialized.
    pub fn pjsua_call_setting_default(opt: *mut pjsua_call_setting);
}

extern "C" {
    /// Initialize video stream operation param with default values.
///
/// @param param		The video stream operation param to be initialized.
    pub fn pjsua_call_vid_strm_op_param_default(param: *mut pjsua_call_vid_strm_op_param);
}

extern "C" {
    /// Get maximum number of calls configured in pjsua.
///
/// @return		Maximum number of calls configured.
    pub fn pjsua_call_get_max_count() -> ::std::os::raw::c_uint;
}

extern "C" {
    /// Get number of currently active calls.
///
/// @return		Number of currently active calls.
    pub fn pjsua_call_get_count() -> ::std::os::raw::c_uint;
}

extern "C" {
    /// Enumerate all active calls. Application may then query the information and
/// state of each call by calling #pjsua_call_get_info().
///
/// @param ids		Array of account IDs to be initialized.
/// @param count		In input, specifies the maximum number of elements.
/// On return, it contains the actual number of elements.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_enum_calls(ids: *mut pjsua_call_id, count: *mut ::std::os::raw::c_uint) -> pj_status_t;
}

extern "C" {
    /// Make outgoing call to the specified URI using the specified account.
///
/// @param acc_id	The account to be used.
/// @param dst_uri	URI to be put in the To header (normally is the same
/// as the target URI).
/// @param opt		Optional call setting. This should be initialized
/// using #pjsua_call_setting_default().
/// @param user_data	Arbitrary user data to be attached to the call, and
/// can be retrieved later.
/// @param msg_data	Optional headers etc to be added to outgoing INVITE
/// request, or NULL if no custom header is desired.
/// @param p_call_id	Pointer to receive call identification.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_call_make_call(acc_id: pjsua_acc_id, dst_uri: *const pj_str_t, opt: *const pjsua_call_setting, user_data: *mut ::std::os::raw::c_void, msg_data: *const pjsua_msg_data, p_call_id: *mut pjsua_call_id) -> pj_status_t;
}

extern "C" {
    /// Check if the specified call has active INVITE session and the INVITE
/// session has not been disconnected.
///
/// @param call_id	Call identification.
///
/// @return		Non-zero if call is active.
    pub fn pjsua_call_is_active(call_id: pjsua_call_id) -> pj_bool_t;
}

extern "C" {
    /// Check if call has an active media session.
///
/// @param call_id	Call identification.
///
/// @return		Non-zero if yes.
    pub fn pjsua_call_has_media(call_id: pjsua_call_id) -> pj_bool_t;
}

extern "C" {
    /// Get the conference port identification associated with the call.
///
/// @param call_id	Call identification.
///
/// @return		Conference port ID, or PJSUA_INVALID_ID when the
/// media has not been established or is not active.
    pub fn pjsua_call_get_conf_port(call_id: pjsua_call_id) -> pjsua_conf_port_id;
}

extern "C" {
    /// Obtain detail information about the specified call.
///
/// @param call_id	Call identification.
/// @param info		Call info to be initialized.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_call_get_info(call_id: pjsua_call_id, info: *mut pjsua_call_info) -> pj_status_t;
}

extern "C" {
    /// Check if remote peer support the specified capability.
///
/// @param call_id	Call identification.
/// @param htype		The header type to be checked, which value may be:
/// - PJSIP_H_ACCEPT
/// - PJSIP_H_ALLOW
/// - PJSIP_H_SUPPORTED
/// @param hname		If htype specifies PJSIP_H_OTHER, then the header
/// name must be supplied in this argument. Otherwise the
/// value must be set to NULL.
/// @param token		The capability token to check. For example, if \a
/// htype is PJSIP_H_ALLOW, then \a token specifies the
/// method names; if \a htype is PJSIP_H_SUPPORTED, then
/// \a token specifies the extension names such as
/// "100rel".
///
/// @return		PJSIP_DIALOG_CAP_SUPPORTED if the specified capability
/// is explicitly supported, see @pjsip_dialog_cap_status
/// for more info.
    pub fn pjsua_call_remote_has_cap(call_id: pjsua_call_id, htype: ::std::os::raw::c_int, hname: *const pj_str_t, token: *const pj_str_t) -> pjsip_dialog_cap_status;
}

extern "C" {
    /// Attach application specific data to the call. Application can then
/// inspect this data by calling #pjsua_call_get_user_data().
///
/// @param call_id	Call identification.
/// @param user_data	Arbitrary data to be attached to the call.
///
/// @return		The user data.
    pub fn pjsua_call_set_user_data(call_id: pjsua_call_id, user_data: *mut ::std::os::raw::c_void) -> pj_status_t;
}

extern "C" {
    /// Get user data attached to the call, which has been previously set with
/// #pjsua_call_set_user_data().
///
/// @param call_id	Call identification.
///
/// @return		The user data.
    pub fn pjsua_call_get_user_data(call_id: pjsua_call_id) -> *mut ::std::os::raw::c_void;
}

extern "C" {
    /// Get the NAT type of remote's endpoint. This is a proprietary feature
/// of PJSUA-LIB which sends its NAT type in the SDP when \a nat_type_in_sdp
/// is set in #pjsua_config.
///
/// This function can only be called after SDP has been received from remote,
/// which means for incoming call, this function can be called as soon as
/// call is received as long as incoming call contains SDP, and for outgoing
/// call, this function can be called only after SDP is received (normally in
/// 200/OK response to INVITE). As a general case, application should call
/// this function after or in \a on_call_media_state() callback.
///
/// @param call_id	Call identification.
/// @param p_type	Pointer to store the NAT type. Application can then
/// retrieve the string description of the NAT type
/// by calling pj_stun_get_nat_name().
///
/// @return		PJ_SUCCESS on success.
///
/// @see pjsua_get_nat_type(), nat_type_in_sdp
    pub fn pjsua_call_get_rem_nat_type(call_id: pjsua_call_id, p_type: *mut pj_stun_nat_type) -> pj_status_t;
}

extern "C" {
    /// Send response to incoming INVITE request. Depending on the status
/// code specified as parameter, this function may send provisional
/// response, establish the call, or terminate the call. See also
/// #pjsua_call_answer2().
///
/// @param call_id	Incoming call identification.
/// @param code		Status code, (100-699).
/// @param reason	Optional reason phrase. If NULL, default text
/// will be used.
/// @param msg_data	Optional list of headers etc to be added to outgoing
/// response message. Note that this message data will
/// be persistent in all next answers/responses for this
/// INVITE request.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_call_answer(call_id: pjsua_call_id, code: ::std::os::raw::c_uint, reason: *const pj_str_t, msg_data: *const pjsua_msg_data) -> pj_status_t;
}

extern "C" {
    /// Send response to incoming INVITE request with call setting param.
/// Depending on the status code specified as parameter, this function may
/// send provisional response, establish the call, or terminate the call.
/// Notes about call setting:
/// - if call setting is changed in the subsequent call to this function,
/// only the first call setting supplied will applied. So normally
/// application will not supply call setting before getting confirmation
/// from the user.
/// - if no call setting is supplied when SDP has to be sent, i.e: answer
/// with status code 183 or 2xx, the default call setting will be used,
/// check #pjsua_call_setting for its default values.
///
/// @param call_id	Incoming call identification.
/// @param opt		Optional call setting.
/// @param code		Status code, (100-699).
/// @param reason	Optional reason phrase. If NULL, default text
/// will be used.
/// @param msg_data	Optional list of headers etc to be added to outgoing
/// response message. Note that this message data will
/// be persistent in all next answers/responses for this
/// INVITE request.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_call_answer2(call_id: pjsua_call_id, opt: *const pjsua_call_setting, code: ::std::os::raw::c_uint, reason: *const pj_str_t, msg_data: *const pjsua_msg_data) -> pj_status_t;
}

extern "C" {
    /// Hangup call by using method that is appropriate according to the
/// call state. This function is different than answering the call with
/// 3xx-6xx response (with #pjsua_call_answer()), in that this function
/// will hangup the call regardless of the state and role of the call,
/// while #pjsua_call_answer() only works with incoming calls on EARLY
/// state.
///
/// @param call_id	Call identification.
/// @param code		Optional status code to be sent when we're rejecting
/// incoming call. If the value is zero, "603/Decline"
/// will be sent.
/// @param reason	Optional reason phrase to be sent when we're rejecting
/// incoming call.  If NULL, default text will be used.
/// @param msg_data	Optional list of headers etc to be added to outgoing
/// request/response message.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_call_hangup(call_id: pjsua_call_id, code: ::std::os::raw::c_uint, reason: *const pj_str_t, msg_data: *const pjsua_msg_data) -> pj_status_t;
}

extern "C" {
    /// Accept or reject redirection response. Application MUST call this function
/// after it signaled PJSIP_REDIRECT_PENDING in the \a on_call_redirected()
/// callback, to notify the call whether to accept or reject the redirection
/// to the current target. Application can use the combination of
/// PJSIP_REDIRECT_PENDING command in \a on_call_redirected() callback and
/// this function to ask for user permission before redirecting the call.
///
/// Note that if the application chooses to reject or stop redirection (by
/// using PJSIP_REDIRECT_REJECT or PJSIP_REDIRECT_STOP respectively), the
/// call disconnection callback will be called before this function returns.
/// And if the application rejects the target, the \a on_call_redirected()
/// callback may also be called before this function returns if there is
/// another target to try.
///
/// @param call_id	The call ID.
/// @param cmd		Redirection operation to be applied to the current
/// target. The semantic of this argument is similar
/// to the description in the \a on_call_redirected()
/// callback, except that the PJSIP_REDIRECT_PENDING is
/// not accepted here.
///
/// @return		PJ_SUCCESS on successful operation.
    pub fn pjsua_call_process_redirect(call_id: pjsua_call_id, cmd: pjsip_redirect_op) -> pj_status_t;
}

extern "C" {
    /// Put the specified call on hold. This will send re-INVITE with the
/// appropriate SDP to inform remote that the call is being put on hold.
/// The final status of the request itself will be reported on the
/// \a on_call_media_state() callback, which inform the application that
/// the media state of the call has changed.
///
/// @param call_id	Call identification.
/// @param msg_data	Optional message components to be sent with
/// the request.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_call_set_hold(call_id: pjsua_call_id, msg_data: *const pjsua_msg_data) -> pj_status_t;
}

extern "C" {
    /// Put the specified call on hold. This will send re-INVITE with the
/// appropriate SDP to inform remote that the call is being put on hold.
/// The final status of the request itself will be reported on the
/// \a on_call_media_state() callback, which inform the application that
/// the media state of the call has changed.
///
/// @param call_id	Call identification.
/// @param options	Bitmask of pjsua_call_flag constants. Currently, only
/// the flag PJSUA_CALL_UPDATE_CONTACT can be used.
/// @param msg_data	Optional message components to be sent with
/// the request.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_call_set_hold2(call_id: pjsua_call_id, options: ::std::os::raw::c_uint, msg_data: *const pjsua_msg_data) -> pj_status_t;
}

extern "C" {
    /// Send re-INVITE request or release hold.
/// The final status of the request itself will be reported on the
/// \a on_call_media_state() callback, which inform the application that
/// the media state of the call has changed.
///
/// @param call_id	Call identification.
/// @param options	Bitmask of pjsua_call_flag constants. Note that
/// for compatibility, specifying PJ_TRUE here is
/// equal to specifying PJSUA_CALL_UNHOLD flag.
/// @param msg_data	Optional message components to be sent with
/// the request.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_call_reinvite(call_id: pjsua_call_id, options: ::std::os::raw::c_uint, msg_data: *const pjsua_msg_data) -> pj_status_t;
}

extern "C" {
    /// Send re-INVITE request or release hold.
/// The final status of the request itself will be reported on the
/// \a on_call_media_state() callback, which inform the application that
/// the media state of the call has changed.
///
/// @param call_id	Call identification.
/// @param opt		Optional call setting, if NULL, the current call
/// setting will be used. Note that to release hold
/// or update contact or omit SDP offer, this parameter
/// cannot be NULL and it must specify appropriate flags,
/// e.g: PJSUA_CALL_UNHOLD, PJSUA_CALL_UPDATE_CONTACT,
/// PJSUA_CALL_NO_SDP_OFFER.
/// @param msg_data	Optional message components to be sent with
/// the request.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_call_reinvite2(call_id: pjsua_call_id, opt: *const pjsua_call_setting, msg_data: *const pjsua_msg_data) -> pj_status_t;
}

extern "C" {
    /// Send UPDATE request.
   ///
   /// @param call_id	Call identification.
   /// @param options	Bitmask of pjsua_call_flag constants.
   /// @param msg_data	Optional message components to be sent with
   /// the request.
   ///
   /// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_call_update(call_id: pjsua_call_id, options: ::std::os::raw::c_uint, msg_data: *const pjsua_msg_data) -> pj_status_t;
}

extern "C" {
    /// Send UPDATE request.
///
/// @param call_id	Call identification.
/// @param opt		Optional call setting, if NULL, the current call
/// setting will be used. Note that to release hold
/// or update contact or omit SDP offer, this parameter
/// cannot be NULL and it must specify appropriate flags,
/// e.g: PJSUA_CALL_UNHOLD, PJSUA_CALL_UPDATE_CONTACT,
/// PJSUA_CALL_NO_SDP_OFFER.
/// @param msg_data	Optional message components to be sent with
/// the request.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_call_update2(call_id: pjsua_call_id, opt: *const pjsua_call_setting, msg_data: *const pjsua_msg_data) -> pj_status_t;
}

extern "C" {
    /// Initiate call transfer to the specified address. This function will send
/// REFER request to instruct remote call party to initiate a new INVITE
/// session to the specified destination/target.
///
/// If application is interested to monitor the successfulness and
/// the progress of the transfer request, it can implement
/// \a on_call_transfer_status() callback which will report the progress
/// of the call transfer request.
///
/// @param call_id	The call id to be transferred.
/// @param dest		URI of new target to be contacted. The URI may be
/// in name address or addr-spec format.
/// @param msg_data	Optional message components to be sent with
/// the request.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_call_xfer(call_id: pjsua_call_id, dest: *const pj_str_t, msg_data: *const pjsua_msg_data) -> pj_status_t;
}

extern "C" {
    /// Initiate attended call transfer. This function will send REFER request
/// to instruct remote call party to initiate new INVITE session to the URL
/// of \a dest_call_id. The party at \a dest_call_id then should "replace"
/// the call with us with the new call from the REFER recipient.
///
/// @param call_id	The call id to be transferred.
/// @param dest_call_id	The call id to be replaced.
/// @param options	Application may specify PJSUA_XFER_NO_REQUIRE_REPLACES
/// to suppress the inclusion of "Require: replaces" in
/// the outgoing INVITE request created by the REFER
/// request.
/// @param msg_data	Optional message components to be sent with
/// the request.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_call_xfer_replaces(call_id: pjsua_call_id, dest_call_id: pjsua_call_id, options: ::std::os::raw::c_uint, msg_data: *const pjsua_msg_data) -> pj_status_t;
}

extern "C" {
    /// Send DTMF digits to remote using RFC 2833 payload formats.
///
/// @param call_id	Call identification.
/// @param digits	DTMF string digits to be sent as described on RFC 2833
/// section 3.10. If PJMEDIA_HAS_DTMF_FLASH is enabled,
/// character 'R' is used to represent the
/// event type 16 (flash) as stated in RFC 4730.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_call_dial_dtmf(call_id: pjsua_call_id, digits: *const pj_str_t) -> pj_status_t;
}

extern "C" {
    /// Send instant messaging inside INVITE session.
///
/// @param call_id	Call identification.
/// @param mime_type	Optional MIME type. If NULL, then "text/plain" is
/// assumed.
/// @param content	The message content.
/// @param msg_data	Optional list of headers etc to be included in outgoing
/// request. The body descriptor in the msg_data is
/// ignored.
/// @param user_data	Optional user data, which will be given back when
/// the IM callback is called.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_call_send_im(call_id: pjsua_call_id, mime_type: *const pj_str_t, content: *const pj_str_t, msg_data: *const pjsua_msg_data, user_data: *mut ::std::os::raw::c_void) -> pj_status_t;
}

extern "C" {
    /// Send IM typing indication inside INVITE session.
///
/// @param call_id	Call identification.
/// @param is_typing	Non-zero to indicate to remote that local person is
/// currently typing an IM.
/// @param msg_data	Optional list of headers etc to be included in outgoing
/// request.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_call_send_typing_ind(call_id: pjsua_call_id, is_typing: pj_bool_t, msg_data: *const pjsua_msg_data) -> pj_status_t;
}

extern "C" {
    /// Send arbitrary request with the call. This is useful for example to send
/// INFO request. Note that application should not use this function to send
/// requests which would change the invite session's state, such as re-INVITE,
/// UPDATE, PRACK, and BYE.
///
/// @param call_id	Call identification.
/// @param method	SIP method of the request.
/// @param msg_data	Optional message body and/or list of headers to be
/// included in outgoing request.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_call_send_request(call_id: pjsua_call_id, method: *const pj_str_t, msg_data: *const pjsua_msg_data) -> pj_status_t;
}

extern "C" {
    /// Terminate all calls. This will initiate #pjsua_call_hangup() for all
/// currently active calls.
    pub fn pjsua_call_hangup_all();
}

extern "C" {
    /// Dump call and media statistics to string.
///
/// @param call_id	Call identification.
/// @param with_media	Non-zero to include media information too.
/// @param buffer	Buffer where the statistics are to be written to.
/// @param maxlen	Maximum length of buffer.
/// @param indent	Spaces for left indentation.
///
/// @return		PJ_SUCCESS on success.
    pub fn pjsua_call_dump(call_id: pjsua_call_id, with_media: pj_bool_t, buffer: *mut ::std::os::raw::c_char, maxlen: ::std::os::raw::c_uint, indent: *const ::std::os::raw::c_char) -> pj_status_t;
}

extern "C" {
    /// Get the media stream index of the default video stream in the call.
/// Typically this will just retrieve the stream index of the first
/// activated video stream in the call. If none is active, it will return
/// the first inactive video stream.
///
/// @param call_id	Call identification.
///
/// @return		The media stream index or -1 if no video stream
/// is present in the call.
    pub fn pjsua_call_get_vid_stream_idx(call_id: pjsua_call_id) -> ::std::os::raw::c_int;
}

extern "C" {
    /// Determine if video stream for the specified call is currently running
/// (i.e. has been created, started, and not being paused) for the specified
/// direction.
///
/// @param call_id	Call identification.
/// @param med_idx	Media stream index, or -1 to specify default video
/// media.
/// @param dir		The direction to be checked.
///
/// @return		PJ_TRUE if stream is currently running for the
/// specified direction.
    pub fn pjsua_call_vid_stream_is_running(call_id: pjsua_call_id, med_idx: ::std::os::raw::c_int, dir: pjmedia_dir) -> pj_bool_t;
}

extern "C" {
    /// Add, remove, modify, and/or manipulate video media stream for the
/// specified call. This may trigger a re-INVITE or UPDATE to be sent
/// for the call.
///
/// @param call_id	Call identification.
/// @param op		The video stream operation to be performed,
/// possible values are #pjsua_call_vid_strm_op.
/// @param param		The parameters for the video stream operation,
/// or NULL for the default parameter values
/// (see #pjsua_call_vid_strm_op_param).
///
/// @return		PJ_SUCCESS on success or the appropriate error.
    pub fn pjsua_call_set_vid_strm(call_id: pjsua_call_id, op: pjsua_call_vid_strm_op, param: *const pjsua_call_vid_strm_op_param) -> pj_status_t;
}

extern "C" {
    /// Get media stream info for the specified media index.
///
/// @param call_id	The call identification.
/// @param med_idx	Media stream index.
/// @param psi		To be filled with the stream info.
///
/// @return		PJ_SUCCESS on success or the appropriate error.
    pub fn pjsua_call_get_stream_info(call_id: pjsua_call_id, med_idx: ::std::os::raw::c_uint, psi: *mut pjsua_stream_info) -> pj_status_t;
}

extern "C" {
    /// Get media stream statistic for the specified media index.
///
/// @param call_id	The call identification.
/// @param med_idx	Media stream index.
/// @param psi		To be filled with the stream statistic.
///
/// @return		PJ_SUCCESS on success or the appropriate error.
    pub fn pjsua_call_get_stream_stat(call_id: pjsua_call_id, med_idx: ::std::os::raw::c_uint, stat: *mut pjsua_stream_stat) -> pj_status_t;
}

extern "C" {
    /// Get media transport info for the specified media index.
///
/// @param call_id	The call identification.
/// @param med_idx	Media stream index.
/// @param t		To be filled with the transport info.
///
/// @return		PJ_SUCCESS on success or the appropriate error.
    pub fn pjsua_call_get_med_transport_info(call_id: pjsua_call_id, med_idx: ::std::os::raw::c_uint, t: *mut pjmedia_transport_info) -> pj_status_t;
}

/// This structure describes buddy configuration when adding a buddy to
/// the buddy list with #pjsua_buddy_add(). Application MUST initialize
/// the structure with #pjsua_buddy_config_default() to initialize this
/// structure with default configuration.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsua_buddy_config {
    /// Buddy URL or name address.
    pub uri: pj_str_t,
    /// Specify whether presence subscription should start immediately.
    pub subscribe: pj_bool_t,
    /// Specify arbitrary application data to be associated with with
    /// the buddy object.
    pub user_data: *mut ::std::os::raw::c_void,
}

#[repr(u32)]
/// This enumeration describes basic buddy's online status.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsua_buddy_status {
    /// Online status is unknown (possibly because no presence subscription
    /// has been established).
    PJSUA_BUDDY_STATUS_UNKNOWN = 0,
    /// Buddy is known to be online.
    PJSUA_BUDDY_STATUS_ONLINE = 1,
    /// Buddy is offline.
    PJSUA_BUDDY_STATUS_OFFLINE = 2,
}

/// This structure describes buddy info, which can be retrieved by calling
/// #pjsua_buddy_get_info().
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsua_buddy_info {
    /// The buddy ID.
    pub id: pjsua_buddy_id,
    /// The full URI of the buddy, as specified in the configuration.
    pub uri: pj_str_t,
    /// Buddy's Contact, only available when presence subscription has
    /// been established to the buddy.
    pub contact: pj_str_t,
    /// Buddy's online status.
    pub status: pjsua_buddy_status,
    /// Text to describe buddy's online status.
    pub status_text: pj_str_t,
    /// Flag to indicate that we should monitor the presence information for
    /// this buddy (normally yes, unless explicitly disabled).
    pub monitor_pres: pj_bool_t,
    /// If \a monitor_pres is enabled, this specifies the last state of the
    /// presence subscription. If presence subscription session is currently
    /// active, the value will be PJSIP_EVSUB_STATE_ACTIVE. If presence
    /// subscription request has been rejected, the value will be
    /// PJSIP_EVSUB_STATE_TERMINATED, and the termination reason will be
    /// specified in \a sub_term_reason.
    pub sub_state: pjsip_evsub_state,
    /// String representation of subscription state.
    pub sub_state_name: *const ::std::os::raw::c_char,
    /// Specifies the last presence subscription termination code. This would
    /// return the last status of the SUBSCRIBE request. If the subscription
    /// is terminated with NOTIFY by the server, this value will be set to
    /// 200, and subscription termination reason will be given in the
    /// \a sub_term_reason field.
    pub sub_term_code: ::std::os::raw::c_uint,
    /// Specifies the last presence subscription termination reason. If
    /// presence subscription is currently active, the value will be empty.
    pub sub_term_reason: pj_str_t,
    /// Extended RPID information about the person.
    pub rpid: pjrpid_element,
    /// Extended presence info.
    pub pres_status: pjsip_pres_status,
    /// Internal buffer.
    pub buf_: [::std::os::raw::c_char; 512usize],
}

extern "C" {
    /// Set default values to the buddy config.
    pub fn pjsua_buddy_config_default(cfg: *mut pjsua_buddy_config);
}

extern "C" {
    /// Get total number of buddies.
///
/// @return		Number of buddies.
    pub fn pjsua_get_buddy_count() -> ::std::os::raw::c_uint;
}

extern "C" {
    /// Check if buddy ID is valid.
///
/// @param buddy_id	Buddy ID to check.
///
/// @return		Non-zero if buddy ID is valid.
    pub fn pjsua_buddy_is_valid(buddy_id: pjsua_buddy_id) -> pj_bool_t;
}

extern "C" {
    /// Enumerate all buddy IDs in the buddy list. Application then can use
/// #pjsua_buddy_get_info() to get the detail information for each buddy
/// id.
///
/// @param ids		Array of ids to be initialized.
/// @param count		On input, specifies max elements in the array.
/// On return, it contains actual number of elements
/// that have been initialized.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_enum_buddies(ids: *mut pjsua_buddy_id, count: *mut ::std::os::raw::c_uint) -> pj_status_t;
}

extern "C" {
    /// Find the buddy ID with the specified URI.
///
/// @param uri		The buddy URI.
///
/// @return		The buddy ID, or PJSUA_INVALID_ID if not found.
    pub fn pjsua_buddy_find(uri: *const pj_str_t) -> pjsua_buddy_id;
}

extern "C" {
    /// Get detailed buddy info.
///
/// @param buddy_id	The buddy identification.
/// @param info		Pointer to receive information about buddy.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_buddy_get_info(buddy_id: pjsua_buddy_id, info: *mut pjsua_buddy_info) -> pj_status_t;
}

extern "C" {
    /// Set the user data associated with the buddy object.
///
/// @param buddy_id	The buddy identification.
/// @param user_data	Arbitrary application data to be associated with
/// the buddy object.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_buddy_set_user_data(buddy_id: pjsua_buddy_id, user_data: *mut ::std::os::raw::c_void) -> pj_status_t;
}

extern "C" {
    /// Get the user data associated with the budy object.
///
/// @param buddy_id	The buddy identification.
///
/// @return		The application data.
    pub fn pjsua_buddy_get_user_data(buddy_id: pjsua_buddy_id) -> *mut ::std::os::raw::c_void;
}

extern "C" {
    /// Add new buddy to the buddy list. If presence subscription is enabled
/// for this buddy, this function will also start the presence subscription
/// session immediately.
///
/// @param buddy_cfg	Buddy configuration.
/// @param p_buddy_id	Pointer to receive buddy ID.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_buddy_add(buddy_cfg: *const pjsua_buddy_config, p_buddy_id: *mut pjsua_buddy_id) -> pj_status_t;
}

extern "C" {
    /// Delete the specified buddy from the buddy list. Any presence subscription
/// to this buddy will be terminated.
///
/// @param buddy_id	Buddy identification.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_buddy_del(buddy_id: pjsua_buddy_id) -> pj_status_t;
}

extern "C" {
    /// Enable/disable buddy's presence monitoring. Once buddy's presence is
/// subscribed, application will be informed about buddy's presence status
/// changed via \a on_buddy_state() callback.
///
/// @param buddy_id	Buddy identification.
/// @param subscribe	Specify non-zero to activate presence subscription to
/// the specified buddy.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_buddy_subscribe_pres(buddy_id: pjsua_buddy_id, subscribe: pj_bool_t) -> pj_status_t;
}

extern "C" {
    /// Update the presence information for the buddy. Although the library
/// periodically refreshes the presence subscription for all buddies, some
/// application may want to refresh the buddy's presence subscription
/// immediately, and in this case it can use this function to accomplish
/// this.
///
/// Note that the buddy's presence subscription will only be initiated
/// if presence monitoring is enabled for the buddy. See
/// #pjsua_buddy_subscribe_pres() for more info. Also if presence subscription
/// for the buddy is already active, this function will not do anything.
///
/// Once the presence subscription is activated successfully for the buddy,
/// application will be notified about the buddy's presence status in the
/// on_buddy_state() callback.
///
/// @param buddy_id	Buddy identification.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_buddy_update_pres(buddy_id: pjsua_buddy_id) -> pj_status_t;
}

extern "C" {
    /// Send NOTIFY to inform account presence status or to terminate server
/// side presence subscription. If application wants to reject the incoming
/// request, it should set the \a state to PJSIP_EVSUB_STATE_TERMINATED.
///
/// @param acc_id	Account ID.
/// @param srv_pres	Server presence subscription instance.
/// @param state		New state to set.
/// @param state_str	Optionally specify the state string name, if state
/// is not "active", "pending", or "terminated".
/// @param reason	If the new state is PJSIP_EVSUB_STATE_TERMINATED,
/// optionally specify the termination reason.
/// @param with_body	If the new state is PJSIP_EVSUB_STATE_TERMINATED,
/// this specifies whether the NOTIFY request should
/// contain message body containing account's presence
/// information.
/// @param msg_data	Optional list of headers to be sent with the NOTIFY
/// request.
///
/// @return		PJ_SUCCESS on success.
    pub fn pjsua_pres_notify(acc_id: pjsua_acc_id, srv_pres: *mut pjsua_srv_pres, state: pjsip_evsub_state, state_str: *const pj_str_t, reason: *const pj_str_t, with_body: pj_bool_t, msg_data: *const pjsua_msg_data) -> pj_status_t;
}

extern "C" {
    /// Dump presence subscriptions to log.
///
/// @param verbose	Yes or no.
    pub fn pjsua_pres_dump(verbose: pj_bool_t);
}

extern "C" {
    #[link_name = "\u{1}pjsip_message_method"]
    pub static mut pjsip_message_method: pjsip_method;
}

extern "C" {
    #[link_name = "\u{1}pjsip_info_method"]
    pub static mut pjsip_info_method: pjsip_method;
}

extern "C" {
    /// Send instant messaging outside dialog, using the specified account for
/// route set and authentication.
///
/// @param acc_id	Account ID to be used to send the request.
/// @param to		Remote URI.
/// @param mime_type	Optional MIME type. If NULL, then "text/plain" is
/// assumed.
/// @param content	The message content.
/// @param msg_data	Optional list of headers etc to be included in outgoing
/// request. The body descriptor in the msg_data is
/// ignored.
/// @param user_data	Optional user data, which will be given back when
/// the IM callback is called.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_im_send(acc_id: pjsua_acc_id, to: *const pj_str_t, mime_type: *const pj_str_t, content: *const pj_str_t, msg_data: *const pjsua_msg_data, user_data: *mut ::std::os::raw::c_void) -> pj_status_t;
}

extern "C" {
    /// Send typing indication outside dialog.
///
/// @param acc_id	Account ID to be used to send the request.
/// @param to		Remote URI.
/// @param is_typing	If non-zero, it tells remote person that local person
/// is currently composing an IM.
/// @param msg_data	Optional list of headers etc to be added to outgoing
/// request.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_im_typing(acc_id: pjsua_acc_id, to: *const pj_str_t, is_typing: pj_bool_t, msg_data: *const pjsua_msg_data) -> pj_status_t;
}

/// This structure describes media configuration, which will be specified
/// when calling #pjsua_init(). Application MUST initialize this structure
/// by calling #pjsua_media_config_default().
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsua_media_config {
    /// Clock rate to be applied to the conference bridge.
    /// If value is zero, default clock rate will be used
    /// (PJSUA_DEFAULT_CLOCK_RATE, which by default is 16KHz).
    pub clock_rate: ::std::os::raw::c_uint,
    /// Clock rate to be applied when opening the sound device.
    /// If value is zero, conference bridge clock rate will be used.
    pub snd_clock_rate: ::std::os::raw::c_uint,
    /// Channel count be applied when opening the sound device and
    /// conference bridge.
    pub channel_count: ::std::os::raw::c_uint,
    /// Specify audio frame ptime. The value here will affect the
    /// samples per frame of both the sound device and the conference
    /// bridge. Specifying lower ptime will normally reduce the
    /// latency.
    ///
    /// Default value: PJSUA_DEFAULT_AUDIO_FRAME_PTIME
    pub audio_frame_ptime: ::std::os::raw::c_uint,
    /// Specify maximum number of media ports to be created in the
    /// conference bridge. Since all media terminate in the bridge
    /// (calls, file player, file recorder, etc), the value must be
    /// large enough to support all of them. However, the larger
    /// the value, the more computations are performed.
    ///
    /// Default value: PJSUA_MAX_CONF_PORTS
    pub max_media_ports: ::std::os::raw::c_uint,
    /// Specify whether the media manager should manage its own
    /// ioqueue for the RTP/RTCP sockets. If yes, ioqueue will be created
    /// and at least one worker thread will be created too. If no,
    /// the RTP/RTCP sockets will share the same ioqueue as SIP sockets,
    /// and no worker thread is needed.
    ///
    /// Normally application would say yes here, unless it wants to
    /// run everything from a single thread.
    pub has_ioqueue: pj_bool_t,
    /// Specify the number of worker threads to handle incoming RTP
    /// packets. A value of one is recommended for most applications.
    pub thread_cnt: ::std::os::raw::c_uint,
    /// Media quality, 0-10, according to this table:
    /// 5-10: resampling use large filter,
    /// 3-4:  resampling use small filter,
    /// 1-2:  resampling use linear.
    /// The media quality also sets speex codec quality/complexity to the
    /// number.
    ///
    /// Default: 5 (PJSUA_DEFAULT_CODEC_QUALITY).
    pub quality: ::std::os::raw::c_uint,
    /// Specify default codec ptime.
    ///
    /// Default: 0 (codec specific)
    pub ptime: ::std::os::raw::c_uint,
    /// Disable VAD?
    ///
    /// Default: 0 (no (meaning VAD is enabled))
    pub no_vad: pj_bool_t,
    /// iLBC mode (20 or 30).
    ///
    /// Default: 30 (PJSUA_DEFAULT_ILBC_MODE)
    pub ilbc_mode: ::std::os::raw::c_uint,
    /// Percentage of RTP packet to drop in TX direction
    /// (to simulate packet lost).
    ///
    /// Default: 0
    pub tx_drop_pct: ::std::os::raw::c_uint,
    /// Percentage of RTP packet to drop in RX direction
    /// (to simulate packet lost).
    ///
    /// Default: 0
    pub rx_drop_pct: ::std::os::raw::c_uint,
    /// Echo canceller options (see #pjmedia_echo_create())
    ///
    /// Default: 0.
    pub ec_options: ::std::os::raw::c_uint,
    /// Echo canceller tail length, in miliseconds.
    ///
    /// Default: PJSUA_DEFAULT_EC_TAIL_LEN
    pub ec_tail_len: ::std::os::raw::c_uint,
    /// Audio capture buffer length, in milliseconds.
    ///
    /// Default: PJMEDIA_SND_DEFAULT_REC_LATENCY
    pub snd_rec_latency: ::std::os::raw::c_uint,
    /// Audio playback buffer length, in milliseconds.
    ///
    /// Default: PJMEDIA_SND_DEFAULT_PLAY_LATENCY
    pub snd_play_latency: ::std::os::raw::c_uint,
    /// Jitter buffer initial prefetch delay in msec. The value must be
    /// between jb_min_pre and jb_max_pre below. If the value is 0,
    /// prefetching will be disabled.
    ///
    /// Default: -1 (to use default stream settings, currently 0)
    pub jb_init: ::std::os::raw::c_int,
    /// Jitter buffer minimum prefetch delay in msec.
    ///
    /// Default: -1 (to use default stream settings, currently 60 msec)
    pub jb_min_pre: ::std::os::raw::c_int,
    /// Jitter buffer maximum prefetch delay in msec.
    ///
    /// Default: -1 (to use default stream settings, currently 240 msec)
    pub jb_max_pre: ::std::os::raw::c_int,
    /// Set maximum delay that can be accomodated by the jitter buffer msec.
    ///
    /// Default: -1 (to use default stream settings, currently 360 msec)
    pub jb_max: ::std::os::raw::c_int,
    /// Enable ICE
    pub enable_ice: pj_bool_t,
    /// Set the maximum number of host candidates.
    ///
    /// Default: -1 (maximum not set)
    pub ice_max_host_cands: ::std::os::raw::c_int,
    /// ICE session options.
    pub ice_opt: pj_ice_sess_options,
    /// Disable RTCP component.
    ///
    /// Default: no
    pub ice_no_rtcp: pj_bool_t,
    /// Send re-INVITE/UPDATE every after ICE connectivity check regardless
    /// the default ICE transport address is changed or not. When this is set
    /// to PJ_FALSE, re-INVITE/UPDATE will be sent only when the default ICE
    /// transport address is changed.
    ///
    /// Default: yes
    pub ice_always_update: pj_bool_t,
    /// Enable TURN relay candidate in ICE.
    pub enable_turn: pj_bool_t,
    /// Specify TURN domain name or host name, in in "DOMAIN:PORT" or
    /// "HOST:PORT" format.
    pub turn_server: pj_str_t,
    /// Specify the connection type to be used to the TURN server. Valid
    /// values are PJ_TURN_TP_UDP or PJ_TURN_TP_TCP.
    ///
    /// Default: PJ_TURN_TP_UDP
    pub turn_conn_type: pj_turn_tp_type,
    /// Specify the credential to authenticate with the TURN server.
    pub turn_auth_cred: pj_stun_auth_cred,
    /// Specify idle time of sound device before it is automatically closed,
    /// in seconds. Use value -1 to disable the auto-close feature of sound
    /// device
    ///
    /// Default : 1
    pub snd_auto_close_time: ::std::os::raw::c_int,
    /// Specify whether built-in/native preview should be used if available.
    /// In some systems, video input devices have built-in capability to show
    /// preview window of the device. Using this built-in preview is preferable
    /// as it consumes less CPU power. If built-in preview is not available,
    /// the library will perform software rendering of the input. If this
    /// field is set to PJ_FALSE, software preview will always be used.
    ///
    /// Default: PJ_TRUE
    pub vid_preview_enable_native: pj_bool_t,
    /// Disable smart media update (ticket #1568). The smart media update
    /// will check for any changes in the media properties after a successful
    /// SDP negotiation and the media will only be reinitialized when any
    /// change is found. When it is disabled, media streams will always be
    /// reinitialized after a successful SDP negotiation.
    ///
    /// Note for third party media, the smart media update requires stream info
    /// retrieval capability, see #PJSUA_THIRD_PARTY_STREAM_HAS_GET_INFO.
    ///
    /// Default: PJ_FALSE
    pub no_smart_media_update: pj_bool_t,
    /// Omit RTCP SDES and BYE in outgoing RTCP packet, this setting will be
    /// applied for both audio and video streams. Note that, when RTCP SDES
    /// and BYE are set to be omitted, RTCP SDES will still be sent once when
    /// the stream starts/stops and RTCP BYE will be sent once when the stream
    /// stops.
    ///
    /// Default: PJ_FALSE
    pub no_rtcp_sdes_bye: pj_bool_t,
    /// Optional callback for audio frame preview right before queued to
    /// the speaker.
    /// Notes:
    /// - application MUST NOT block or perform long operation in the callback
    /// as the callback may be executed in sound device thread
    /// - when using software echo cancellation, application MUST NOT modify
    /// the audio data from within the callback, otherwise the echo canceller
    /// will not work properly.
    pub on_aud_prev_play_frame: ::std::option::Option<unsafe extern "C" fn(frame: *mut pjmedia_frame)>,
    /// Optional callback for audio frame preview recorded from the microphone
    /// before being processed by any media component such as software echo
    /// canceller.
    /// Notes:
    /// - application MUST NOT block or perform long operation in the callback
    /// as the callback may be executed in sound device thread
    /// - when using software echo cancellation, application MUST NOT modify
    /// the audio data from within the callback, otherwise the echo canceller
    /// will not work properly.
    pub on_aud_prev_rec_frame: ::std::option::Option<unsafe extern "C" fn(frame: *mut pjmedia_frame)>,
}

extern "C" {
    /// Use this function to initialize media config.
///
/// @param cfg	The media config to be initialized.
    pub fn pjsua_media_config_default(cfg: *mut pjsua_media_config);
}

/// This structure describes codec information, which can be retrieved by
/// calling #pjsua_enum_codecs().
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsua_codec_info {
    /// Codec unique identification.
    pub codec_id: pj_str_t,
    /// Codec priority (integer 0-255).
    pub priority: pj_uint8_t,
    /// Codec description.
    pub desc: pj_str_t,
    /// Internal buffer.
    pub buf_: [::std::os::raw::c_char; 64usize],
}

/// This structure descibes information about a particular media port that
/// has been registered into the conference bridge. Application can query
/// this info by calling #pjsua_conf_get_port_info().
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsua_conf_port_info {
    /// Conference port number.
    pub slot_id: pjsua_conf_port_id,
    /// Port name.
    pub name: pj_str_t,
    /// Format.
    pub format: pjmedia_format,
    /// Clock rate.
    pub clock_rate: ::std::os::raw::c_uint,
    /// Number of channels.
    pub channel_count: ::std::os::raw::c_uint,
    /// Samples per frame
    pub samples_per_frame: ::std::os::raw::c_uint,
    /// Bits per sample
    pub bits_per_sample: ::std::os::raw::c_uint,
    /// Tx level adjustment.
    pub tx_level_adj: f32,
    /// Rx level adjustment.
    pub rx_level_adj: f32,
    /// Number of listeners in the array.
    pub listener_cnt: ::std::os::raw::c_uint,
    /// Array of listeners (in other words, ports where this port is
    /// transmitting to.
    pub listeners: [pjsua_conf_port_id; 254usize],
}

/// This structure holds information about custom media transport to
/// be registered to pjsua.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsua_media_transport {
    /// Media socket information containing the address information
    /// of the RTP and RTCP socket.
    pub skinfo: pjmedia_sock_info,
    /// The media transport instance.
    pub transport: *mut pjmedia_transport,
}

#[repr(i32)]
/// Sound device index constants.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsua_snd_dev_id {
    /// Constant to denote default capture device.
    PJSUA_SND_DEFAULT_CAPTURE_DEV = -1,
    /// Constant to denote default playback device.
    PJSUA_SND_DEFAULT_PLAYBACK_DEV = -2,
    /// Constant to denote that no sound device is being used.
    PJSUA_SND_NO_DEV = -3,
    /// Constant to denote null sound device.
    PJSUA_SND_NULL_DEV = -99,
}

#[repr(u32)]
/// This enumeration specifies the sound device mode.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsua_snd_dev_mode {
    /// Open sound device without mic (speaker only).
    PJSUA_SND_DEV_SPEAKER_ONLY = 1,
    /// Do not open sound device, after setting the sound device.
    PJSUA_SND_DEV_NO_IMMEDIATE_OPEN = 2,
}

/// This structure specifies the parameters to set the sound device.
/// Use pjsua_snd_dev_param_default() to initialize this structure with
/// default values.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsua_snd_dev_param { pub capture_dev: ::std::os::raw::c_int, pub playback_dev: ::std::os::raw::c_int, pub mode: ::std::os::raw::c_uint }

extern "C" {
    /// Initialize pjsua_snd_dev_param with default values.
///
/// @param prm		The parameter.
    pub fn pjsua_snd_dev_param_default(prm: *mut pjsua_snd_dev_param);
}

extern "C" {
    /// Get maxinum number of conference ports.
///
/// @return		Maximum number of ports in the conference bridge.
    pub fn pjsua_conf_get_max_ports() -> ::std::os::raw::c_uint;
}

extern "C" {
    /// Get current number of active ports in the bridge.
///
/// @return		The number.
    pub fn pjsua_conf_get_active_ports() -> ::std::os::raw::c_uint;
}

extern "C" {
    /// Enumerate all conference ports.
///
/// @param id		Array of conference port ID to be initialized.
/// @param count		On input, specifies max elements in the array.
/// On return, it contains actual number of elements
/// that have been initialized.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_enum_conf_ports(id: *mut pjsua_conf_port_id, count: *mut ::std::os::raw::c_uint) -> pj_status_t;
}

extern "C" {
    /// Get information about the specified conference port
///
/// @param port_id	Port identification.
/// @param info		Pointer to store the port info.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_conf_get_port_info(port_id: pjsua_conf_port_id, info: *mut pjsua_conf_port_info) -> pj_status_t;
}

extern "C" {
    /// Add arbitrary media port to PJSUA's conference bridge. Application
/// can use this function to add the media port that it creates. For
/// media ports that are created by PJSUA-LIB (such as calls, file player,
/// or file recorder), PJSUA-LIB will automatically add the port to
/// the bridge.
///
/// @param pool		Pool to use.
/// @param port		Media port to be added to the bridge.
/// @param p_id		Optional pointer to receive the conference
/// slot id.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_conf_add_port(pool: *mut pj_pool_t, port: *mut pjmedia_port, p_id: *mut pjsua_conf_port_id) -> pj_status_t;
}

extern "C" {
    /// Remove arbitrary slot from the conference bridge. Application should only
/// call this function if it registered the port manually with previous call
/// to #pjsua_conf_add_port().
///
/// @param port_id	The slot id of the port to be removed.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_conf_remove_port(port_id: pjsua_conf_port_id) -> pj_status_t;
}

extern "C" {
    /// Establish unidirectional media flow from souce to sink. One source
/// may transmit to multiple destinations/sink. And if multiple
/// sources are transmitting to the same sink, the media will be mixed
/// together. Source and sink may refer to the same ID, effectively
/// looping the media.
///
/// If bidirectional media flow is desired, application needs to call
/// this function twice, with the second one having the arguments
/// reversed.
///
/// @param source	Port ID of the source media/transmitter.
/// @param sink		Port ID of the destination media/received.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_conf_connect(source: pjsua_conf_port_id, sink: pjsua_conf_port_id) -> pj_status_t;
}

extern "C" {
    /// Disconnect media flow from the source to destination port.
///
/// @param source	Port ID of the source media/transmitter.
/// @param sink		Port ID of the destination media/received.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_conf_disconnect(source: pjsua_conf_port_id, sink: pjsua_conf_port_id) -> pj_status_t;
}

extern "C" {
    /// Adjust the signal level to be transmitted from the bridge to the
/// specified port by making it louder or quieter.
///
/// @param slot		The conference bridge slot number.
/// @param level		Signal level adjustment. Value 1.0 means no level
/// adjustment, while value 0 means to mute the port.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_conf_adjust_tx_level(slot: pjsua_conf_port_id, level: f32) -> pj_status_t;
}

extern "C" {
    /// Adjust the signal level to be received from the specified port (to
/// the bridge) by making it louder or quieter.
///
/// @param slot		The conference bridge slot number.
/// @param level		Signal level adjustment. Value 1.0 means no level
/// adjustment, while value 0 means to mute the port.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_conf_adjust_rx_level(slot: pjsua_conf_port_id, level: f32) -> pj_status_t;
}

extern "C" {
    /// Get last signal level transmitted to or received from the specified port.
/// The signal level is an integer value in zero to 255, with zero indicates
/// no signal, and 255 indicates the loudest signal level.
///
/// @param slot		The conference bridge slot number.
/// @param tx_level	Optional argument to receive the level of signal
/// transmitted to the specified port (i.e. the direction
/// is from the bridge to the port).
/// @param rx_level	Optional argument to receive the level of signal
/// received from the port (i.e. the direction is from the
/// port to the bridge).
///
/// @return		PJ_SUCCESS on success.
    pub fn pjsua_conf_get_signal_level(slot: pjsua_conf_port_id, tx_level: *mut ::std::os::raw::c_uint, rx_level: *mut ::std::os::raw::c_uint) -> pj_status_t;
}

extern "C" {
    /// Create a file player, and automatically add this player to
/// the conference bridge.
///
/// @param filename	The filename to be played. Currently only
/// WAV files are supported, and the WAV file MUST be
/// formatted as 16bit PCM mono/single channel (any
/// clock rate is supported).
/// @param options	Optional option flag. Application may specify
/// PJMEDIA_FILE_NO_LOOP to prevent playback loop.
/// @param p_id		Pointer to receive player ID.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_player_create(filename: *const pj_str_t, options: ::std::os::raw::c_uint, p_id: *mut pjsua_player_id) -> pj_status_t;
}

extern "C" {
    /// Create a file playlist media port, and automatically add the port
/// to the conference bridge.
///
/// @param file_names	Array of file names to be added to the play list.
/// Note that the files must have the same clock rate,
/// number of channels, and number of bits per sample.
/// @param file_count	Number of files in the array.
/// @param label		Optional label to be set for the media port.
/// @param options	Optional option flag. Application may specify
/// PJMEDIA_FILE_NO_LOOP to prevent looping.
/// @param p_id		Optional pointer to receive player ID.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_playlist_create(file_names: *const pj_str_t, file_count: ::std::os::raw::c_uint, label: *const pj_str_t, options: ::std::os::raw::c_uint, p_id: *mut pjsua_player_id) -> pj_status_t;
}

extern "C" {
    /// Get conference port ID associated with player or playlist.
///
/// @param id		The file player ID.
///
/// @return		Conference port ID associated with this player.
    pub fn pjsua_player_get_conf_port(id: pjsua_player_id) -> pjsua_conf_port_id;
}

extern "C" {
    /// Get the media port for the player or playlist.
///
/// @param id		The player ID.
/// @param p_port	The media port associated with the player.
///
/// @return		PJ_SUCCESS on success.
    pub fn pjsua_player_get_port(id: pjsua_player_id, p_port: *mut *mut pjmedia_port) -> pj_status_t;
}

extern "C" {
    /// Get additional info about the file player. This operation is not valid
/// for playlist.
///
/// @param port		The file player ID.
/// @param info		The info.
///
/// @return		PJ_SUCCESS on success or the appropriate error code.
    pub fn pjsua_player_get_info(id: pjsua_player_id, info: *mut pjmedia_wav_player_info) -> pj_status_t;
}

extern "C" {
    /// Get playback position. This operation is not valid for playlist.
///
/// @param id		The file player ID.
///
/// @return		The current playback position, in samples. On error,
/// return the error code as negative value.
    pub fn pjsua_player_get_pos(id: pjsua_player_id) -> pj_ssize_t;
}

extern "C" {
    /// Set playback position. This operation is not valid for playlist.
///
/// @param id		The file player ID.
/// @param samples	The playback position, in samples. Application can
/// specify zero to re-start the playback.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_player_set_pos(id: pjsua_player_id, samples: pj_uint32_t) -> pj_status_t;
}

extern "C" {
    /// Close the file of playlist, remove the player from the bridge, and free
/// resources associated with the file player or playlist.
///
/// @param id		The file player ID.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_player_destroy(id: pjsua_player_id) -> pj_status_t;
}

extern "C" {
    /// Create a file recorder, and automatically connect this recorder to
/// the conference bridge. The recorder currently supports recording WAV file.
/// The type of the recorder to use is determined by the extension of the file
/// (e.g. ".wav").
///
/// @param filename	Output file name. The function will determine the
/// default format to be used based on the file extension.
/// Currently ".wav" is supported on all platforms.
/// @param enc_type	Optionally specify the type of encoder to be used to
/// compress the media, if the file can support different
/// encodings. This value must be zero for now.
/// @param enc_param	Optionally specify codec specific parameter to be
/// passed to the file writer.
/// For .WAV recorder, this value must be NULL.
/// @param max_size	Maximum file size. Specify zero or -1 to remove size
/// limitation. This value must be zero or -1 for now.
/// @param options	Optional options.
/// @param p_id		Pointer to receive the recorder instance.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_recorder_create(filename: *const pj_str_t, enc_type: ::std::os::raw::c_uint, enc_param: *mut ::std::os::raw::c_void, max_size: pj_ssize_t, options: ::std::os::raw::c_uint, p_id: *mut pjsua_recorder_id) -> pj_status_t;
}

extern "C" {
    /// Get conference port associated with recorder.
///
/// @param id		The recorder ID.
///
/// @return		Conference port ID associated with this recorder.
    pub fn pjsua_recorder_get_conf_port(id: pjsua_recorder_id) -> pjsua_conf_port_id;
}

extern "C" {
    /// Get the media port for the recorder.
///
/// @param id		The recorder ID.
/// @param p_port	The media port associated with the recorder.
///
/// @return		PJ_SUCCESS on success.
    pub fn pjsua_recorder_get_port(id: pjsua_recorder_id, p_port: *mut *mut pjmedia_port) -> pj_status_t;
}

extern "C" {
    /// Destroy recorder (this will complete recording).
///
/// @param id		The recorder ID.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_recorder_destroy(id: pjsua_recorder_id) -> pj_status_t;
}

extern "C" {
    /// Enum all audio devices installed in the system.
///
/// @param info		Array of info to be initialized.
/// @param count		On input, specifies max elements in the array.
/// On return, it contains actual number of elements
/// that have been initialized.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_enum_aud_devs(info: *mut pjmedia_aud_dev_info, count: *mut ::std::os::raw::c_uint) -> pj_status_t;
}

extern "C" {
    /// Enum all sound devices installed in the system (old API).
///
/// @param info		Array of info to be initialized.
/// @param count		On input, specifies max elements in the array.
/// On return, it contains actual number of elements
/// that have been initialized.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_enum_snd_devs(info: *mut pjmedia_snd_dev_info, count: *mut ::std::os::raw::c_uint) -> pj_status_t;
}

extern "C" {
    /// Get currently active sound devices. If sound devices has not been created
/// (for example when pjsua_start() is not called), it is possible that
/// the function returns PJ_SUCCESS with -1 as device IDs.
/// See also #pjsua_snd_dev_id constants.
///
/// @param capture_dev   On return it will be filled with device ID of the
/// capture device.
/// @param playback_dev	On return it will be filled with device ID of the
/// device ID of the playback device.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_get_snd_dev(capture_dev: *mut ::std::os::raw::c_int, playback_dev: *mut ::std::os::raw::c_int) -> pj_status_t;
}

extern "C" {
    /// Select or change sound device. Application may call this function at
/// any time to replace current sound device.
///
/// @param capture_dev   Device ID of the capture device.
/// @param playback_dev	Device ID of the playback device.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_set_snd_dev(capture_dev: ::std::os::raw::c_int, playback_dev: ::std::os::raw::c_int) -> pj_status_t;
}

extern "C" {
    /// Select or change sound device according to the specified param.
///
/// @param snd_param	Sound device param.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_set_snd_dev2(snd_param: *mut pjsua_snd_dev_param) -> pj_status_t;
}

extern "C" {
    /// Set pjsua to use null sound device. The null sound device only provides
/// the timing needed by the conference bridge, and will not interract with
/// any hardware.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_set_null_snd_dev() -> pj_status_t;
}

extern "C" {
    /// Disconnect the main conference bridge from any sound devices, and let
/// application connect the bridge to it's own sound device/master port.
///
/// @return		The port interface of the conference bridge,
/// so that application can connect this to it's own
/// sound device or master port.
    pub fn pjsua_set_no_snd_dev() -> *mut pjmedia_port;
}

extern "C" {
    /// Change the echo cancellation settings.
///
/// The behavior of this function depends on whether the sound device is
/// currently active, and if it is, whether device or software AEC is
/// being used.
///
/// If the sound device is currently active, and if the device supports AEC,
/// this function will forward the change request to the device and it will
/// be up to the device on whether support the request. If software AEC is
/// being used (the software EC will be used if the device does not support
/// AEC), this function will change the software EC settings. In all cases,
/// the setting will be saved for future opening of the sound device.
///
/// If the sound device is not currently active, this will only change the
/// default AEC settings and the setting will be applied next time the
/// sound device is opened.
///
/// @param tail_ms	The tail length, in miliseconds. Set to zero to
/// disable AEC.
/// @param options	Options to be passed to pjmedia_echo_create().
/// Normally the value should be zero.
///
/// @return		PJ_SUCCESS on success.
    pub fn pjsua_set_ec(tail_ms: ::std::os::raw::c_uint, options: ::std::os::raw::c_uint) -> pj_status_t;
}

extern "C" {
    /// Get current echo canceller tail length.
///
/// @param p_tail_ms	Pointer to receive the tail length, in miliseconds.
/// If AEC is disabled, the value will be zero.
///
/// @return		PJ_SUCCESS on success.
    pub fn pjsua_get_ec_tail(p_tail_ms: *mut ::std::os::raw::c_uint) -> pj_status_t;
}

extern "C" {
    /// Check whether the sound device is currently active. The sound device
/// may be inactive if the application has set the auto close feature to
/// non-zero (the snd_auto_close_time setting in #pjsua_media_config), or
/// if null sound device or no sound device has been configured via the
/// #pjsua_set_no_snd_dev() function.
    pub fn pjsua_snd_is_active() -> pj_bool_t;
}

extern "C" {
    /// Configure sound device setting to the sound device being used. If sound
/// device is currently active, the function will forward the setting to the
/// sound device instance to be applied immediately, if it supports it.
///
/// The setting will be saved for future opening of the sound device, if the
/// "keep" argument is set to non-zero. If the sound device is currently
/// inactive, and the "keep" argument is false, this function will return
/// error.
///
/// Note that in case the setting is kept for future use, it will be applied
/// to any devices, even when application has changed the sound device to be
/// used.
///
/// Note also that the echo cancellation setting should be set with
/// #pjsua_set_ec() API instead.
///
/// See also #pjmedia_aud_stream_set_cap() for more information about setting
/// an audio device capability.
///
/// @param cap		The sound device setting to change.
/// @param pval		Pointer to value. Please see #pjmedia_aud_dev_cap
/// documentation about the type of value to be
/// supplied for each setting.
/// @param keep		Specify whether the setting is to be kept for future
/// use.
///
/// @return		PJ_SUCCESS on success or the appropriate error code.
    pub fn pjsua_snd_set_setting(cap: pjmedia_aud_dev_cap, pval: *const ::std::os::raw::c_void, keep: pj_bool_t) -> pj_status_t;
}

extern "C" {
    /// Retrieve a sound device setting. If sound device is currently active,
/// the function will forward the request to the sound device. If sound device
/// is currently inactive, and if application had previously set the setting
/// and mark the setting as kept, then that setting will be returned.
/// Otherwise, this function will return error.
///
/// Note that echo cancellation settings should be retrieved with
/// #pjsua_get_ec_tail() API instead.
///
/// @param cap		The sound device setting to retrieve.
/// @param pval		Pointer to receive the value.
/// Please see #pjmedia_aud_dev_cap documentation about
/// the type of value to be supplied for each setting.
///
/// @return		PJ_SUCCESS on success or the appropriate error code.
    pub fn pjsua_snd_get_setting(cap: pjmedia_aud_dev_cap, pval: *mut ::std::os::raw::c_void) -> pj_status_t;
}

extern "C" {
    /// Enum all supported codecs in the system.
///
/// @param id		Array of ID to be initialized.
/// @param count		On input, specifies max elements in the array.
/// On return, it contains actual number of elements
/// that have been initialized.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_enum_codecs(id: *mut pjsua_codec_info, count: *mut ::std::os::raw::c_uint) -> pj_status_t;
}

extern "C" {
    /// Change codec priority.
///
/// @param codec_id	Codec ID, which is a string that uniquely identify
/// the codec (such as "speex/8000"). Please see pjsua
/// manual or pjmedia codec reference for details.
/// @param priority	Codec priority, 0-255, where zero means to disable
/// the codec.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_codec_set_priority(codec_id: *const pj_str_t, priority: pj_uint8_t) -> pj_status_t;
}

extern "C" {
    /// Get codec parameters.
///
/// @param codec_id	Codec ID.
/// @param param		Structure to receive codec parameters.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_codec_get_param(codec_id: *const pj_str_t, param: *mut pjmedia_codec_param) -> pj_status_t;
}

extern "C" {
    /// Set codec parameters.
///
/// @param codec_id	Codec ID.
/// @param param		Codec parameter to set. Set to NULL to reset
/// codec parameter to library default settings.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_codec_set_param(codec_id: *const pj_str_t, param: *const pjmedia_codec_param) -> pj_status_t;
}

extern "C" {
    /// Get the number of video devices installed in the system.
///
/// @return		The number of devices.
    pub fn pjsua_vid_dev_count() -> ::std::os::raw::c_uint;
}

extern "C" {
    /// Retrieve the video device info for the specified device index.
///
/// @param id		The device index.
/// @param vdi		Device info to be initialized.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_vid_dev_get_info(id: pjmedia_vid_dev_index, vdi: *mut pjmedia_vid_dev_info) -> pj_status_t;
}

extern "C" {
    /// Check whether the video capture device is currently active, i.e. if
/// a video preview has been started or there is a video call using
/// the device. This function will return PJ_FALSE for video renderer device.
///
/// @param id		The video device index.
///
/// @return		PJ_TRUE if active, PJ_FALSE otherwise.
    pub fn pjsua_vid_dev_is_active(id: pjmedia_vid_dev_index) -> pj_bool_t;
}

extern "C" {
    /// Configure the capability of a video capture device. If the device is
/// currently active (i.e. if there is a video call using the device or
/// a video preview has been started), the function will forward the setting
/// to the video device instance to be applied immediately, if it supports it.
///
/// The setting will be saved for future opening of the video device, if the
/// "keep" argument is set to non-zero. If the video device is currently
/// inactive, and the "keep" argument is false, this function will return
/// error.
///
/// Note: This function will only works for video capture devices. To
/// configure the setting of video renderer device instances, use
/// pjsua_vid_win API instead.
///
/// Warning: If application refreshes the video device list, it needs to
/// manually update the settings to reflect the newly updated video device
/// indexes. See #pjmedia_vid_dev_refresh() for more information.
///
/// See also #pjmedia_vid_stream_set_cap() for more information about setting
/// a video device capability.
///
/// @param id		The video device index.
/// @param cap		The video device capability to change.
/// @param pval		Pointer to value. Please see #pjmedia_vid_dev_cap
/// documentation about the type of value to be
/// supplied for each setting.
///
/// @return		PJ_SUCCESS on success or the appropriate error code.
    pub fn pjsua_vid_dev_set_setting(id: pjmedia_vid_dev_index, cap: pjmedia_vid_dev_cap, pval: *const ::std::os::raw::c_void, keep: pj_bool_t) -> pj_status_t;
}

extern "C" {
    /// Retrieve the value of a video capture device setting. If the device is
/// currently active (i.e. if there is a video call using the device or
/// a video preview has been started), the function will forward the request
/// to the video device. If video device is currently inactive, and if
/// application had previously set the setting and mark the setting as kept,
/// then that setting will be returned. Otherwise, this function will return
/// error.
/// The function only works for video capture device.
///
/// @param id		The video device index.
/// @param cap		The video device capability to retrieve.
/// @param pval		Pointer to receive the value.
/// Please see #pjmedia_vid_dev_cap documentation about
/// the type of value to be supplied for each setting.
///
/// @return		PJ_SUCCESS on success or the appropriate error code.
    pub fn pjsua_vid_dev_get_setting(id: pjmedia_vid_dev_index, cap: pjmedia_vid_dev_cap, pval: *mut ::std::os::raw::c_void) -> pj_status_t;
}

extern "C" {
    /// Enum all video devices installed in the system.
///
/// @param info		Array of info to be initialized.
/// @param count		On input, specifies max elements in the array.
/// On return, it contains actual number of elements
/// that have been initialized.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_vid_enum_devs(info: *mut pjmedia_vid_dev_info, count: *mut ::std::os::raw::c_uint) -> pj_status_t;
}

/// Parameters for starting video preview with pjsua_vid_preview_start().
/// Application should initialize this structure with
/// pjsua_vid_preview_param_default().
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsua_vid_preview_param {
    /// Device ID for the video renderer to be used for rendering the
    /// capture stream for preview. This parameter is ignored if native
    /// preview is being used.
    ///
    /// Default: PJMEDIA_VID_DEFAULT_RENDER_DEV
    pub rend_id: pjmedia_vid_dev_index,
    /// Show window initially.
    ///
    /// Default: PJ_TRUE.
    pub show: pj_bool_t,
    /// Window flags.  The value is a bitmask combination of
    /// #pjmedia_vid_dev_wnd_flag.
    ///
    /// Default: 0.
    pub wnd_flags: ::std::os::raw::c_uint,
    /// Media format. Initialize this with #pjmedia_format_init_video().
    /// If left unitialized, this parameter will not be used.
    pub format: pjmedia_format,
    /// Optional output window to be used to display the video preview.
    /// This parameter will only be used if the video device supports
    /// PJMEDIA_VID_DEV_CAP_OUTPUT_WINDOW capability and the capability
    /// is not read-only.
    pub wnd: pjmedia_vid_dev_hwnd,
}

extern "C" {
    /// Initialize pjsua_vid_preview_param
///
/// @param p		The parameter to be initialized.
    pub fn pjsua_vid_preview_param_default(p: *mut pjsua_vid_preview_param);
}

extern "C" {
    /// Determine if the specified video input device has built-in native
/// preview capability. This is a convenience function that is equal to
/// querying device's capability for PJMEDIA_VID_DEV_CAP_INPUT_PREVIEW
/// capability.
///
/// @param id		The capture device ID.
///
/// @return		PJ_TRUE if it has.
    pub fn pjsua_vid_preview_has_native(id: pjmedia_vid_dev_index) -> pj_bool_t;
}

extern "C" {
    /// Start video preview window for the specified capture device.
///
/// @param id		The capture device ID where its preview will be
/// started.
/// @param p		Optional video preview parameters. Specify NULL
/// to use default values.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_vid_preview_start(id: pjmedia_vid_dev_index, p: *const pjsua_vid_preview_param) -> pj_status_t;
}

extern "C" {
    /// Get the preview window handle associated with the capture device, if any.
///
/// @param id		The capture device ID.
///
/// @return		The window ID of the preview window for the
/// specified capture device ID, or PJSUA_INVALID_ID if
/// preview has not been started for the device.
    pub fn pjsua_vid_preview_get_win(id: pjmedia_vid_dev_index) -> pjsua_vid_win_id;
}

extern "C" {
    /// Stop video preview.
///
/// @param id		The capture device ID.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_vid_preview_stop(id: pjmedia_vid_dev_index) -> pj_status_t;
}

/// This structure describes video window info.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsua_vid_win_info {
    /// Flag to indicate whether this window is a native window,
    /// such as created by built-in preview device. If this field is
    /// PJ_TRUE, only the native window handle field of this
    /// structure is valid.
    pub is_native: pj_bool_t,
    /// Native window handle.
    pub hwnd: pjmedia_vid_dev_hwnd,
    /// Renderer device ID.
    pub rdr_dev: pjmedia_vid_dev_index,
    /// Window show status. The window is hidden if false.
    pub show: pj_bool_t,
    /// Window position.
    pub pos: pjmedia_coord,
    /// Window size.
    pub size: pjmedia_rect_size,
}

extern "C" {
    /// Enumerates all video windows.
///
/// @param id		Array of window ID to be initialized.
/// @param count		On input, specifies max elements in the array.
/// On return, it contains actual number of elements
/// that have been initialized.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_vid_enum_wins(wids: *mut pjsua_vid_win_id, count: *mut ::std::os::raw::c_uint) -> pj_status_t;
}

extern "C" {
    /// Get window info.
///
/// @param wid		The video window ID.
/// @param wi		The video window info to be initialized.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_vid_win_get_info(wid: pjsua_vid_win_id, wi: *mut pjsua_vid_win_info) -> pj_status_t;
}

extern "C" {
    /// Show or hide window. This operation is not valid for native windows
/// (pjsua_vid_win_info.is_native=PJ_TRUE), on which native windowing API
/// must be used instead.
///
/// @param wid		The video window ID.
/// @param show		Set to PJ_TRUE to show the window, PJ_FALSE to
/// hide the window.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_vid_win_set_show(wid: pjsua_vid_win_id, show: pj_bool_t) -> pj_status_t;
}

extern "C" {
    /// Set video window position. This operation is not valid for native windows
/// (pjsua_vid_win_info.is_native=PJ_TRUE), on which native windowing API
/// must be used instead.
///
/// @param wid		The video window ID.
/// @param pos		The window position.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_vid_win_set_pos(wid: pjsua_vid_win_id, pos: *const pjmedia_coord) -> pj_status_t;
}

extern "C" {
    /// Resize window. This operation is not valid for native windows
/// (pjsua_vid_win_info.is_native=PJ_TRUE), on which native windowing API
/// must be used instead.
///
/// @param wid		The video window ID.
/// @param size		The new window size.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_vid_win_set_size(wid: pjsua_vid_win_id, size: *const pjmedia_rect_size) -> pj_status_t;
}

extern "C" {
    /// Set output window. This operation is valid only when the underlying
/// video device supports PJMEDIA_VIDEO_DEV_CAP_OUTPUT_WINDOW capability AND
/// allows the output window to be changed on-the-fly. Currently it is only
/// supported on Android.
///
/// @param wid		The video window ID.
/// @param win		The new output window.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_vid_win_set_win(wid: pjsua_vid_win_id, win: *const pjmedia_vid_dev_hwnd) -> pj_status_t;
}

extern "C" {
    /// Rotate the video window. This function will change the video orientation
/// and also possibly the video window size (width and height get swapped).
/// This operation is not valid for native windows (pjsua_vid_win_info.is_native
/// =PJ_TRUE), on which native windowing API must be used instead.
///
/// @param wid		The video window ID.
/// @param angle		The rotation angle in degrees, must be multiple of 90.
/// Specify positive value for clockwise rotation or
/// negative value for counter-clockwise rotation.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_vid_win_rotate(wid: pjsua_vid_win_id, angle: ::std::os::raw::c_int) -> pj_status_t;
}

extern "C" {
    /// Enum all supported video codecs in the system.
///
/// @param id		Array of ID to be initialized.
/// @param count		On input, specifies max elements in the array.
/// On return, it contains actual number of elements
/// that have been initialized.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_vid_enum_codecs(id: *mut pjsua_codec_info, count: *mut ::std::os::raw::c_uint) -> pj_status_t;
}

extern "C" {
    /// Change video codec priority.
///
/// @param codec_id	Codec ID, which is a string that uniquely identify
/// the codec (such as "H263/90000"). Please see pjsua
/// manual or pjmedia codec reference for details.
/// @param priority	Codec priority, 0-255, where zero means to disable
/// the codec.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_vid_codec_set_priority(codec_id: *const pj_str_t, priority: pj_uint8_t) -> pj_status_t;
}

extern "C" {
    /// Get video codec parameters.
///
/// @param codec_id	Codec ID.
/// @param param		Structure to receive video codec parameters.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_vid_codec_get_param(codec_id: *const pj_str_t, param: *mut pjmedia_vid_codec_param) -> pj_status_t;
}

extern "C" {
    /// Set video codec parameters.
///
/// @param codec_id	Codec ID.
/// @param param		Codec parameter to set. Set to NULL to reset
/// codec parameter to library default settings.
///
/// @return		PJ_SUCCESS on success, or the appropriate error code.
    pub fn pjsua_vid_codec_set_param(codec_id: *const pj_str_t, param: *const pjmedia_vid_codec_param) -> pj_status_t;
}

/// Call's media stream.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsua_call_media {
    /// < Parent call.
    pub call: *mut pjsua_call,
    /// < Media type.
    pub type_: pjmedia_type,
    /// < This media index in parent call.
    pub idx: ::std::os::raw::c_uint,
    /// < Media state.
    pub state: pjsua_call_media_status,
    /// < Previous media state.
    pub prev_state: pjsua_call_media_status,
    /// < Media direction.
    pub dir: pjmedia_dir,
    pub strm: pjsua_call_media__bindgen_ty_1,
    /// < RTP SSRC
    pub ssrc: pj_uint32_t,
    /// < Initial RTP timestamp for sender.
    pub rtp_tx_ts: pj_uint32_t,
    /// < Initial RTP sequence for sender.
    pub rtp_tx_seq: pj_uint16_t,
    pub rtp_tx_seq_ts_set: pj_uint8_t,
    /// < Current media transport (can be 0)
    pub tp: *mut pjmedia_transport,
    /// < Media transport status.
    pub tp_ready: pj_status_t,
    /// < Media transport creation result.
    pub tp_result: pj_status_t,
    /// < Original media transport
    pub tp_orig: *mut pjmedia_transport,
    /// < May delete media transport
    pub tp_auto_del: pj_bool_t,
    /// < Media transport state
    pub tp_st: pjsua_med_tp_st,
    /// < Use custom media transport?
    pub use_custom_med_tp: pj_bool_t,
    /// < Current RTP source address
    /// (used to update ICE default
    /// address)
    pub rtp_addr: pj_sockaddr,
    /// < Remote's SRTP usage policy.
    pub rem_srtp_use: pjmedia_srtp_use,
    /// < Last TX keyframe request.
    pub last_req_keyframe: pj_timestamp,
    /// < Media transport
    /// initialization callback.
    pub med_init_cb: pjsua_med_tp_state_cb,
    /// Media transport creation callback.
    pub med_create_cb: ::std::option::Option<unsafe extern "C" fn(call_med: *mut pjsua_call_media, status: pj_status_t, security_level: ::std::os::raw::c_int, sip_err_code: *mut ::std::os::raw::c_int) -> pj_status_t>,
}

/// The stream
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsua_call_media__bindgen_ty_1 { pub a: pjsua_call_media__bindgen_ty_1__bindgen_ty_1, pub v: pjsua_call_media__bindgen_ty_1__bindgen_ty_2 }

/// Audio stream
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsua_call_media__bindgen_ty_1__bindgen_ty_1 {
    /// < The audio stream.
    pub stream: *mut pjmedia_stream,
    /// < The media port.
    pub media_port: *mut pjmedia_port,
    /// < Destroy the media port?
    pub destroy_port: pj_bool_t,
    /// < Slot # in conference bridge.
    pub conf_slot: ::std::os::raw::c_int,
}

/// Video stream
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsua_call_media__bindgen_ty_1__bindgen_ty_2 {
    /// < The video stream.
    pub stream: *mut pjmedia_vid_stream,
    /// < The video capture window
    pub cap_win_id: pjsua_vid_win_id,
    /// < The video render window
    pub rdr_win_id: pjsua_vid_win_id,
    /// < The video capture device
    pub cap_dev: pjmedia_vid_dev_index,
    /// < The video-in render device
    pub rdr_dev: pjmedia_vid_dev_index,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct call_answer {
    pub prev: *mut call_answer,
    pub next: *mut call_answer,
    /// < Answer's headers list.
    pub msg_data: *mut pjsua_msg_data,
    /// < Answer's reason phrase.
    pub reason: *mut pj_str_t,
    /// < Answer's status code.
    pub code: ::std::os::raw::c_uint,
    /// < Answer's call setting.
    pub opt: *mut pjsua_call_setting,
}

/// Structure to be attached to invite dialog.
/// Given a dialog "dlg", application can retrieve this structure
/// by accessing dlg->mod_data[pjsua.mod.id].
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsua_call {
    /// < Index in pjsua array.
    pub index: ::std::os::raw::c_uint,
    /// < Call setting.
    pub opt: pjsua_call_setting,
    /// < Initial call setting has been set,
    /// to avoid different opt in answer.
    pub opt_inited: pj_bool_t,
    /// < The invite session.
    pub inv: *mut pjsip_inv_session,
    /// < User/application data.
    pub user_data: *mut ::std::os::raw::c_void,
    /// < Last status code seen.
    pub last_code: pjsip_status_code,
    /// < Last status text seen.
    pub last_text: pj_str_t,
    /// < First INVITE sent/received.
    pub start_time: pj_time_val,
    /// < First response sent/received.
    pub res_time: pj_time_val,
    /// < Connected/confirmed time.
    pub conn_time: pj_time_val,
    /// < Disconnect time.
    pub dis_time: pj_time_val,
    /// < Account index being used.
    pub acc_id: pjsua_acc_id,
    /// < Signaling security level.
    pub secure_level: ::std::os::raw::c_int,
    /// < How to do call hold.
    pub call_hold_type: pjsua_call_hold_type,
    /// < Flag for call-hold by local.
    pub local_hold: pj_bool_t,
    /// < Outgoing hold tx_data.
    pub hold_msg: *mut ::std::os::raw::c_void,
    /// < Number of media in SDP.
    pub med_cnt: ::std::os::raw::c_uint,
    /// < Array of media
    pub media: [pjsua_call_media; 16usize],
    /// < Number of provisional media.
    pub med_prov_cnt: ::std::os::raw::c_uint,
    pub media_prov: [pjsua_call_media; 16usize],
    pub med_update_success: pj_bool_t,
    /// < Is call in the process of hangup?
    pub hanging_up: pj_bool_t,
    /// < First active audio media.
    pub audio_idx: ::std::os::raw::c_int,
    /// < Media channel callback's mutex.
    pub med_ch_mutex: *mut pj_mutex_t,
    /// < Media channel callback.
    pub med_ch_cb: pjsua_med_tp_state_cb,
    /// < Media channel info.
    pub med_ch_info: pjsua_med_tp_state_info,
    /// < Xfer server subscription, if this
    /// call was triggered by xfer.
    pub xfer_sub: *mut pjsip_evsub,
    /// < NAT type of remote endpoint.
    pub rem_nat_type: pj_stun_nat_type,
    /// < Buffer for last_text.
    pub last_text_buf_: [::std::os::raw::c_char; 128usize],
    /// < Data for codec locking when answer
    /// contains multiple codecs.
    pub lock_codec: pjsua_call__bindgen_ty_1,
    /// < Temporary storage for async
    /// outgoing/incoming call.
    pub async_call: pjsua_call__bindgen_ty_2,
    /// < Was remote SDP offerer?
    pub rem_offerer: pj_bool_t,
    /// < No of active audio in last remote
    /// offer.
    pub rem_aud_cnt: ::std::os::raw::c_uint,
    /// < No of active video in last remote
    /// offer.
    pub rem_vid_cnt: ::std::os::raw::c_uint,
    /// < Reinvite retry timer.
    pub reinv_timer: pj_timer_entry,
    /// < Pending until CONFIRMED state.
    pub reinv_pending: pj_bool_t,
    /// < Has reinvite for ICE upd sent?
    pub reinv_ice_sent: pj_bool_t,
    /// < Cloned incoming call rdata.
    /// On pjsua2, when handling incoming
    /// call, onCreateMediaTransport() will
    /// not be called since the call isn't
    /// created yet. This temporary
    /// variable is used to handle such
    /// case, see ticket #1916.
    pub incoming_data: *mut pjsip_rx_data,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsua_call__bindgen_ty_1 {
    /// < Retry count.
    pub retry_cnt: ::std::os::raw::c_int,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsua_call__bindgen_ty_2 {
    /// < Call dialog.
    pub dlg: *mut pjsip_dialog,
    /// < Remote SDP.
    pub rem_sdp: *mut pjmedia_sdp_session,
    /// < Provisional pool.
    pub pool_prov: *mut pj_pool_t,
    /// < Media channel de-init-ed?
    pub med_ch_deinit: pj_bool_t,
    pub call_var: pjsua_call__bindgen_ty_2__bindgen_ty_1,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union pjsua_call__bindgen_ty_2__bindgen_ty_1 { pub out_call: pjsua_call__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1, pub inc_call: pjsua_call__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2, _bindgen_union_align: [u32; 8usize] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsua_call__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    /// < Headers for outgoing INVITE.
    pub msg_data: *mut pjsua_msg_data,
    /// < Call is hangup?
    pub hangup: pj_bool_t,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsua_call__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    /// < A list of call answers.
    pub answers: call_answer,
    /// < Call is hangup?
    pub hangup: pj_bool_t,
    /// < Replaced dialog.
    pub replaced_dlg: *mut pjsip_dialog,
}

/// Server presence subscription list head.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsua_srv_pres {
    pub prev: *mut pjsua_srv_pres,
    pub next: *mut pjsua_srv_pres,
    /// < The evsub.
    pub sub: *mut pjsip_evsub,
    /// < Remote URI.
    pub remote: *mut ::std::os::raw::c_char,
    /// < Account ID.
    pub acc_id: ::std::os::raw::c_int,
    /// < Dialog.
    pub dlg: *mut pjsip_dialog,
    /// < "expires" value in the request.
    pub expires: ::std::os::raw::c_int,
}

/// Account
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsua_acc {
    /// < Pool for this account.
    pub pool: *mut pj_pool_t,
    /// < Account configuration.
    pub cfg: pjsua_acc_config,
    /// < Is this account valid?
    pub valid: pj_bool_t,
    /// < Index in accounts array.
    pub index: ::std::os::raw::c_int,
    /// < Display name, if any.
    pub display: pj_str_t,
    /// < User part of local URI.
    pub user_part: pj_str_t,
    /// < Local URI uses "sips"?
    pub is_sips: pj_bool_t,
    /// < Our Contact header.
    pub contact: pj_str_t,
    /// < Contact header for REGISTER.
    /// It may be different than acc
    /// contact if outbound is used
    pub reg_contact: pj_str_t,
    pub contact_rewritten: pj_bool_t,
    /// < Address for Via header
    pub via_addr: pjsip_host_port,
    /// < Transport associated with
    /// the Via address
    pub via_tp: *mut pjsip_transport,
    /// < Host part of reg server.
    pub srv_domain: pj_str_t,
    /// < Port number of reg server.
    pub srv_port: ::std::os::raw::c_int,
    /// < Client registration session.
    pub regc: *mut pjsip_regc,
    /// < Last registration error.
    pub reg_last_err: pj_status_t,
    /// < Last status last register.
    pub reg_last_code: ::std::os::raw::c_int,
    /// < Our addr as seen by reg srv.
    /// Only if allow_sdp_nat_rewrite
    /// is set
    pub reg_mapped_addr: pj_str_t,
    /// < Reregister/reconnect data.
    pub auto_rereg: pjsua_acc__bindgen_ty_1,
    /// < Keep-alive timer for UDP.
    pub ka_timer: pj_timer_entry,
    /// < Transport for keep-alive.
    pub ka_transport: *mut pjsip_transport,
    /// < Destination address for K-A
    pub ka_target: pj_sockaddr,
    /// < Length of ka_target.
    pub ka_target_len: ::std::os::raw::c_uint,
    /// < Complete route set inc. outbnd.
    pub route_set: pjsip_route_hdr,
    pub global_route_crc: pj_uint32_t,
    /// CRC of global route setting.
    pub local_route_crc: pj_uint32_t,
    /// < SIP outbound status:
    /// 0: not used
    /// 1: requested
    /// 2: acknowledged by servers
    pub rfc5626_status: ::std::os::raw::c_uint,
    /// < SIP outbound instance param.
    pub rfc5626_instprm: pj_str_t,
    /// < SIP outbound reg param.
    pub rfc5626_regprm: pj_str_t,
    /// < Number of credentials.
    pub cred_cnt: ::std::os::raw::c_uint,
    /// < Complete creds.
    pub cred: [pjsip_cred_info; 8usize],
    /// < Our online status.
    pub online_status: pj_bool_t,
    /// < RPID element information.
    pub rpid: pjrpid_element,
    /// < Server subscription list.
    pub pres_srv_list: pjsua_srv_pres,
    /// < Client publication session.
    pub publish_sess: *mut pjsip_publishc,
    /// < Last published online status
    pub publish_state: pj_bool_t,
    /// < MWI client subscription
    pub mwi_sub: *mut pjsip_evsub,
    /// < Dialog for MWI sub.
    pub mwi_dlg: *mut pjsip_dialog,
    /// < Next RTP port to be used.
    pub next_rtp_port: pj_uint16_t,
    /// < Transport type (for local acc or
    /// transport binding)
    pub tp_type: pjsip_transport_type_e,
    /// < IP change process progress.
    pub ip_change_op: pjsua_ip_change_op,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsua_acc__bindgen_ty_1 {
    /// < Flag of reregister status.
    pub active: pj_bool_t,
    /// < Timer for reregistration.
    pub timer: pj_timer_entry,
    /// < Transport for registration.
    pub reg_tp: *mut ::std::os::raw::c_void,
    /// < Attempt counter.
    pub attempt_cnt: ::std::os::raw::c_uint,
}

/// Transport.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsua_transport_data { pub index: ::std::os::raw::c_int, pub type_: pjsip_transport_type_e, pub local_name: pjsip_host_port, pub data: pjsua_transport_data__bindgen_ty_1, pub is_restarting: pj_bool_t }

#[repr(C)]
#[derive(Copy, Clone)]
pub union pjsua_transport_data__bindgen_ty_1 { pub tp: *mut pjsip_transport, pub factory: *mut pjsip_tpfactory, pub ptr: *mut ::std::os::raw::c_void, _bindgen_union_align: u32 }

/// Buddy data.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsua_buddy {
    /// < Pool for this buddy.
    pub pool: *mut pj_pool_t,
    /// < Buddy index.
    pub index: ::std::os::raw::c_uint,
    /// < Application data.
    pub user_data: *mut ::std::os::raw::c_void,
    /// < Buddy URI.
    pub uri: pj_str_t,
    /// < Contact learned from subscrp.
    pub contact: pj_str_t,
    /// < Buddy name.
    pub name: pj_str_t,
    /// < Buddy display name.
    pub display: pj_str_t,
    /// < Buddy host.
    pub host: pj_str_t,
    /// < Buddy port.
    pub port: ::std::os::raw::c_uint,
    /// < Should we monitor?
    pub monitor: pj_bool_t,
    /// < The underlying dialog.
    pub dlg: *mut pjsip_dialog,
    /// < Buddy presence subscription
    pub sub: *mut pjsip_evsub,
    /// < Subscription termination code
    pub term_code: ::std::os::raw::c_uint,
    /// < Subscription termination reason
    pub term_reason: pj_str_t,
    /// < Buddy presence status.
    pub status: pjsip_pres_status,
    /// < Resubscription timer
    pub timer: pj_timer_entry,
}

/// File player/recorder data.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsua_file_data { pub type_: pj_bool_t, pub port: *mut pjmedia_port, pub pool: *mut pj_pool_t, pub slot: ::std::os::raw::c_uint }

/// Additional parameters for conference bridge.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsua_conf_setting { pub channel_count: ::std::os::raw::c_uint, pub samples_per_frame: ::std::os::raw::c_uint, pub bits_per_sample: ::std::os::raw::c_uint }

#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsua_stun_resolve {
    pub prev: *mut pjsua_stun_resolve,
    pub next: *mut pjsua_stun_resolve,
    /// < Pool
    pub pool: *mut pj_pool_t,
    /// < Reference count
    pub ref_cnt: ::std::os::raw::c_int,
    /// < To be destroyed
    pub destroy_flag: pj_bool_t,
    pub has_result: pj_bool_t,
    /// < # of entries
    pub count: ::std::os::raw::c_uint,
    /// < Array of entries
    pub srv: *mut pj_str_t,
    /// < Current index
    pub idx: ::std::os::raw::c_uint,
    /// < App token
    pub token: *mut ::std::os::raw::c_void,
    /// < App callback
    pub cb: pj_stun_resolve_cb,
    /// < Blocking?
    pub blocking: pj_bool_t,
    /// < Waiting thread
    pub waiter: *mut pj_thread_t,
    /// < Destroy timer
    pub timer: pj_timer_entry,
    /// < Session status
    pub status: pj_status_t,
    /// < Result
    pub addr: pj_sockaddr,
    /// < Testing STUN sock
    pub stun_sock: *mut pj_stun_sock,
    /// < Address family
    pub af: ::std::os::raw::c_int,
    /// < Async resolution
    /// of STUN entry
    pub async_wait: pj_bool_t,
}

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pjsua_vid_win_type { PJSUA_WND_TYPE_NONE = 0, PJSUA_WND_TYPE_PREVIEW = 1, PJSUA_WND_TYPE_STREAM = 2 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsua_vid_win {
    /// < Type.
    pub type_: pjsua_vid_win_type,
    /// < Own pool.
    pub pool: *mut pj_pool_t,
    /// < Reference counter.
    pub ref_cnt: ::std::os::raw::c_uint,
    /// < Capture vidport.
    pub vp_cap: *mut pjmedia_vid_port,
    /// < Renderer vidport
    pub vp_rend: *mut pjmedia_vid_port,
    /// < Video tee
    pub tee: *mut pjmedia_port,
    /// < Capture dev id
    pub preview_cap_id: pjmedia_vid_dev_index,
    /// < Preview is started
    pub preview_running: pj_bool_t,
    /// < Preview is by dev
    pub is_native: pj_bool_t,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsua_timer_list { pub prev: *mut pjsua_timer_list, pub next: *mut pjsua_timer_list, pub entry: pj_timer_entry, pub cb: ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>, pub user_data: *mut ::std::os::raw::c_void }

/// Global pjsua application data.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pjsua_data {
    /// < Global pool factory.
    pub cp: pj_caching_pool,
    /// < pjsua's private pool.
    pub pool: *mut pj_pool_t,
    /// < Mutex protection for this data
    pub mutex: *mut pj_mutex_t,
    /// < Mutex nesting level.
    pub mutex_nesting_level: ::std::os::raw::c_uint,
    /// < Mutex owner.
    pub mutex_owner: *mut pj_thread_t,
    /// < Library state.
    pub state: pjsua_state,
    /// < Current logging config.
    pub log_cfg: pjsua_logging_config,
    /// <Output log file handle
    pub log_file: pj_oshandle_t,
    /// < Global endpoint.
    pub endpt: *mut pjsip_endpoint,
    /// < pjsua's PJSIP module.
    pub mod_: pjsip_module,
    /// < Array of transports.
    pub tpdata: [pjsua_transport_data; 8usize],
    /// < Old transport callback.
    pub old_tp_cb: pjsip_tp_state_callback,
    /// < Thread quit flag.
    pub thread_quit_flag: pj_bool_t,
    /// < Array of threads.
    pub thread: [*mut pj_thread_t; 4usize],
    /// < Global STUN settings.
    pub stun_cfg: pj_stun_config,
    /// < Resolved STUN server address
    pub stun_srv: pj_sockaddr,
    /// < STUN server status.
    pub stun_status: pj_status_t,
    /// < List of pending STUN resolution
    pub stun_res: pjsua_stun_resolve,
    /// < Resolved STUN server index
    pub stun_srv_idx: ::std::os::raw::c_uint,
    /// < DNS resolver.
    pub resolver: *mut pj_dns_resolver,
    /// < NAT type.
    pub nat_type: pj_stun_nat_type,
    /// < Detection status.
    pub nat_status: pj_status_t,
    /// < Detection in progress
    pub nat_in_progress: pj_bool_t,
    pub outbound_proxy: pjsip_route_hdr,
    /// < Number of accounts.
    pub acc_cnt: ::std::os::raw::c_uint,
    /// < Default account ID
    pub default_acc: pjsua_acc_id,
    /// < Account array.
    pub acc: [pjsua_acc; 12usize],
    /// < Acc sorted by prio
    pub acc_ids: [pjsua_acc_id; 12usize],
    /// < UA config.
    pub ua_cfg: pjsua_config,
    /// < Call counter.
    pub call_cnt: ::std::os::raw::c_uint,
    /// < Calls array.
    pub calls: [pjsua_call; 32usize],
    /// < Next call id to use
    pub next_call_id: pjsua_call_id,
    /// < Buddy count.
    pub buddy_cnt: ::std::os::raw::c_uint,
    /// < Buddy array.
    pub buddy: [pjsua_buddy; 256usize],
    /// < Presence refresh timer.
    pub pres_timer: pj_timer_entry,
    /// < Media config.
    pub media_cfg: pjsua_media_config,
    /// < Media endpoint.
    pub med_endpt: *mut pjmedia_endpt,
    /// < Additionan conf. bridge. param
    pub mconf_cfg: pjsua_conf_setting,
    /// < Conference bridge.
    pub mconf: *mut pjmedia_conf,
    /// < Are we using audio switchboard
    /// (a.k.a APS-Direct)
    pub is_mswitch: pj_bool_t,
    /// < Capture device ID.
    pub cap_dev: pjmedia_aud_dev_index,
    /// < Playback device ID.
    pub play_dev: pjmedia_aud_dev_index,
    /// < Which settings to save
    pub aud_svmask: pj_uint32_t,
    /// < User settings to sound dev
    pub aud_param: pjmedia_aud_param,
    /// < How many # device is opened
    pub aud_open_cnt: pj_bool_t,
    /// < No sound (app will manage it)
    pub no_snd: pj_bool_t,
    /// < Sound's private pool.
    pub snd_pool: *mut pj_pool_t,
    /// < Sound port.
    pub snd_port: *mut pjmedia_snd_port,
    /// < Sound device idle timer.
    pub snd_idle_timer: pj_timer_entry,
    /// < Master port for null sound.
    pub null_snd: *mut pjmedia_master_port,
    /// < Null port.
    pub null_port: *mut pjmedia_port,
    /// < Media flow is currently active
    pub snd_is_on: pj_bool_t,
    /// < Sound device mode.
    pub snd_mode: ::std::os::raw::c_uint,
    /// < Capture device ID.
    pub vcap_dev: pjmedia_vid_dev_index,
    /// < Playback device ID.
    pub vrdr_dev: pjmedia_vid_dev_index,
    /// < Number of file players.
    pub player_cnt: ::std::os::raw::c_uint,
    /// < Array of players.
    pub player: [pjsua_file_data; 32usize],
    /// < Number of file recorders.
    pub rec_cnt: ::std::os::raw::c_uint,
    /// < Array of recs.
    pub recorder: [pjsua_file_data; 32usize],
    pub timer_list: pjsua_timer_list,
    pub timer_mutex: *mut pj_mutex_t,
}

extern "C" {
    #[link_name = "\u{1}pjsua_var"]
    pub static mut pjsua_var: pjsua_data;
}

extern "C" {
    /// Get the instance of pjsua
    pub fn pjsua_get_var() -> *mut pjsua_data;
}

/// IM callback data.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjsua_im_data { pub acc_id: pjsua_acc_id, pub call_id: pjsua_call_id, pub to: pj_str_t, pub body: pj_str_t, pub user_data: *mut ::std::os::raw::c_void }

extern "C" { pub fn pjsua_media_apply_xml_control(call_id: pjsua_call_id, xml_st: *const pj_str_t) -> pj_status_t; }

extern "C" { pub fn pjsua_set_state(new_state: pjsua_state); }

extern "C" { pub fn pjsua_sip_acc_is_using_stun(acc_id: pjsua_acc_id) -> pj_bool_t; }

extern "C" { pub fn pjsua_media_acc_is_using_stun(acc_id: pjsua_acc_id) -> pj_bool_t; }

extern "C" { pub fn pjsua_sip_acc_is_using_ipv6(acc_id: pjsua_acc_id) -> pj_bool_t; }

extern "C" { pub fn pjsua_acc_get_uac_addr(acc_id: pjsua_acc_id, pool: *mut pj_pool_t, dst_uri: *const pj_str_t, addr: *mut pjsip_host_port, p_tp_type: *mut pjsip_transport_type_e, p_secure: *mut ::std::os::raw::c_int, p_tp: *mut *const ::std::os::raw::c_void) -> pj_status_t; }

extern "C" {
    /// Handle incoming invite request.
    pub fn pjsua_call_on_incoming(rdata: *mut pjsip_rx_data) -> pj_bool_t;
}

extern "C" { pub fn pjsua_media_channel_init(call_id: pjsua_call_id, role: pjsip_role_e, security_level: ::std::os::raw::c_int, tmp_pool: *mut pj_pool_t, rem_sdp: *const pjmedia_sdp_session, sip_err_code: *mut ::std::os::raw::c_int, async: pj_bool_t, cb: pjsua_med_tp_state_cb) -> pj_status_t; }

extern "C" { pub fn pjsua_media_channel_create_sdp(call_id: pjsua_call_id, pool: *mut pj_pool_t, rem_sdp: *const pjmedia_sdp_session, p_sdp: *mut *mut pjmedia_sdp_session, sip_err_code: *mut ::std::os::raw::c_int) -> pj_status_t; }

extern "C" { pub fn pjsua_media_channel_update(call_id: pjsua_call_id, local_sdp: *const pjmedia_sdp_session, remote_sdp: *const pjmedia_sdp_session) -> pj_status_t; }

extern "C" { pub fn pjsua_media_channel_deinit(call_id: pjsua_call_id) -> pj_status_t; }

extern "C" { pub fn pjsua_call_media_is_changing(call: *mut pjsua_call) -> pj_bool_t; }

extern "C" { pub fn pjsua_call_media_init(call_med: *mut pjsua_call_media, type_: pjmedia_type, tcfg: *const pjsua_transport_config, security_level: ::std::os::raw::c_int, sip_err_code: *mut ::std::os::raw::c_int, async: pj_bool_t, cb: pjsua_med_tp_state_cb) -> pj_status_t; }

extern "C" { pub fn pjsua_set_media_tp_state(call_med: *mut pjsua_call_media, tp_st: pjsua_med_tp_st); }

extern "C" { pub fn pjsua_media_prov_clean_up(call_id: pjsua_call_id); }

extern "C" {
    /// Init presence.
    pub fn pjsua_pres_init() -> pj_status_t;
}

extern "C" { pub fn pjsua_pres_start() -> pj_status_t; }

extern "C" {
    /// Refresh presence subscriptions
    pub fn pjsua_pres_refresh();
}

extern "C" { pub fn pjsua_pres_update_acc(acc_id: ::std::os::raw::c_int, force: pj_bool_t); }

extern "C" { pub fn pjsua_pres_shutdown(flags: ::std::os::raw::c_uint); }

extern "C" {
    /// Init presence for aoocunt.
    pub fn pjsua_pres_init_acc(acc_id: ::std::os::raw::c_int) -> pj_status_t;
}

extern "C" {
    /// Send PUBLISH
    pub fn pjsua_pres_init_publish_acc(acc_id: ::std::os::raw::c_int) -> pj_status_t;
}

extern "C" {
    /// Send un-PUBLISH
    pub fn pjsua_pres_unpublish(acc: *mut pjsua_acc, flags: ::std::os::raw::c_uint);
}

extern "C" {
    /// Terminate server subscription for the account
    pub fn pjsua_pres_delete_acc(acc_id: ::std::os::raw::c_int, flags: ::std::os::raw::c_uint);
}

extern "C" {
    /// Init IM module handler to handle incoming MESSAGE outside dialog.
    pub fn pjsua_im_init() -> pj_status_t;
}

extern "C" {
    /// Start MWI subscription
    pub fn pjsua_start_mwi(acc_id: pjsua_acc_id, force_renew: pj_bool_t) -> pj_status_t;
}

extern "C" {
    /// Init call subsystem.
    pub fn pjsua_call_subsys_init(cfg: *const pjsua_config) -> pj_status_t;
}

extern "C" {
    /// Start call subsystem.
    pub fn pjsua_call_subsys_start() -> pj_status_t;
}

extern "C" {
    /// Init media subsystems.
    pub fn pjsua_media_subsys_init(cfg: *const pjsua_media_config) -> pj_status_t;
}

extern "C" {
    /// Start pjsua media subsystem.
    pub fn pjsua_media_subsys_start() -> pj_status_t;
}

extern "C" {
    /// Destroy pjsua media subsystem.
    pub fn pjsua_media_subsys_destroy(flags: ::std::os::raw::c_uint) -> pj_status_t;
}

extern "C" {
    /// Private: check if we can accept the message.
   /// If not, then p_accept header will be filled with a valid
   /// Accept header.
    pub fn pjsua_im_accept_pager(rdata: *mut pjsip_rx_data, p_accept_hdr: *mut *mut pjsip_accept_hdr) -> pj_bool_t;
}

extern "C" {
    /// Private: process pager message.
   /// This may trigger pjsua_ui_on_pager() or pjsua_ui_on_typing().
    pub fn pjsua_im_process_pager(call_id: ::std::os::raw::c_int, from: *const pj_str_t, to: *const pj_str_t, rdata: *mut pjsip_rx_data);
}

extern "C" {
    /// Create Accept header for MESSAGE.
    pub fn pjsua_im_create_accept(pool: *mut pj_pool_t) -> *mut pjsip_accept_hdr;
}

extern "C" { pub fn pjsua_process_msg_data(tdata: *mut pjsip_tx_data, msg_data: *const pjsua_msg_data); }

extern "C" { pub fn pjsua_set_msg_route_set(tdata: *mut pjsip_tx_data, route_set: *const pjsip_route_hdr); }

extern "C" { pub fn pjsua_parse_media_type(pool: *mut pj_pool_t, mime: *const pj_str_t, media_type: *mut pjsip_media_type); }

extern "C" { pub fn pjsua_init_tpselector(tp_id: pjsua_transport_id, sel: *mut pjsip_tpselector); }

extern "C" { pub fn pjsua_aud_subsys_init() -> pj_status_t; }

extern "C" { pub fn pjsua_aud_subsys_start() -> pj_status_t; }

extern "C" { pub fn pjsua_aud_subsys_destroy() -> pj_status_t; }

extern "C" { pub fn pjsua_aud_stop_stream(call_med: *mut pjsua_call_media); }

extern "C" { pub fn pjsua_aud_channel_update(call_med: *mut pjsua_call_media, tmp_pool: *mut pj_pool_t, si: *mut pjmedia_stream_info, local_sdp: *const pjmedia_sdp_session, remote_sdp: *const pjmedia_sdp_session) -> pj_status_t; }

extern "C" { pub fn pjsua_check_snd_dev_idle(); }

extern "C" { pub fn pjsua_vid_subsys_init() -> pj_status_t; }

extern "C" { pub fn pjsua_vid_subsys_start() -> pj_status_t; }

extern "C" { pub fn pjsua_vid_subsys_destroy() -> pj_status_t; }

extern "C" { pub fn pjsua_vid_stop_stream(call_med: *mut pjsua_call_media); }

extern "C" { pub fn pjsua_vid_channel_init(call_med: *mut pjsua_call_media) -> pj_status_t; }

extern "C" { pub fn pjsua_vid_channel_update(call_med: *mut pjsua_call_media, tmp_pool: *mut pj_pool_t, si: *mut pjmedia_vid_stream_info, local_sdp: *const pjmedia_sdp_session, remote_sdp: *const pjmedia_sdp_session) -> pj_status_t; }

extern "C" { pub fn pjsua_call_schedule_reinvite_check(call: *mut pjsua_call, delay_ms: ::std::os::raw::c_uint); }

extern "C" { pub fn pjsua_acc_update_contact_on_ip_change(acc: *mut pjsua_acc) -> pj_status_t; }

extern "C" { pub fn pjsua_acc_handle_call_on_ip_change(acc: *mut pjsua_acc) -> pj_status_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_aud_dev_factory_op { pub init: ::std::option::Option<unsafe extern "C" fn(f: *mut pjmedia_aud_dev_factory) -> pj_status_t>, pub destroy: ::std::option::Option<unsafe extern "C" fn(f: *mut pjmedia_aud_dev_factory) -> pj_status_t>, pub get_dev_count: ::std::option::Option<unsafe extern "C" fn(f: *mut pjmedia_aud_dev_factory) -> ::std::os::raw::c_uint>, pub get_dev_info: ::std::option::Option<unsafe extern "C" fn(f: *mut pjmedia_aud_dev_factory, index: ::std::os::raw::c_uint, info: *mut pjmedia_aud_dev_info) -> pj_status_t>, pub default_param: ::std::option::Option<unsafe extern "C" fn(f: *mut pjmedia_aud_dev_factory, index: ::std::os::raw::c_uint, param: *mut pjmedia_aud_param) -> pj_status_t>, pub create_stream: ::std::option::Option<unsafe extern "C" fn(f: *mut pjmedia_aud_dev_factory, param: *const pjmedia_aud_param, rec_cb: pjmedia_aud_rec_cb, play_cb: pjmedia_aud_play_cb, user_data: *mut ::std::os::raw::c_void, p_aud_strm: *mut *mut pjmedia_aud_stream) -> pj_status_t>, pub refresh: ::std::option::Option<unsafe extern "C" fn(f: *mut pjmedia_aud_dev_factory) -> pj_status_t> }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_aud_dev_factory { pub sys: pjmedia_aud_dev_factory__bindgen_ty_1, pub op: *mut pjmedia_aud_dev_factory_op }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_aud_dev_factory__bindgen_ty_1 { pub drv_idx: ::std::os::raw::c_uint }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_aud_stream_op { pub get_param: ::std::option::Option<unsafe extern "C" fn(strm: *mut pjmedia_aud_stream, param: *mut pjmedia_aud_param) -> pj_status_t>, pub get_cap: ::std::option::Option<unsafe extern "C" fn(strm: *mut pjmedia_aud_stream, cap: pjmedia_aud_dev_cap, value: *mut ::std::os::raw::c_void) -> pj_status_t>, pub set_cap: ::std::option::Option<unsafe extern "C" fn(strm: *mut pjmedia_aud_stream, cap: pjmedia_aud_dev_cap, value: *const ::std::os::raw::c_void) -> pj_status_t>, pub start: ::std::option::Option<unsafe extern "C" fn(strm: *mut pjmedia_aud_stream) -> pj_status_t>, pub stop: ::std::option::Option<unsafe extern "C" fn(strm: *mut pjmedia_aud_stream) -> pj_status_t>, pub destroy: ::std::option::Option<unsafe extern "C" fn(strm: *mut pjmedia_aud_stream) -> pj_status_t> }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_aud_stream { pub sys: pjmedia_aud_stream__bindgen_ty_1, pub op: *mut pjmedia_aud_stream_op }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_aud_stream__bindgen_ty_1 { pub drv_idx: ::std::os::raw::c_uint }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_aud_test_stat { pub frame_cnt: ::std::os::raw::c_uint, pub min_interval: ::std::os::raw::c_uint, pub max_interval: ::std::os::raw::c_uint, pub avg_interval: ::std::os::raw::c_uint, pub dev_interval: ::std::os::raw::c_uint, pub max_burst: ::std::os::raw::c_uint }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjmedia_aud_test_results { pub rec: pjmedia_aud_test_stat, pub play: pjmedia_aud_test_stat, pub rec_drift_per_sec: pj_int32_t }

extern "C" { pub fn pjmedia_aud_test(param: *const pjmedia_aud_param, result: *mut pjmedia_aud_test_results) -> pj_status_t; }

pub type __builtin_va_list = __va_list;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list { pub __ap: *mut ::std::os::raw::c_void }